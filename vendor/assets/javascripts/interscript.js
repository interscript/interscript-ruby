(function(undefined) {
  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var global_object = this, console;

  // Detect the global object
  if (typeof(global) !== 'undefined') { global_object = global; }
  if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(this.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return this.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = this.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported fearures
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $hasOwn       = Object.hasOwnProperty;
  var $bind         = Function.prototype.bind;
  var $setPrototype = Object.setPrototypeOf;
  var $slice        = Array.prototype.slice;
  var $splice       = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and nil do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Truth
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, result, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, result, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Don not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $setPrototype(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $setPrototype(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $setPrototype(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (superclass != null && !superclass.hasOwnProperty('$$is_class')) {
      bridged = superclass;
      superclass = _Object;
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $setPrototype(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singletin_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $setPrototype(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singletin_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $setPrototype(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $setPrototype(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($hasOwn.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var proto = includer.$$prototype, parent = proto, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (isRoot(module_iclass) && module_iclass.$$module === module) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      var next_ancestor = Object.getPrototypeOf(module_iclass);

      // skip non-root iclasses (that were recursively included)
      while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
        next_ancestor = Object.getPrototypeOf(next_ancestor);
      }

      start_chain_after = parent;
      end_chain_on = next_ancestor;
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $setPrototype(dummy_prepender, prepender_iclass);
      $setPrototype(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $setPrototype(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    var klass_to_inject, klass_reference;

    klass_to_inject = klass.$$super || Opal.Object;
    klass_reference = klass;
    var original_prototype = klass.$$prototype;

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $setPrototype(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        var method = proto[jsid];

        if (!method.$$stub) {
          super_method = method;
        }
        break;
      }
    }

    if (!defcheck && super_method == null && Opal.Kernel.$method_missing === obj.$method_missing) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body = (typeof(method) === 'string') ? recv['$'+method] : method;

    if (body != null) {
      if (typeof block === 'function') {
        body.$$p = block;
      }
      return body.apply(recv, args);
    }

    return recv.$method_missing.apply(recv, [method].concat(args));
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$hasOwn.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be ovrewritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Try to make the browser pick the right name
    alias.displayName       = name;
    alias.length            = body.length;
    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($hasOwn.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($hasOwn.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$hasOwn.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($hasOwn.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $setPrototype(Opal.BasicObject, Opal.Class.$$prototype);
  $setPrototype(Opal.Object, Opal.Class.$$prototype);
  $setPrototype(Opal.Module, Opal.Class.$$prototype);
  $setPrototype(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Add a short helper to navigate constants manually.
  // @example
  //   Opal.$$.Regexp.$$.IGNORECASE
  Opal.$$ = _Object.$$;

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.0.3 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_type_error$2, $Opal_coerce_to$3, $Opal_coerce_to$excl$4, $Opal_coerce_to$ques$5, $Opal_try_convert$6, $Opal_compare$7, $Opal_destructure$8, $Opal_respond_to$ques$9, $Opal_inspect_obj$10, $Opal_instance_variable_name$excl$11, $Opal_class_variable_name$excl$12, $Opal_const_name$excl$13, $Opal_pristine$14;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$type_error', $Opal_type_error$2 = function $$type_error(object, type, method, coerced) {
      var $a, self = this;

      
      
      if (method == null) {
        method = nil;
      };
      
      if (coerced == null) {
        coerced = nil;
      };
      if ($truthy(($truthy($a = method) ? coerced : $a))) {
        return $$($nesting, 'TypeError').$new("" + "can't convert " + (object.$class()) + " into " + (type) + " (" + (object.$class()) + "#" + (method) + " gives " + (coerced.$class()) + ")")
      } else {
        return $$($nesting, 'TypeError').$new("" + "no implicit conversion of " + (object.$class()) + " into " + (type))
      };
    }, $Opal_type_error$2.$$arity = -3);
    Opal.defs(self, '$coerce_to', $Opal_coerce_to$3 = function $$coerce_to(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        self.$raise(self.$type_error(object, type))
      };
      return object.$__send__(method);
    }, $Opal_coerce_to$3.$$arity = 3);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$4 = function(object, type, method) {
      var self = this, coerced = nil;

      
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$4.$$arity = 3);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$5 = function(object, type, method) {
      var self = this, coerced = nil;

      
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$5.$$arity = 3);
    Opal.defs(self, '$try_convert', $Opal_try_convert$6 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$6.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$7 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$7.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$8 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$8.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$9 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$9.$$arity = -3);
    Opal.defs(self, '$inspect_obj', $Opal_inspect_obj$10 = function $$inspect_obj(obj) {
      var self = this;

      return Opal.inspect(obj);
    }, $Opal_inspect_obj$10.$$arity = 1);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$11 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$11.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$12 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$12.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$13 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$13.$$arity = 1);
    Opal.defs(self, '$pristine', $Opal_pristine$14 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$14.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $lambda = Opal.lambda, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr_reader$14, $Module_attr_writer$15, $Module_autoload$16, $Module_class_variables$17, $Module_class_variable_get$18, $Module_class_variable_set$19, $Module_class_variable_defined$ques$20, $Module_remove_class_variable$21, $Module_constants$22, $Module_constants$23, $Module_nesting$24, $Module_const_defined$ques$25, $Module_const_get$26, $Module_const_missing$28, $Module_const_set$29, $Module_public_constant$30, $Module_define_method$31, $Module_remove_method$33, $Module_singleton_class$ques$34, $Module_include$35, $Module_included_modules$36, $Module_include$ques$37, $Module_instance_method$38, $Module_instance_methods$39, $Module_included$40, $Module_extended$41, $Module_extend_object$42, $Module_method_added$43, $Module_method_removed$44, $Module_method_undefined$45, $Module_module_eval$46, $Module_module_exec$48, $Module_method_defined$ques$49, $Module_module_function$50, $Module_name$51, $Module_prepend$52, $Module_prepend_features$53, $Module_prepended$54, $Module_remove_const$55, $Module_to_s$56, $Module_undef_method$57, $Module_instance_variables$58, $Module_dup$59, $Module_copy_class_variables$60, $Module_copy_constants$61;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    Opal.alias(self, "attr", "attr_accessor");
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$14 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$14.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$15 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$15.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$16 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$16.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$17 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$17.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$18 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      var value = Opal.class_variables(self)[name];
      if (value == null) {
        self.$raise($$($nesting, 'NameError').$new("" + "uninitialized class variable " + (name) + " in " + (self), name))
      }
      return value;
    ;
    }, $Module_class_variable_get$18.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$19 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$19.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$20 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$20.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$21 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$21.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$22 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$22.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$24 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$24.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$25 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$25.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$26 = function $$const_get(name, inherit) {
      var $$27, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$27 = function(o, c){var self = $$27.$$s || this;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$27.$$s = self, $$27.$$arity = 2, $$27))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$26.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$28 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$28.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$29 = function $$const_set(name, value) {
      var $a, self = this;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(($truthy($a = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))) ? $a : name['$start_with?']("::")))) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$29.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$30 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$30.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$31 = function $$define_method(name, method) {
      var $iter = $Module_define_method$31.$$p, block = $iter || nil, $a, $$32, self = this, $case = nil;

      if ($iter) $Module_define_method$31.$$p = null;
      
      
      if ($iter) $Module_define_method$31.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = ($truthy($a = block) ? $a : (function() {$case = method;
      if ($$($nesting, 'Proc')['$===']($case)) {return method}
      else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
      else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$32 = function($b){var self = $$32.$$s || this, $post_args, args, bound = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        bound = method.$bind(self);
        return $send(bound, 'call', Opal.to_a(args));}, $$32.$$s = self, $$32.$$arity = -1, $$32))}
      else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})());
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$31.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$33 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$33.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$34 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$34.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$35 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$35.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$36 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$36.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$37 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$37.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$38 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$38.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$39 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$39.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$40 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$40.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$41 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$41.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$42 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$42.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$43 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$43.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$44 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$44.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$45 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$45.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$46 = function $$module_eval($a) {
      var $iter = $Module_module_eval$46.$$p, block = $iter || nil, $post_args, args, $b, $$47, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$46.$$p = null;
      
      
      if ($iter) $Module_module_eval$46.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$47 = function(){var self = $$47.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$47.$$s = self, $$47.$$arity = 0, $$47));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$46.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$48 = function $$module_exec($a) {
      var $iter = $Module_module_exec$48.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$48.$$p = null;
      
      
      if ($iter) $Module_module_exec$48.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$48.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$49 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$49.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$50 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$50.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$51 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$51.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$52 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$52.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$53 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$53.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$54 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$54.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$55 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$55.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$56 = function $$to_s() {
      var $a, self = this;

      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">")
    }, $Module_to_s$56.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$57 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$57.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$58 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$58.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$59 = function $$dup() {
      var $iter = $Module_dup$59.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$59.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$59, false), $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$59.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$60 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$60.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$61 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$61.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && (singleton_of.$$is_a_module)) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }
      return $send(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false), [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_class$14, $BasicObject_method_missing$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$class', $BasicObject_class$14 = function() {
      var self = this;

      return self.$$class;
    }, $BasicObject_class$14.$$arity = 0);
    return (Opal.def(self, '$method_missing', $BasicObject_method_missing$15 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$15.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$15.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$15.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$15.$$arity = -2), nil) && 'method_missing';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$coerce_to', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$50, $Kernel_rand$51, $Kernel_respond_to$ques$52, $Kernel_respond_to_missing$ques$53, $Kernel_require$54, $Kernel_require_relative$55, $Kernel_require_tree$56, $Kernel_singleton_class$57, $Kernel_sleep$58, $Kernel_srand$59, $Kernel_String$60, $Kernel_tap$61, $Kernel_to_proc$62, $Kernel_to_s$63, $Kernel_catch$64, $Kernel_throw$65, $Kernel_open$66, $Kernel_yield_self$67;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var $a, self = this;

      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, $a, self = this;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      return $gvars.__at_exit__['$<<'](block);
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return [];
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $$($nesting, 'Opal').$coerce_to(status, $$($nesting, 'Integer'), "to_int")
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var $a, self = this;

      
      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s || this;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {e = $err;
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s || this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a) {
      var $post_args, strs, $b, self = this;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$50 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$50.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$51 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$51.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$52 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      if ($truthy(self['$respond_to_missing?'](name, include_all))) {
        return true};
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
    ;
      return false;
    }, $Kernel_respond_to$ques$52.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$53 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$53.$$arity = -2);
    
    Opal.def(self, '$require', $Kernel_require$54 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$54.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$55 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$55.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$56 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$56.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$57 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$57.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$58 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return seconds;
    ;
    }, $Kernel_sleep$58.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$59 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$59.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$60 = function $$String(str) {
      var $a, self = this;

      return ($truthy($a = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")) ? $a : $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s"))
    }, $Kernel_String$60.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$61 = function $$tap() {
      var $iter = $Kernel_tap$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$61.$$p = null;
      
      
      if ($iter) $Kernel_tap$61.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$61.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$62 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$63 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$63.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$64 = function(sym) {
      var $iter = $Kernel_catch$64.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$64.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {e = $err;
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$64.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$65 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$65.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$66 = function $$open($a) {
      var $iter = $Kernel_open$66.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$66.$$p = null;
      
      
      if ($iter) $Kernel_open$66.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$66.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$67 = function $$yield_self() {
      var $$68, $iter = $Kernel_yield_self$67.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$67.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$68 = function(){var self = $$68.$$s || this;

        return 1}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$67.$$arity = 0);
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      cloned.stack = self.stack;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = backtrace.join('\n');
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, self.$$class.$$prototype), [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false), ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false), [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false), [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false), [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var $a, self = this;

      return ($truthy($a = self.receiver) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no receiver is available"))
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var $a, self = this;

      return ($truthy($a = self.key) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no key is available"))
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "2.5.7");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.0.3");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2020-02-01");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2020 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$equal?', '$<=>']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) > 0;;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) >= 0;;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) < 0;;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) <= 0;;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
      } else {
        fail_comparison(min, max)
      };
      if ($truthy(normalize(cmp) > 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy(normalize(self['$<=>'](min)) < 0)) {
        return min};
      if ($truthy(normalize(self['$<=>'](max)) > 0)) {
        return max};
      return self;
    }, $Comparable_clamp$7.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false), $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      return (Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2), nil) && 'new';
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var $a, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      return ($truthy($a = self.$match(string)) ? $gvars["~"].$begin(0) : $a)
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return false;
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var $a, $b, $c, $d, self = this;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$encoding', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chars$17, $String_chomp$18, $String_chop$19, $String_chr$20, $String_clone$21, $String_dup$22, $String_count$23, $String_delete$24, $String_delete_prefix$25, $String_delete_suffix$26, $String_downcase$27, $String_each_char$28, $String_each_line$30, $String_empty$ques$31, $String_end_with$ques$32, $String_gsub$33, $String_hash$34, $String_hex$35, $String_include$ques$36, $String_index$37, $String_inspect$38, $String_intern$39, $String_lines$40, $String_length$41, $String_ljust$42, $String_lstrip$43, $String_ascii_only$ques$44, $String_match$45, $String_match$ques$46, $String_next$47, $String_oct$48, $String_ord$49, $String_partition$50, $String_reverse$51, $String_rindex$52, $String_rjust$53, $String_rpartition$54, $String_rstrip$55, $String_scan$56, $String_split$57, $String_squeeze$58, $String_start_with$ques$59, $String_strip$60, $String_sub$61, $String_sum$62, $String_swapcase$63, $String_to_f$64, $String_to_i$65, $String_to_proc$66, $String_to_s$68, $String_tr$69, $String_tr_s$70, $String_upcase$71, $String_upto$72, $String_instance_variables$73, $String__load$74, $String_unicode_normalize$75, $String_unicode_normalized$ques$76, $String_unpack$77, $String_unpack1$78;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function(str) {
      var self = this;

      
      
      if (str == null) {
        str = "";
      };
      str = $$($nesting, 'Opal').$coerce_to(str, $$($nesting, 'String'), "to_str");
      return new self.$$constructor(str);;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize(str) {
      var self = this;

      
      ;
      
      if (str === undefined) {
        return self;
      }
    ;
      return self.$raise($$($nesting, 'NotImplementedError'), "Mutable strings are not supported in Opal.");
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str");
      return self + other.$to_s();
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($$($nesting, 'Opal')['$respond_to?'](other, "to_str")) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");
        index   = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int");

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return self.$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str").$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chars', $String_chars$17 = function $$chars() {
      var $iter = $String_chars$17.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$17.$$p = null;
      
      
      if ($iter) $String_chars$17.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$17.$$arity = 0);
    
    Opal.def(self, '$chomp', $String_chomp$18 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$18.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$19 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$19.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$20 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$20.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$21 = function $$clone() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$21.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$22 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$22.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$23 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$23.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$24 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$24.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$25 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        (prefix = $$($nesting, 'Opal').$coerce_to(prefix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$25.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$26 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        (suffix = $$($nesting, 'Opal').$coerce_to(suffix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$26.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$27 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$27.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$28 = function $$each_char() {
      var $iter = $String_each_char$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $String_each_char$28.$$p = null;
      
      
      if ($iter) $String_each_char$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.charAt(i));
      }
    ;
      return self;
    }, $String_each_char$28.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$30 = function $$each_line(separator) {
      var $iter = $String_each_line$30.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$30.$$p = null;
      
      
      if ($iter) $String_each_line$30.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $$($nesting, 'Opal').$coerce_to(separator, $$($nesting, 'String'), "to_str")

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$30.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$31 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$31.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$32 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $$($nesting, 'Opal').$coerce_to(suffixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$32.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$33 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$33.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$33.$$p = null;
      
      
      if ($iter) $String_gsub$33.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (_replacement + self.slice(index, match.index + 1))
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$33.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$34 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$34.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$35 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$35.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$36 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        (other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str"))
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$36.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$37 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$37.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$38 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$38.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$39 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$39.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$40 = function $$lines(separator) {
      var $iter = $String_lines$40.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$40.$$p = null;
      
      
      if ($iter) $String_lines$40.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$40.$$arity = -1);
    
    Opal.def(self, '$length', $String_length$41 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$41.$$arity = 0);
    
    Opal.def(self, '$ljust', $String_ljust$42 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$42.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$43 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$43.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$44 = function() {
      var self = this;

      
      if (self.$encoding()['$==']($$$($$($nesting, 'Encoding'), 'UTF_16BE'))) {
        return false};
      return /^[\x00-\x7F]*$/.test(self);;
    }, $String_ascii_only$ques$44.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$45 = function $$match(pattern, pos) {
      var $iter = $String_match$45.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $String_match$45.$$p = null;
      
      
      if ($iter) $String_match$45.$$p = null;;
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$45.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$46 = function(pattern, pos) {
      var $a, self = this;

      
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$46.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$47 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$47.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$48 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$48.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$49 = function $$ord() {
      var self = this;

      return self.charCodeAt(0);
    }, $String_ord$49.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$50 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$50.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$51 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$51.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$52 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$52.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$53 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$53.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$54 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$54.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$55 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$55.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$56 = function $$scan(pattern) {
      var $iter = $String_scan$56.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$56.$$p = null;
      
      
      if ($iter) $String_scan$56.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$56.$$arity = 1);
    Opal.alias(self, "size", "length");
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$57 = function $$split(pattern, limit) {
      var $a, self = this;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy($a = $gvars[";"]) ? $a : " ");
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str").$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$57.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$58 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$58.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$59 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        var prefix = $$($nesting, 'Opal').$coerce_to(prefixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    ;
    }, $String_start_with$ques$59.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$60 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$60.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$61 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$61.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$61.$$p = null;
      
      
      if ($iter) $String_sub$61.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$61.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$62 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$62.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$63 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$63.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$64 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$64.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$65 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$65.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$66 = function $$to_proc() {
      var $$67, $iter = $String_to_proc$66.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$66.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$67 = function($a){var self = $$67.$$s || this, $iter = $$67.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$67.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$67.$$s = self, $$67.$$arity = -1, $$67));
    }, $String_to_proc$66.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$68 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$68.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$69 = function $$tr(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr$69.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$70 = function $$tr_s(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr_s$70.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$71 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$71.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$72 = function $$upto(stop, excl) {
      var $iter = $String_upto$72.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$72.$$p = null;
      
      
      if ($iter) $String_upto$72.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      stop = $$($nesting, 'Opal').$coerce_to(stop, $$($nesting, 'String'), "to_str");
      
      var a, b, s = self.toString();

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$72.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $$($nesting, 'Opal').$coerce_to(sets[i], $$($nesting, 'String'), "to_str");
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$73 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$73.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$74 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$74.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$75 = function $$unicode_normalize(form) {
      var self = this;

      
      ;
      return self.toString();;
    }, $String_unicode_normalize$75.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$76 = function(form) {
      var self = this;

      
      ;
      return true;
    }, $String_unicode_normalized$ques$76.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$77 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$77.$$arity = 1);
    return (Opal.def(self, '$unpack1', $String_unpack1$78 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$78.$$arity = 1), nil) && 'unpack1';
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_find_all$40, $Enumerable_find_index$42, $Enumerable_first$45, $Enumerable_grep$48, $Enumerable_grep_v$50, $Enumerable_group_by$52, $Enumerable_include$ques$54, $Enumerable_inject$56, $Enumerable_lazy$57, $Enumerable_enumerator_size$59, $Enumerable_max$60, $Enumerable_max_by$61, $Enumerable_min$63, $Enumerable_min_by$64, $Enumerable_minmax$66, $Enumerable_minmax_by$68, $Enumerable_none$ques$69, $Enumerable_one$ques$73, $Enumerable_partition$77, $Enumerable_reject$79, $Enumerable_reverse_each$81, $Enumerable_slice_before$83, $Enumerable_slice_after$85, $Enumerable_slice_when$88, $Enumerable_sort$90, $Enumerable_sort_by$92, $Enumerable_sum$97, $Enumerable_take$99, $Enumerable_take_while$100, $Enumerable_uniq$102, $Enumerable_zip$104;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s || this;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s || this;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s || this;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s || this;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s || this;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s || this;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var result,
          all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s || this, $a, enum_size = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [], result = nil;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return result;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s || this;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s || this;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var result,
          slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s || this;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var result,
          index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);

      if (result !== undefined) {
        return result;
      }
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s || this;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$40 = function $$find_all() {
      var $iter = $Enumerable_find_all$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_find_all$40.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$41 = function(){var self = $$41.$$s || this;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$40.$$arity = 0);
    
    Opal.def(self, '$find_index', $Enumerable_find_index$42 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$42.$$p, block = $iter || nil, $$43, $$44, self = this, index = nil;

      if ($iter) $Enumerable_find_index$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$42.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$43 = function($a){var self = $$43.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$43.$$s = self, $$43.$$arity = -1, $$43))
      } else {
        $send(self, 'each', [], ($$44 = function($a){var self = $$44.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$44.$$s = self, $$44.$$arity = -1, $$44))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$42.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$45 = function $$first(number) {try {

      var $$46, $$47, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$46 = function(value){var self = $$46.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$46.$$s = self, $$46.$$arity = 1, $$46))
      } else {
        
        result = [];
        number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$47 = function($a){var self = $$47.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$47.$$s = self, $$47.$$arity = -1, $$47));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$45.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$48 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$48.$$p, block = $iter || nil, $$49, self = this, result = nil;

      if ($iter) $Enumerable_grep$48.$$p = null;
      
      
      if ($iter) $Enumerable_grep$48.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$49.$$s = self, $$49.$$arity = -1, $$49));
      return result;
    }, $Enumerable_grep$48.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$50 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep_v$50.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$52 = function $$group_by() {
      var $iter = $Enumerable_group_by$52.$$p, block = $iter || nil, $$53, $a, self = this, hash = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$52.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$52.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$53 = function(){var self = $$53.$$s || this;

        return self.$enumerator_size()}, $$53.$$s = self, $$53.$$arity = 0, $$53))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$52.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$54 = function(obj) {try {

      var $$55, self = this;

      
      $send(self, 'each', [], ($$55 = function($a){var self = $$55.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$55.$$s = self, $$55.$$arity = -1, $$55));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$54.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$56 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$56.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$56.$$p = null;
      
      
      if ($iter) $Enumerable_inject$56.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$56.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$57 = function $$lazy() {
      var $$58, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$58 = function(enum$, $a){var self = $$58.$$s || this, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$58.$$s = self, $$58.$$arity = -2, $$58))
    }, $Enumerable_lazy$57.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$59 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$59.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$60 = function $$max(n) {
      var $iter = $Enumerable_max$60.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$60.$$p = null;
      
      
      if ($iter) $Enumerable_max$60.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }
    ;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$60.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$61 = function $$max_by() {
      var $iter = $Enumerable_max_by$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Enumerable_max_by$61.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$enumerator_size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$61.$$arity = 0);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$63 = function $$min() {
      var $iter = $Enumerable_min$63.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_min$63.$$p = null;
      
      
      if ($iter) $Enumerable_min$63.$$p = null;;
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$63.$$arity = 0);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$64 = function $$min_by() {
      var $iter = $Enumerable_min_by$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Enumerable_min_by$64.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by"], ($$65 = function(){var self = $$65.$$s || this;

        return self.$enumerator_size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$64.$$arity = 0);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$66 = function $$minmax() {
      var $iter = $Enumerable_minmax$66.$$p, block = $iter || nil, $a, $$67, self = this;

      if ($iter) $Enumerable_minmax$66.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$66.$$p = null;;
      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], ($$67 = function(a, b){var self = $$67.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$<=>'](b);}, $$67.$$s = self, $$67.$$arity = 2, $$67)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$66.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$68 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$68.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_minmax_by$68.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$68.$$p = null;;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Enumerable_minmax_by$68.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$69 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$69.$$p, block = $iter || nil, $$70, $$71, $$72, self = this;

      if ($iter) $Enumerable_none$ques$69.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$69.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$70 = function($a){var self = $$70.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$70.$$s = self, $$70.$$arity = -1, $$70))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$71 = function($a){var self = $$71.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$71.$$s = self, $$71.$$arity = -1, $$71))
      } else {
        $send(self, 'each', [], ($$72 = function($a){var self = $$72.$$s || this, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$72.$$s = self, $$72.$$arity = -1, $$72))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$69.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$73.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$73.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$77 = function $$partition() {
      var $iter = $Enumerable_partition$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Enumerable_partition$77.$$p = null;
      
      
      if ($iter) $Enumerable_partition$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$enumerator_size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$77.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$79 = function $$reject() {
      var $iter = $Enumerable_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Enumerable_reject$79.$$p = null;
      
      
      if ($iter) $Enumerable_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s || this;

        return self.$enumerator_size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$79.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$81 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_reverse_each$81.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$82 = function(){var self = $$82.$$s || this;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$81.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$83 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_slice_before$83.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$83.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$84 = function(e){var self = $$84.$$s || this;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$84.$$s = self, $$84.$$arity = 1, $$84));
    }, $Enumerable_slice_before$83.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$85 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$85.$$p, block = $iter || nil, $$86, $$87, self = this;

      if ($iter) $Enumerable_slice_after$85.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$85.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$86 = function(e){var self = $$86.$$s || this;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$86.$$s = self, $$86.$$arity = 1, $$86))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$87 = function(yielder){var self = $$87.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$87.$$s = self, $$87.$$arity = 1, $$87));
    }, $Enumerable_slice_after$85.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$88 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$88.$$p, block = $iter || nil, $$89, self = this;

      if ($iter) $Enumerable_slice_when$88.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$88.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$89 = function(yielder){var self = $$89.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$89.$$s = self, $$89.$$arity = 1, $$89));
    }, $Enumerable_slice_when$88.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$90 = function $$sort() {
      var $iter = $Enumerable_sort$90.$$p, block = $iter || nil, $$91, self = this, ary = nil;

      if ($iter) $Enumerable_sort$90.$$p = null;
      
      
      if ($iter) $Enumerable_sort$90.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$91 = function(a, b){var self = $$91.$$s || this;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$91.$$s = self, $$91.$$arity = 2, $$91))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$90.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$92 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$92.$$p, block = $iter || nil, $$93, $$94, $$95, $$96, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$92.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$enumerator_size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      dup = $send(self, 'map', [], ($$94 = function(){var self = $$94.$$s || this, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$94.$$s = self, $$94.$$arity = 0, $$94));
      $send(dup, 'sort!', [], ($$95 = function(a, b){var self = $$95.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$95.$$s = self, $$95.$$arity = 2, $$95));
      return $send(dup, 'map!', [], ($$96 = function(i){var self = $$96.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$96.$$s = self, $$96.$$arity = 1, $$96));
    }, $Enumerable_sort_by$92.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$97 = function $$sum(initial) {
      var $$98, $iter = $Enumerable_sum$97.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$97.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$98 = function($a){var self = $$98.$$s || this, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$98.$$s = self, $$98.$$arity = -1, $$98));
      return result;
    }, $Enumerable_sum$97.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$99 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$99.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$100 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$100.$$p, block = $iter || nil, $$101, self = this, result = nil;

      if ($iter) $Enumerable_take_while$100.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$100.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$101 = function($a){var self = $$101.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$101.$$s = self, $$101.$$arity = -1, $$101));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$100.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$102 = function $$uniq() {
      var $iter = $Enumerable_uniq$102.$$p, block = $iter || nil, $$103, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$102.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$102.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$103 = function($a){var self = $$103.$$s || this, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$103.$$s = self, $$103.$$arity = -1, $$103));
      return hash.$values();
    }, $Enumerable_uniq$102.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$zip', $Enumerable_zip$104 = function $$zip($a) {
      var $iter = $Enumerable_zip$104.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$104.$$p = null;
      
      
      if ($iter) $Enumerable_zip$104.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$104.$$arity = -1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_inspect$7;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy(self.size)) {
          return (self.size = $$($nesting, 'Opal').$coerce_to(self.size, $$($nesting, 'Integer'), "to_int"))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, $b, self = this;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy($$($nesting, 'Proc')['$==='](self.size))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int")
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s || this;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$inspect', $Enumerator_inspect$7 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$7.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$8, $Generator_each$9;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$8 = function $$initialize() {
        var $iter = $Generator_initialize$8.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$8.$$p = null;
        
        
        if ($iter) $Generator_initialize$8.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$8.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$9 = function $$each($a) {
        var $iter = $Generator_each$9.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$9.$$p = null;
        
        
        if ($iter) $Generator_each$9.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$9.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$10, $Yielder_yield$11, $Yielder_$lt$lt$12;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$10 = function $$initialize() {
        var $iter = $Yielder_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$10.$$p = null;
        
        
        if ($iter) $Yielder_initialize$10.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$10.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$11 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$11.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$12 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$12.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$13, $Lazy_lazy$16, $Lazy_collect$17, $Lazy_collect_concat$19, $Lazy_drop$23, $Lazy_drop_while$25, $Lazy_enum_for$27, $Lazy_find_all$28, $Lazy_grep$30, $Lazy_reject$33, $Lazy_take$35, $Lazy_take_while$37, $Lazy_inspect$39;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$13 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$13.$$p, block = $iter || nil, $$14, self = this;

        if ($iter) $Lazy_initialize$13.$$p = null;
        
        
        if ($iter) $Lazy_initialize$13.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$13, false), [size], ($$14 = function(yielder, $a){var self = $$14.$$s || this, $post_args, each_args, $$15;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$15 = function($b){var self = $$15.$$s || this, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$15.$$s = self, $$15.$$arity = -1, $$15))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$14.$$s = self, $$14.$$arity = -2, $$14));
      }, $Lazy_initialize$13.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$16 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$16.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$17 = function $$collect() {
        var $iter = $Lazy_collect$17.$$p, block = $iter || nil, $$18, self = this;

        if ($iter) $Lazy_collect$17.$$p = null;
        
        
        if ($iter) $Lazy_collect$17.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$18 = function(enum$, $a){var self = $$18.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$18.$$s = self, $$18.$$arity = -2, $$18));
      }, $Lazy_collect$17.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$19 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect_concat$19.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$20 = function(enum$, $a){var self = $$20.$$s || this, $post_args, args, $$21, $$22;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$21 = function(v){var self = $$21.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$21.$$s = self, $$21.$$arity = 1, $$21))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$22 = function(v){var self = $$22.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$22.$$s = self, $$22.$$arity = 1, $$22));
            }
          }
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect_concat$19.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$23 = function $$drop(n) {
        var $$24, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$24 = function(enum$, $a){var self = $$24.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$24.$$s = self, $$24.$$arity = -2, $$24));
      }, $Lazy_drop$23.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$25 = function $$drop_while() {
        var $iter = $Lazy_drop_while$25.$$p, block = $iter || nil, $$26, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$25.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$25.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$26 = function(enum$, $a){var self = $$26.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop_while$25.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$27 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$27.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$27.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$27.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$27.$$arity = -1);
      
      Opal.def(self, '$find_all', $Lazy_find_all$28 = function $$find_all() {
        var $iter = $Lazy_find_all$28.$$p, block = $iter || nil, $$29, self = this;

        if ($iter) $Lazy_find_all$28.$$p = null;
        
        
        if ($iter) $Lazy_find_all$28.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$29 = function(enum$, $a){var self = $$29.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$29.$$s = self, $$29.$$arity = -2, $$29));
      }, $Lazy_find_all$28.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$30 = function $$grep(pattern) {
        var $iter = $Lazy_grep$30.$$p, block = $iter || nil, $$31, $$32, self = this;

        if ($iter) $Lazy_grep$30.$$p = null;
        
        
        if ($iter) $Lazy_grep$30.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$31.$$s = self, $$31.$$arity = -2, $$31))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$32 = function(enum$, $a){var self = $$32.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$32.$$s = self, $$32.$$arity = -2, $$32))
        };
      }, $Lazy_grep$30.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$33 = function $$reject() {
        var $iter = $Lazy_reject$33.$$p, block = $iter || nil, $$34, self = this;

        if ($iter) $Lazy_reject$33.$$p = null;
        
        
        if ($iter) $Lazy_reject$33.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$34.$$s = self, $$34.$$arity = -2, $$34));
      }, $Lazy_reject$33.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$35 = function $$take(n) {
        var $$36, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$36 = function(enum$, $a){var self = $$36.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_take$35.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$37 = function $$take_while() {
        var $iter = $Lazy_take_while$37.$$p, block = $iter || nil, $$38, self = this;

        if ($iter) $Lazy_take_while$37.$$p = null;
        
        
        if ($iter) $Lazy_take_while$37.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$38 = function(enum$, $a){var self = $$38.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take_while$37.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$39 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$39.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_to_c$28, $Numeric_to_int$29, $Numeric_truncate$30, $Numeric_zero$ques$31, $Numeric_positive$ques$32, $Numeric_negative$ques$33, $Numeric_dup$34, $Numeric_clone$35, $Numeric_finite$ques$36, $Numeric_infinite$ques$37;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$28 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$28.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$29 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$29.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$30 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$30.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$31 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$31.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$32 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$32.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$33 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$33.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$34 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$34.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$35 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$35.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$36 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$36.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$37 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$37.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_dig$41, $Array_drop$42, $Array_dup$43, $Array_each$44, $Array_each_index$46, $Array_empty$ques$48, $Array_eql$ques$49, $Array_fetch$50, $Array_fill$51, $Array_first$52, $Array_flatten$53, $Array_flatten$excl$54, $Array_hash$55, $Array_include$ques$56, $Array_index$57, $Array_insert$58, $Array_inspect$59, $Array_join$60, $Array_keep_if$61, $Array_last$63, $Array_length$64, $Array_max$65, $Array_min$66, $Array_permutation$67, $Array_repeated_permutation$69, $Array_pop$71, $Array_product$72, $Array_push$73, $Array_rassoc$74, $Array_reject$75, $Array_reject$excl$77, $Array_replace$79, $Array_reverse$80, $Array_reverse$excl$81, $Array_reverse_each$82, $Array_rindex$84, $Array_rotate$85, $Array_rotate$excl$86, $Array_sample$89, $Array_select$90, $Array_select$excl$92, $Array_shift$94, $Array_shuffle$95, $Array_shuffle$excl$96, $Array_slice$excl$97, $Array_sort$98, $Array_sort$excl$99, $Array_sort_by$excl$100, $Array_take$102, $Array_take_while$103, $Array_to_a$104, $Array_to_h$105, $Array_transpose$106, $Array_uniq$109, $Array_uniq$excl$110, $Array_unshift$111, $Array_values_at$112, $Array_zip$115, $Array_inherited$116, $Array_instance_variables$117, $Array_pack$119;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $$($nesting, 'Opal').$coerce_to(size, $$($nesting, 'Integer'), "to_int")

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        Opal.hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Integer'), "to_int");
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return toArraySubclass(result, self.$class());
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($$($nesting, 'Opal')['$respond_to?'](other, "to_ary")) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return toArraySubclass(result, self.$class());
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return toArraySubclass(result, self.$class());
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int"),
            to      = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false), $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
      
      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    ;
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = Opal.yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, $a, self = this;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s || this;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, $a, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy(($truthy($a = object) ? $a : block))) {
        return $send(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false), $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s || this;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s || this;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s || this;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s || this;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value !== false && value !== nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$dig', $Array_dig$41 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$41.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$42 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$42.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$43 = function $$dup() {
      var $iter = $Array_dup$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$43, false), $zuper, $iter);
    }, $Array_dup$43.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, $$45, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$45 = function(){var self = $$45.$$s || this;

        return self.$size()}, $$45.$$s = self, $$45.$$arity = 0, $$45))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$46 = function $$each_index() {
      var $iter = $Array_each_index$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each_index$46.$$p = null;
      
      
      if ($iter) $Array_each_index$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$46.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$48 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$48.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$49 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$49.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$50 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$50.$$p = null;
      
      
      if ($iter) $Array_fetch$50.$$p = null;;
      ;
      
      var original = index;

      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$50.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$51 = function $$fill($a) {
      var $iter = $Array_fill$51.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$51.$$p = null;
      
      
      if ($iter) $Array_fill$51.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $$($nesting, 'Opal').$coerce_to(one.$begin(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $$($nesting, 'Opal').$coerce_to(one.$end(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $$($nesting, 'Opal').$coerce_to(one, $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $$($nesting, 'Opal').$coerce_to(two, $$($nesting, 'Integer'), "to_int");
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$51.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$52 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$52.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$53 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$$($nesting, 'Opal')['$respond_to?'](item, "to_ary", true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $$($nesting, 'Opal').$coerce_to(level, $$($nesting, 'Integer'), "to_int");
      }

      return toArraySubclass(_flatten(self, level), self.$class());
    ;
    }, $Array_flatten$53.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$54 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$54.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$55 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if (Opal.hash_ids[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Array_hash$55.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$56 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$57 = function $$index(object) {
      var $iter = $Array_index$57.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$57.$$p = null;
      
      
      if ($iter) $Array_index$57.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$57.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$58 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$58.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$59 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$59.$$arity = 0);
    
    Opal.def(self, '$join', $Array_join$60 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_str")) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_ary")) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_s")) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$60.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$61 = function $$keep_if() {
      var $iter = $Array_keep_if$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Array_keep_if$61.$$p = null;
      
      
      if ($iter) $Array_keep_if$61.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_keep_if$61.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$63 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$63.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$64 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$64.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$65 = function $$max(n) {
      var $iter = $Array_max$65.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$65.$$p = null;
      
      
      if ($iter) $Array_max$65.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$65.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$66 = function $$min() {
      var $iter = $Array_min$66.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$66.$$p = null;
      
      
      if ($iter) $Array_min$66.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$66.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$67 = function $$permutation(num) {
      var $iter = $Array_permutation$67.$$p, block = $iter || nil, $$68, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$67.$$p = null;
      
      
      if ($iter) $Array_permutation$67.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$68 = function(){var self = $$68.$$s || this;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $$($nesting, 'Opal').$coerce_to(num, $$($nesting, 'Integer'), "to_int")
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                Opal.yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$67.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$69 = function $$repeated_permutation(n) {
      var $$70, $iter = $Array_repeated_permutation$69.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$69.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$70 = function(){var self = $$70.$$s || this;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$69.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$71 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$71.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$72 = function $$product($a) {
      var $iter = $Array_product$72.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$72.$$p = null;
      
      
      if ($iter) $Array_product$72.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $$($nesting, 'Opal').$coerce_to(args[i - 1], $$($nesting, 'Array'), "to_ary");
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$72.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$73 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$73.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$74 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$74.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$75 = function $$reject() {
      var $iter = $Array_reject$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Array_reject$75.$$p = null;
      
      
      if ($iter) $Array_reject$75.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$76 = function(){var self = $$76.$$s || this;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$75.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$77 = function() {
      var $iter = $Array_reject$excl$77.$$p, block = $iter || nil, $$78, self = this, original = nil;

      if ($iter) $Array_reject$excl$77.$$p = null;
      
      
      if ($iter) $Array_reject$excl$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$77.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$79 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$79.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$80 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$80.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$81 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$81.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$82 = function $$reverse_each() {
      var $iter = $Array_reverse_each$82.$$p, block = $iter || nil, $$83, self = this;

      if ($iter) $Array_reverse_each$82.$$p = null;
      
      
      if ($iter) $Array_reverse_each$82.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$83 = function(){var self = $$83.$$s || this;

        return self.$size()}, $$83.$$s = self, $$83.$$arity = 0, $$83))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$82.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$84 = function $$rindex(object) {
      var $iter = $Array_rindex$84.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$84.$$p = null;
      
      
      if ($iter) $Array_rindex$84.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$84.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$85 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      
      var ary, idx, firstPart, lastPart;

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$85.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$86 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
    ;
      cnt = $$($nesting, 'Opal').$coerce_to(cnt, $$($nesting, 'Integer'), "to_int");
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$86.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$87, $SampleRandom_rand$88;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$87 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$87.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$88 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $$($nesting, 'Opal').$coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), "to_int");
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$88.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$89 = function $$sample(count, options) {
      var $a, self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        }
      } else {
        
        count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        options = $$($nesting, 'Opal').$coerce_to(options, $$($nesting, 'Hash'), "to_hash");
      };
      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy(($truthy($a = rng) ? rng['$respond_to?']("rand") : $a))) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$89.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$90 = function $$select() {
      var $iter = $Array_select$90.$$p, block = $iter || nil, $$91, self = this;

      if ($iter) $Array_select$90.$$p = null;
      
      
      if ($iter) $Array_select$90.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$91 = function(){var self = $$91.$$s || this;

        return self.$size()}, $$91.$$s = self, $$91.$$arity = 0, $$91))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = Opal.yield1(block, item);

        if (Opal.truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$90.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$92 = function() {
      var $iter = $Array_select$excl$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Array_select$excl$92.$$p = null;
      
      
      if ($iter) $Array_select$excl$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$92.$$arity = 0);
    
    Opal.def(self, '$shift', $Array_shift$94 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.shift();};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$94.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$95 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$95.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$96 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$96.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$97 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $$($nesting, 'Opal').$coerce_to(range.$begin(), $$($nesting, 'Integer'), "to_int");
          range_end = $$($nesting, 'Opal').$coerce_to(range.$end(), $$($nesting, 'Integer'), "to_int");
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$97.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$98 = function $$sort() {
      var $iter = $Array_sort$98.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$98.$$p = null;
      
      
      if ($iter) $Array_sort$98.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$98.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$99 = function() {
      var $iter = $Array_sort$excl$99.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$99.$$p = null;
      
      
      if ($iter) $Array_sort$excl$99.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$99.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$100 = function() {
      var $iter = $Array_sort_by$excl$100.$$p, block = $iter || nil, $$101, self = this;

      if ($iter) $Array_sort_by$excl$100.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$100.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$101 = function(){var self = $$101.$$s || this;

        return self.$size()}, $$101.$$s = self, $$101.$$arity = 0, $$101))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$100.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$102 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$102.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$103 = function $$take_while() {
      var $iter = $Array_take_while$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$103.$$p = null;
      
      
      if ($iter) $Array_take_while$103.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$103.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$104 = function $$to_a() {
      var self = this;

      return self
    }, $Array_to_a$104.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    
    Opal.def(self, '$to_h', $Array_to_h$105 = function $$to_h() {
      var self = this;

      
      var i, len = self.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](self[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        Opal.hash_put(hash, key, val);
      }

      return hash;
    
    }, $Array_to_h$105.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$106 = function $$transpose() {
      var $$107, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$107 = function(row){var self = $$107.$$s || this, $a, $$108;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(row, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        max = ($truthy($a = max) ? $a : row.length);
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$108 = function(i){var self = $$108.$$s || this, $b, entry = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          return entry['$<<'](row.$at(i));}, $$108.$$s = self, $$108.$$arity = 1, $$108));}, $$107.$$s = self, $$107.$$arity = 1, $$107));
      return result;
    }, $Array_transpose$106.$$arity = 0);
    
    Opal.def(self, '$uniq', $Array_uniq$109 = function $$uniq() {
      var $iter = $Array_uniq$109.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$109.$$p = null;
      
      
      if ($iter) $Array_uniq$109.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if (Opal.hash_get(hash, item) === undefined) {
            Opal.hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = Opal.yield1(block, item);
          if (Opal.hash_get(hash, key) === undefined) {
            Opal.hash_put(hash, key, item);
          }
        }
      }

      return toArraySubclass((hash).$values(), self.$class());
    ;
    }, $Array_uniq$109.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$110 = function() {
      var $iter = $Array_uniq$excl$110.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$110.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$110.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : Opal.yield1(block, item));

        if (Opal.hash_get(hash, key) === undefined) {
          Opal.hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$110.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$111 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = objects.length - 1; i >= 0; i--) {
        self.unshift(objects[i]);
      }
    ;
      return self;
    }, $Array_unshift$111.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$112 = function $$values_at($a) {
      var $post_args, args, $$113, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$113 = function(elem){var self = $$113.$$s || this, $$114, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $$($nesting, 'Opal').$coerce_to(elem.$last(), $$($nesting, 'Integer'), "to_int");
          start = $$($nesting, 'Opal').$coerce_to(elem.$first(), $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$114 = function(i){var self = $$114.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$114.$$s = self, $$114.$$arity = 1, $$114));
        } else {
          
          i = $$($nesting, 'Opal').$coerce_to(elem, $$($nesting, 'Integer'), "to_int");
          return out['$<<'](self.$at(i));
        };}, $$113.$$s = self, $$113.$$arity = 1, $$113));
      return out;
    }, $Array_values_at$112.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$115 = function $$zip($a) {
      var $iter = $Array_zip$115.$$p, block = $iter || nil, $post_args, others, $b, self = this;

      if ($iter) $Array_zip$115.$$p = null;
      
      
      if ($iter) $Array_zip$115.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_enumerator) {
          if (o.$size() === Infinity) {
            others[j] = o.$take(size);
          } else {
            others[j] = o.$to_a();
          }
          continue;
        }
        others[j] = ($truthy($b = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")) ? $b : $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "each")).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$115.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$116 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$116.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$117 = function $$instance_variables() {
      var $$118, $iter = $Array_instance_variables$117.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$117.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$117, false), $zuper, $iter), 'reject', [], ($$118 = function(ivar){var self = $$118.$$s || this, $a;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        return ($truthy($a = /^@\d+$/.test(ivar)) ? $a : ivar['$==']("@length"));}, $$118.$$s = self, $$118.$$arity = 1, $$118))
    }, $Array_instance_variables$117.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$119 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$119.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_fetch$35, $Hash_fetch_values$36, $Hash_flatten$38, $Hash_has_key$ques$39, $Hash_has_value$ques$40, $Hash_hash$41, $Hash_index$42, $Hash_indexes$43, $Hash_inspect$44, $Hash_invert$45, $Hash_keep_if$46, $Hash_keys$48, $Hash_length$49, $Hash_merge$50, $Hash_merge$excl$51, $Hash_rassoc$52, $Hash_rehash$53, $Hash_reject$54, $Hash_reject$excl$56, $Hash_replace$58, $Hash_select$59, $Hash_select$excl$61, $Hash_shift$63, $Hash_slice$64, $Hash_to_a$65, $Hash_to_h$66, $Hash_to_hash$67, $Hash_to_proc$68, $Hash_transform_keys$70, $Hash_transform_keys$excl$72, $Hash_transform_values$74, $Hash_transform_values$excl$76, $Hash_values$78;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s || this, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s || this;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s || this;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s || this;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$fetch', $Hash_fetch$35 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$35.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$35.$$p = null;
      
      
      if ($iter) $Hash_fetch$35.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$35.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$36 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$36.$$p, block = $iter || nil, $post_args, keys, $$37, self = this;

      if ($iter) $Hash_fetch_values$36.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$37 = function(key){var self = $$37.$$s || this;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$37.$$s = self, $$37.$$arity = 1, $$37));
    }, $Hash_fetch_values$36.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$38 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$38.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$39 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$39.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$40 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$40.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$41 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$41.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$42 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$42.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$43 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$43.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$44 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$44.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$45 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$45.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$46 = function $$keep_if() {
      var $iter = $Hash_keep_if$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Hash_keep_if$46.$$p = null;
      
      
      if ($iter) $Hash_keep_if$46.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$46.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$48 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$48.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$49 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$49.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$50 = function $$merge(other) {
      var $iter = $Hash_merge$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$50.$$p = null;
      
      
      if ($iter) $Hash_merge$50.$$p = null;;
      return $send(self.$dup(), 'merge!', [other], block.$to_proc());
    }, $Hash_merge$50.$$arity = 1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$51 = function(other) {
      var $iter = $Hash_merge$excl$51.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$excl$51.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$51.$$p = null;;
      
      if (!other.$$is_hash) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      }

      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;

      if (block === nil) {
        for (i = 0; i < length; i++) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }

        return self;
      }

      for (i = 0; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        value = Opal.hash_get(self, key);

        if (value === undefined) {
          Opal.hash_put(self, key, other_value);
          continue;
        }

        Opal.hash_put(self, key, block(key, value, other_value));
      }

      return self;
    ;
    }, $Hash_merge$excl$51.$$arity = 1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$52 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$52.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$53 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$53.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$54 = function $$reject() {
      var $iter = $Hash_reject$54.$$p, block = $iter || nil, $$55, self = this;

      if ($iter) $Hash_reject$54.$$p = null;
      
      
      if ($iter) $Hash_reject$54.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$55 = function(){var self = $$55.$$s || this;

        return self.$size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$54.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$56 = function() {
      var $iter = $Hash_reject$excl$56.$$p, block = $iter || nil, $$57, self = this;

      if ($iter) $Hash_reject$excl$56.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$56.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$57 = function(){var self = $$57.$$s || this;

        return self.$size()}, $$57.$$s = self, $$57.$$arity = 0, $$57))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$56.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$58 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$58.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$59 = function $$select() {
      var $iter = $Hash_select$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_select$59.$$p = null;
      
      
      if ($iter) $Hash_select$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$60 = function(){var self = $$60.$$s || this;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$59.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$61 = function() {
      var $iter = $Hash_select$excl$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Hash_select$excl$61.$$p = null;
      
      
      if ($iter) $Hash_select$excl$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$61.$$arity = 0);
    
    Opal.def(self, '$shift', $Hash_shift$63 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$63.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$64 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$64.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$65 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$65.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$66 = function $$to_h() {
      var self = this;

      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_to_h$66.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$67 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$67.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$68 = function $$to_proc() {
      var $$69, self = this;

      return $send(self, 'proc', [], ($$69 = function(key){var self = $$69.$$s || this;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$69.$$s = self, $$69.$$arity = -1, $$69))
    }, $Hash_to_proc$68.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$70 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$70.$$p, block = $iter || nil, $$71, self = this;

      if ($iter) $Hash_transform_keys$70.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$70.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$71 = function(){var self = $$71.$$s || this;

        return self.$size()}, $$71.$$s = self, $$71.$$arity = 0, $$71))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$70.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$72 = function() {
      var $iter = $Hash_transform_keys$excl$72.$$p, block = $iter || nil, $$73, self = this;

      if ($iter) $Hash_transform_keys$excl$72.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$72.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$73 = function(){var self = $$73.$$s || this;

        return self.$size()}, $$73.$$s = self, $$73.$$arity = 0, $$73))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$72.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$74 = function $$transform_values() {
      var $iter = $Hash_transform_values$74.$$p, block = $iter || nil, $$75, self = this;

      if ($iter) $Hash_transform_values$74.$$p = null;
      
      
      if ($iter) $Hash_transform_values$74.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$75 = function(){var self = $$75.$$s || this;

        return self.$size()}, $$75.$$s = self, $$75.$$arity = 0, $$75))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$74.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$76 = function() {
      var $iter = $Hash_transform_values$excl$76.$$p, block = $iter || nil, $$77, self = this;

      if ($iter) $Hash_transform_values$excl$76.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$76.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$77 = function(){var self = $$77.$$s || this;

        return self.$size()}, $$77.$$s = self, $$77.$$arity = 0, $$77))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$76.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$78 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$78.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$any?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_step$58, $Number_times$60, $Number_to_f$62, $Number_to_i$63, $Number_to_r$64, $Number_to_s$65, $Number_truncate$66, $Number_digits$67, $Number_divmod$68, $Number_upto$69, $Number_zero$ques$71, $Number_size$72, $Number_nan$ques$73, $Number_finite$ques$74, $Number_infinite$ques$75, $Number_positive$ques$76, $Number_negative$ques$77;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var $a, $b, self = this;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = $$($nesting, 'Float')['$==='](other)) ? $b : $$($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return String.fromCharCode(self);;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $a, $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return 1
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false), $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(), self.$lcm()]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $a, $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false), $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $a, $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false), $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $a, $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return self
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false), $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false), $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(x) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    
    Opal.def(self, '$step', $Number_step$58 = function $$step($a, $b, $c) {
      var $iter = $Number_step$58.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $$59, self = this, positional_args = nil, keyword_args = nil;

      if ($iter) $Number_step$58.$$p = null;
      
      
      if ($iter) $Number_step$58.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      function validateParameters() {
        if (to !== undefined) {
          limit = to;
        }

        if (limit === undefined) {
          limit = nil;
        }

        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (by !== undefined) {
          step = by;
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }
    ;
      if ((block !== nil)) {
      } else {
        
        positional_args = [];
        keyword_args = $hash2([], {});
        
        if (limit !== undefined) {
          positional_args.push(limit);
        }

        if (step !== undefined) {
          positional_args.push(step);
        }

        if (to !== undefined) {
          Opal.hash_put(keyword_args, "to", to);
        }

        if (by !== undefined) {
          Opal.hash_put(keyword_args, "by", by);
        }

        if (keyword_args['$any?']()) {
          positional_args.push(keyword_args);
        }
      ;
        return $send(self, 'enum_for', ["step"].concat(Opal.to_a(positional_args)), ($$59 = function(){var self = $$59.$$s || this;

        return stepSize();}, $$59.$$s = self, $$59.$$arity = 0, $$59));
      };
      
      validateParameters();

      if (step === 0) {
        while (true) {
          block(self);
        }
      }

      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {
        var n = stepFloatSize();

        if (n > 0) {
          if (step === Infinity || step === -Infinity) {
            block(self);
          } else {
            var i = 0, d;

            if (step > 0) {
              while (i < n) {
                d = i * step + self;
                if (limit < d) {
                  d = limit;
                }
                block(d);
                i += 1;
              }
            } else {
              while (i < n) {
                d = i * step + self;
                if (limit > d) {
                  d = limit;
                }
                block(d);
                i += 1
              }
            }
          }
        }
      } else {
        var value = self;

        if (step > 0) {
          while (value <= limit) {
            block(value);
            value += step;
          }
        } else {
          while (value >= limit) {
            block(value);
            value += step
          }
        }
      }

      return self;
    ;
    }, $Number_step$58.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$60 = function $$times() {
      var $iter = $Number_times$60.$$p, block = $iter || nil, $$61, self = this;

      if ($iter) $Number_times$60.$$p = null;
      
      
      if ($iter) $Number_times$60.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$61 = function(){var self = $$61.$$s || this;

        return self}, $$61.$$s = self, $$61.$$arity = 0, $$61))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$60.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$62 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$62.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$63 = function $$to_i() {
      var self = this;

      return parseInt(self, 10);
    }, $Number_to_i$63.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$64 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$64.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$65 = function $$to_s(base) {
      var $a, self = this;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$65.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$66 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$66.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$67 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$67.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$68 = function $$divmod(other) {
      var $a, $iter = $Number_divmod$68.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$68.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$68, false), $zuper, $iter)
      }
    }, $Number_divmod$68.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$69 = function $$upto(stop) {
      var $iter = $Number_upto$69.$$p, block = $iter || nil, $$70, self = this;

      if ($iter) $Number_upto$69.$$p = null;
      
      
      if ($iter) $Number_upto$69.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$70 = function(){var self = $$70.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$69.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$71 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$71.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$72 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$72.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$73 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$73.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$74 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$74.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$75 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$75.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$76 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$76.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$77 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$77.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79, $sqrt$80;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      
      Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        
        if (!other.$$is_number) {
          return false;
        }

        return (other % 1) === 0;
      
      }, $eq_eq_eq$79.$$arity = 1);
      return (Opal.def(self, '$sqrt', $sqrt$80 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$80.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$81, $eq_eq_eq$82;

      
      
      Opal.def(self, '$allocate', $allocate$81 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$81.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$82 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$82.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq$2, $Range_$eq_eq_eq$3, $Range_cover$ques$4, $Range_each$5, $Range_eql$ques$6, $Range_exclude_end$ques$7, $Range_first$8, $Range_last$9, $Range_max$10, $Range_min$11, $Range_size$12, $Range_step$13, $Range_bsearch$17, $Range_to_s$18, $Range_inspect$19, $Range_marshal_load$20, $Range_hash$21;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy(first['$<=>'](last))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$==', $Range_$eq_eq$2 = function(other) {
      var self = this;

      
      if (!other.$$is_range) {
        return false;
      }

      return self.excl  === other.excl &&
             self.begin ==  other.begin &&
             self.end   ==  other.end;
    
    }, $Range_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$3 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$cover?', $Range_cover$ques$4 = function(value) {
      var $a, self = this, beg_cmp = nil, end_cmp = nil;

      
      beg_cmp = self.begin['$<=>'](value);
      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {
      } else {
        return false
      };
      end_cmp = value['$<=>'](self.end);
      if ($truthy(self.excl)) {
        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)
      } else {
        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)
      };
    }, $Range_cover$ques$4.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$5 = function $$each() {
      var $iter = $Range_each$5.$$p, block = $iter || nil, $a, self = this, current = nil, last = nil;

      if ($iter) $Range_each$5.$$p = null;
      
      
      if ($iter) $Range_each$5.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy($rb_lt(current['$<=>'](last), 0))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$5.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$6 = function(other) {
      var $a, $b, self = this;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);
    }, $Range_eql$ques$6.$$arity = 1);
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$7 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$7.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$8 = function $$first(n) {
      var $iter = $Range_first$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(n == null)) {
        return self.begin};
      return $send(self, Opal.find_super_dispatcher(self, 'first', $Range_first$8, false), $zuper, $iter);
    }, $Range_first$8.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$9 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$9.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$10 = function $$max() {
      var $a, $iter = $Range_max$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'max', $Range_max$10, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$10.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$11 = function $$min() {
      var $a, $iter = $Range_min$11.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$11.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'min', $Range_min$11, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$11.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$12 = function $$size() {
      var $a, self = this, range_begin = nil, range_end = nil, infinity = nil;

      
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](range_begin)) ? $$($nesting, 'Numeric')['$==='](range_end) : $a))) {
      } else {
        return nil
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy([range_begin.$abs(), range_end.$abs()]['$include?'](infinity))) {
        return infinity};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$12.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$13 = function $$step(n) {
      var $$14, $$15, $$16, $iter = $Range_step$13.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$13.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$14 = function(){var self = $$14.$$s || this;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$14.$$s = self, $$14.$$arity = 0, $$14))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$15 = function(){var self = $$15.$$s || this, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$15.$$s = self, $$15.$$brk = $brk, $$15.$$arity = 0, $$15))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$16 = function(value, idx){var self = $$16.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$16.$$s = self, $$16.$$arity = 2, $$16));
      };
      return self;
    }, $Range_step$13.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$17 = function $$bsearch() {
      var $iter = $Range_bsearch$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$17.$$p = null;
      
      
      if ($iter) $Range_bsearch$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$17.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$18 = function $$to_s() {
      var self = this;

      return "" + (self.begin) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end)
    }, $Range_to_s$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$19 = function $$inspect() {
      var self = this;

      return "" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end.$inspect())
    }, $Range_inspect$19.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$20 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$20.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$21 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$21.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_to_proc$3, $Proc_lambda$ques$4, $Proc_arity$5, $Proc_source_location$6, $Proc_binding$7, $Proc_parameters$8, $Proc_curry$9, $Proc_dup$10;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$to_proc', $Proc_to_proc$3 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$3.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$4 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$4.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$5 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$5.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$6 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$6.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$7 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$7.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$8 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$8.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$9 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$9.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$10 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$10.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_unbind$7, $Method_to_proc$8, $Method_inspect$9;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$unbind', $Method_unbind$7 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$7.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$8 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$8.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$9.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$10, $UnboundMethod_arity$11, $UnboundMethod_parameters$12, $UnboundMethod_source_location$13, $UnboundMethod_comments$14, $UnboundMethod_bind$15, $UnboundMethod_inspect$16;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$10 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$10.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$11 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$12 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$12.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$13 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $UnboundMethod_source_location$13.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$14 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $UnboundMethod_comments$14.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$15 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$15.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$16 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$16.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "^"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "$"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$coerce_to', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, $b, self = this, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((($b = args.$length()['$=='](1)) ? args['$[]'](0)['$respond_to?']("to_ary") : args.$length()['$=='](1)))) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($$($nesting, 'Opal').$coerce_to(arg, $$($nesting, 'Integer'), "to_int"));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    Opal.alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $$12, $$15, $$18, $$21, $$24, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$bytesize', '$enum_for', '$each_codepoint', '$force_encoding', '$dup', '$coerce_to!', '$find', '$getbyte']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_to_s$7, $Encoding_inspect$8, $Encoding_each_byte$9, $Encoding_getbyte$10, $Encoding_bytesize$11;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defineProperty(self, '$$register', {});
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $a, $$2, self = this, names = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], ($truthy($a = options['$[]']("aliases")) ? $a : []));
      encoding = $send($$($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]']("ascii")) ? $a : false), ($truthy($a = options['$[]']("dummy")) ? $a : false));
      register = self["$$register"];
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s || this;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$sub("-", "_"), encoding);
        return register["" + "$$" + (encoding_name)] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var $a, self = this, register = nil, encoding = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = self["$$register"];
      encoding = ($truthy($a = register["" + "$$" + (name)]) ? $a : register["" + "$$" + (name.$upcase())]);
      if ($truthy(encoding)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, $Encoding_find$3.$$arity = 1);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("default_external")
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$7 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$8.$$arity = 0);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$9 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$9.$$arity = -1);
    
    Opal.def(self, '$getbyte', $Encoding_getbyte$10 = function $$getbyte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_getbyte$10.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$11 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$11.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$12 = function(){var self = $$12.$$s || this, $each_byte$13, $bytesize$14;

  
    
    Opal.def(self, '$each_byte', $each_byte$13 = function $$each_byte(string) {
      var $iter = $each_byte$13.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$13.$$p = null;
      
      
      if ($iter) $each_byte$13.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        if (code <= 0x7f) {
          Opal.yield1(block, code);
        }
        else {
          var encoded = encodeURIComponent(string.charAt(i)).substr(1).split('%');

          for (var j = 0, encoded_length = encoded.length; j < encoded_length; j++) {
            Opal.yield1(block, parseInt(encoded[j], 16));
          }
        }
      }
    ;
    }, $each_byte$13.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$14 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$14.$$arity = 1), nil) && 'bytesize';}, $$12.$$s = self, $$12.$$arity = 0, $$12));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$15 = function(){var self = $$15.$$s || this, $each_byte$16, $bytesize$17;

  
    
    Opal.def(self, '$each_byte', $each_byte$16 = function $$each_byte(string) {
      var $iter = $each_byte$16.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$16.$$p = null;
      
      
      if ($iter) $each_byte$16.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$16.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$17 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$17.$$arity = 1), nil) && 'bytesize';}, $$15.$$s = self, $$15.$$arity = 0, $$15));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE"], ($$18 = function(){var self = $$18.$$s || this, $each_byte$19, $bytesize$20;

  
    
    Opal.def(self, '$each_byte', $each_byte$19 = function $$each_byte(string) {
      var $iter = $each_byte$19.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$19.$$p = null;
      
      
      if ($iter) $each_byte$19.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$19.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$20 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$20.$$arity = 1), nil) && 'bytesize';}, $$18.$$s = self, $$18.$$arity = 0, $$18));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$21 = function(){var self = $$21.$$s || this, $each_byte$22, $bytesize$23;

  
    
    Opal.def(self, '$each_byte', $each_byte$22 = function $$each_byte(string) {
      var $iter = $each_byte$22.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$22.$$p = null;
      
      
      if ($iter) $each_byte$22.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$22.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$23 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$23.$$arity = 1), nil) && 'bytesize';}, $$21.$$s = self, $$21.$$arity = 0, $$21));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], ($$24 = function(){var self = $$24.$$s || this, $each_byte$25, $bytesize$26;

  
    
    Opal.def(self, '$each_byte', $each_byte$25 = function $$each_byte(string) {
      var $iter = $each_byte$25.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$25.$$p = null;
      
      
      if ($iter) $each_byte$25.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$25.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$26 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$26.$$arity = 1), nil) && 'bytesize';}, $$24.$$s = self, $$24.$$arity = 0, $$24));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_bytes$27, $String_bytesize$28, $String_each_byte$29, $String_each_codepoint$30, $String_codepoints$31, $String_encode$32, $String_force_encoding$33, $String_getbyte$34, $String_valid_encoding$ques$35;

    self.$$prototype.encoding = nil;
    
    self.$attr_reader("encoding");
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_16LE'));
    
    Opal.def(self, '$bytes', $String_bytes$27 = function $$bytes() {
      var self = this;

      return self.$each_byte().$to_a()
    }, $String_bytes$27.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$28 = function $$bytesize() {
      var self = this;

      return self.encoding.$bytesize(self)
    }, $String_bytesize$28.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$29 = function $$each_byte() {
      var $iter = $String_each_byte$29.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_byte$29.$$p = null;
      
      
      if ($iter) $String_each_byte$29.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      $send(self.encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$29.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$30 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$30.$$p = null;
      
      
      if ($iter) $String_each_codepoint$30.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$30.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$31 = function $$codepoints() {
      var $iter = $String_codepoints$31.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$31.$$p = null;
      
      
      if ($iter) $String_codepoints$31.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$31.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$32 = function $$encode(encoding) {
      var self = this;

      return self.$dup().$force_encoding(encoding)
    }, $String_encode$32.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$33 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      self.encoding = encoding;
      return self;
    
    }, $String_force_encoding$33.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$34 = function $$getbyte(idx) {
      var self = this;

      return self.encoding.$getbyte(self, idx)
    }, $String_getbyte$34.$$arity = 1);
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$35 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$35.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$type_error', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($$($nesting, 'Opal').$type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    
    Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var $a, $b, $c, self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](real)) ? real['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](imag) : $b)) ? imag['$real?']() : $a))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var $a, $b, $c, self = this;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](r)) ? r['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](theta) : $b)) ? theta['$real?']() : $a))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return (($a = self.real['$=='](other.$real())) ? self.imag['$=='](other.$imag()) : self.real['$=='](other.$real()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return (($a = self.real['$=='](other)) ? self.imag['$=='](0) : self.real['$=='](other))
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var $a, $b, $c, $d, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = $$($nesting, 'Number')['$==='](self.real)) ? self.real['$nan?']() : $d)) ? $c : ($truthy($d = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $d))) ? $b : ($truthy($c = $$($nesting, 'Number')['$==='](other.$real())) ? other.$real()['$nan?']() : $c))) ? $a : ($truthy($b = $$($nesting, 'Number')['$==='](other.$imag())) ? other.$imag()['$nan?']() : $b)))) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](other)) ? $a : $$($nesting, 'Rational')['$==='](other)))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = $$($nesting, 'Complex')['$==='](other)) ? self.real.$class()['$=='](self.imag.$class()) : $b)) ? self['$=='](other) : $a)
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var $a, self = this;

      return ($truthy($a = self.real['$finite?']()) ? self.imag['$finite?']() : $a)
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var $a, self = this;

      return ($truthy($a = self.real['$infinite?']()) ? $a : self.imag['$infinite?']())
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var $a, $b, $c, self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $c)) ? $b : self.imag['$positive?']())) ? $a : self.imag['$zero?']()))) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy(($truthy($a = $$($nesting, 'Number')['$==='](self.imag)) ? ($truthy($b = self.imag['$nan?']()) ? $b : self.imag['$infinite?']()) : $a))) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    
    Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var $a, $b, self = this;

      
      if ($truthy(($truthy($a = num['$nil?']()) ? $a : den['$nil?']()))) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](num)) ? $$($nesting, 'Integer')['$==='](den) : $a))) {
        return self.$reduce(num, den)};
      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](num)) ? $b : $$($nesting, 'String')['$==='](num))) ? $a : $$($nesting, 'Complex')['$==='](num)))) {
        num = num.$to_r()};
      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](den)) ? $b : $$($nesting, 'String')['$==='](den))) ? $a : $$($nesting, 'Complex')['$==='](den)))) {
        den = den.$to_r()};
      if ($truthy(($truthy($a = den['$equal?'](1)) ? $$($nesting, 'Integer')['$==='](num)['$!']() : $a))) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](num)) ? $$($nesting, 'Numeric')['$==='](den) : $a))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return (($a = self.num['$=='](other.$numerator())) ? self.den['$=='](other.$denominator()) : self.num['$=='](other.$numerator()))}
      else if ($$($nesting, 'Integer')['$===']($case)) {return (($a = self.num['$=='](other)) ? self.den['$=='](1) : self.num['$=='](other))}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    
    Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var $a, self = this;

      return ($truthy($a = $$($nesting, 'Time')['$==='](other)) ? self.$to_f() === other.$to_f() : $a)
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var $a, self = this;

      return ($truthy($a = other['$is_a?']($$($nesting, 'Time'))) ? self['$<=>'](other)['$zero?']() : $a)
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var $a, self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy(($truthy($a = $rb_le(jan01_wday, 4)) ? jan01_wday['$!='](0) : $a))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy(($truthy($a = $rb_le(dec31_wday, 3)) ? dec31_wday['$!='](0) : $a))) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_members$15, $Struct_hash$16, $Struct_$$$17, $Struct_$$$eq$18, $Struct_$eq_eq$19, $Struct_eql$ques$20, $Struct_each$21, $Struct_each_pair$24, $Struct_length$27, $Struct_to_a$28, $Struct_inspect$30, $Struct_to_h$32, $Struct_values_at$34, $Struct_dig$36;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s || this, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s || this;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s || this;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var $a, self = this;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = ($truthy($a = self.members) ? $a : []));
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s || this;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $b, $$13, $$14, self = this, kwargs = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy($b = args.$last()) ? $b : $hash2([], {}));
        if ($truthy(($truthy($b = $rb_gt(args.$length(), 1)) ? $b : (args.length === 1 && !kwargs.$$is_hash)))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$members', $Struct_members$15 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$15.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$16 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$16.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$17 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$17.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$18 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$18.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$19 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$19.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$20.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$21 = function $$each() {
      var $$22, $$23, $iter = $Struct_each$21.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$21.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$22 = function(){var self = $$22.$$s || this;

        return self.$size()}, $$22.$$s = self, $$22.$$arity = 0, $$22))
      };
      $send(self.$class().$members(), 'each', [], ($$23 = function(name){var self = $$23.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$23.$$s = self, $$23.$$arity = 1, $$23));
      return self;
    }, $Struct_each$21.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$24 = function $$each_pair() {
      var $$25, $$26, $iter = $Struct_each_pair$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$24.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      $send(self.$class().$members(), 'each', [], ($$26 = function(name){var self = $$26.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$26.$$s = self, $$26.$$arity = 1, $$26));
      return self;
    }, $Struct_each_pair$24.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$27 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$27.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$28 = function $$to_a() {
      var $$29, self = this;

      return $send(self.$class().$members(), 'map', [], ($$29 = function(name){var self = $$29.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$29.$$s = self, $$29.$$arity = 1, $$29))
    }, $Struct_to_a$28.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$30 = function $$inspect() {
      var $a, $$31, self = this, result = nil;

      
      result = "#<struct ";
      if ($truthy(($truthy($a = $$($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$31 = function(name, value){var self = $$31.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$31.$$s = self, $$31.$$arity = 2, $$31)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$30.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$32 = function $$to_h() {
      var $$33, self = this;

      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$33 = function(name, h){var self = $$33.$$s || this, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$33.$$s = self, $$33.$$arity = 2, $$33))
    }, $Struct_to_h$32.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$34 = function $$values_at($a) {
      var $post_args, args, $$35, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$35 = function(arg){var self = $$35.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$35.$$s = self, $$35.$$arity = 1, $$35)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$34.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$36 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$36.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$8;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, $$7, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        self.$write($send(args, 'map', [], ($$7 = function(arg){var self = $$7.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$String(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7)).$join($gvars[","]));
        return nil;
      }, $Writable_print$6.$$arity = -1);
      
      Opal.def(self, '$puts', $Writable_puts$8 = function $$puts($a) {
        var $post_args, args, $$9, self = this, newline = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        newline = $gvars["/"];
        if ($truthy(args['$empty?']())) {
          self.$write($gvars["/"])
        } else {
          self.$write($send(args, 'map', [], ($$9 = function(arg){var self = $$9.$$s || this;

          
            
            if (arg == null) {
              arg = nil;
            };
            return self.$String(arg).$chomp();}, $$9.$$s = self, $$9.$$arity = 1, $$9)).$concat([nil]).$join(newline))
        };
        return nil;
      }, $Writable_puts$8.$$arity = -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$10, $Readable_readchar$11, $Readable_readline$12, $Readable_readpartial$13;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$10 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$10.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$11 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$11.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$12 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$12.$$arity = -1);
      
      Opal.def(self, '$readpartial', $Readable_readpartial$13 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$13.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var $a, self = this;

        return ($truthy($a = $$($nesting, 'ENV')['$[]']("HOME")) ? $a : ".")
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var $a, self = this, sep = nil, sep_chars = nil, new_parts = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = ($truthy($a = basedir) ? $a : $$($nesting, 'Dir').$pwd());
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(new RegExp("" + "[" + (sep_chars) + "]"));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(new RegExp("" + "[" + (sep_chars) + "]")), path.$split(new RegExp("" + "[" + (sep_chars) + "]")));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = new RegExp("" + "^\\~(?:" + (sep) + "|$)");
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var $a, self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(new RegExp("" + "(^." + ($$($nesting, 'SEPARATOR')) + "+|" + ($$($nesting, 'SEPARATOR')) + "+$)"));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s || this;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](new RegExp("" + "^" + (path)));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s || this, $b;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((($b = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((($b = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s || this, $b, next_item = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? next_item['$start_with?']($$($nesting, 'SEPARATOR')) : $b))) {
              item = item.$sub(new RegExp("" + ($$($nesting, 'SEPARATOR')) + "+$"), "")};
            return (result = (function() {if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? $b : next_item['$start_with?']($$($nesting, 'SEPARATOR'))))) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var $a, self = this, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id))));
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/random"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$<', '$raise', '$encode', '$join', '$new', '$chr', '$===', '$==', '$state', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random_initialize$1, $Random_reseed$2, $Random_new_seed$3, $Random_rand$4, $Random_srand$5, $Random_urandom$6, $Random_$eq_eq$8, $Random_bytes$9, $Random_rand$11, $Random_generator$eq$12;

    
    self.$attr_reader("seed", "state");
    
    Opal.def(self, '$initialize', $Random_initialize$1 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$1.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$2 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$2.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$3 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$3.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$4 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$4.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$5 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$5.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$6 = function $$urandom(size) {
      var $$7, self = this;

      
      size = $$($nesting, 'Opal')['$coerce_to!'](size, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(size, 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)")};
      return $send($$($nesting, 'Array'), 'new', [size], ($$7 = function(){var self = $$7.$$s || this;

      return self.$rand(255).$chr()}, $$7.$$s = self, $$7.$$arity = 0, $$7)).$join().$encode("ASCII-8BIT");
    }, $Random_urandom$6.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var $a, self = this;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      return (($a = self.$seed()['$=='](other.$seed())) ? self.$state()['$=='](other.$state()) : self.$seed()['$=='](other.$seed()));
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Opal')['$coerce_to!'](length, $$($nesting, 'Integer'), "to_int");
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s || this;

      return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$11 = function $$rand(limit) {
      var self = this;

      
      ;
      
      function randomFloat() {
        self.state++;
        return Opal.$$rand.rand(self.$rng);
      }

      function randomInt() {
        return Math.floor(randomFloat() * limit);
      }

      function randomRange() {
        var min = limit.begin,
            max = limit.end;

        if (min === nil || max === nil) {
          return nil;
        }

        var length = max - min;

        if (length < 0) {
          return nil;
        }

        if (length === 0) {
          return min;
        }

        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
          length++;
        }

        return self.$rand(length) + min;
      }

      if (limit == null) {
        return randomFloat();
      } else if (limit.$$is_range) {
        return randomRange();
      } else if (limit.$$is_number) {
        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        if (limit % 1 === 0) {
          // integer
          return randomInt();
        } else {
          return randomFloat() * limit;
        }
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        return randomInt();
      }
    ;
    }, $Random_rand$11.$$arity = -1);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$12 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$12.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/*
This is based on an adaptation of Makoto Matsumoto and Takuji Nishimura's code
done by Sean McCullough <banksean@gmail.com> and Dave Heitzman
<daveheitzman@yahoo.com>, subsequently readapted from an updated version of
ruby's random.c (rev c38a183032a7826df1adabd8aa0725c713d53e1c).

The original copyright notice from random.c follows.

  This is based on trimmed version of MT19937.  To get the original version,
  contact <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>.

  The original copyright notice follows.

     A C-program for MT19937, with initialization improved 2002/2/10.
     Coded by Takuji Nishimura and Makoto Matsumoto.
     This is a faster version by taking Shawn Cokus's optimization,
     Matthe Bellew's simplification, Isaku Wada's real version.

     Before using, initialize the state by using init_genrand(mt, seed)
     or init_by_array(mt, init_key, key_length).

     Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

       1. Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.

       2. Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.

       3. The names of its contributors may not be used to endorse or promote
          products derived from this software without specific prior written
          permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


     Any feedback is very welcome.
     http://www.math.keio.ac.jp/matumoto/emt.html
     email: matumoto@math.keio.ac.jp
*/
var MersenneTwister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
Opal.loaded(["corelib/random/MersenneTwister.js"]);
/* Generated by Opal 1.0.3 */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$generator=', '$-']);
  
  self.$require("corelib/random/MersenneTwister");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return MersenneTwister.init(seed); },
    rand: function(mt) { return MersenneTwister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    
    Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    
    Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    
    Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1)
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister.js");
  return self.$require("corelib/unsupported");
};

/* Generated by Opal 1.0.3 */
Opal.modules["yaml"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$warn']);
  return self.$warn("REMOVED: use `require 'nodejs/yaml'` instead")
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/configuration/properties"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $lambda = Opal.lambda, $hash2 = Opal.hash2;

  Opal.add_stubs(['$attr_reader', '$attr_accessor', '$reset', '$reset_readers', '$reset_serializers', '$new', '$private', '$attr_writer', '$==']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Configuration');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Properties');

          var $nesting = [self].concat($parent_nesting), $Properties_initialize$1, $Properties_reset$2, $Properties_reset_readers$4, $Properties_reset_serializers$5;

          
          self.$attr_reader("readers");
          self.$attr_reader("serializers");
          self.$attr_accessor("compressor");
          self.$attr_accessor("root_builder");
          self.$attr_accessor("tmp_path");
          
          Opal.def(self, '$initialize', $Properties_initialize$1 = function $$initialize() {
            var self = this;

            return self.$reset()
          }, $Properties_initialize$1.$$arity = 0);
          
          Opal.def(self, '$reset', $Properties_reset$2 = function $$reset() {
            var $$3, self = this;

            
            self.$reset_readers();
            self.$reset_serializers();
            self.compressor = $$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Compressor').$new();
            self.root_builder = $lambda(($$3 = function(){var self = $$3.$$s || this;

            return $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Raw').$new()}, $$3.$$s = self, $$3.$$arity = 0, $$3));
            return (self.tmp_path = "/tmp");
          }, $Properties_reset$2.$$arity = 0);
          self.$private();
          self.$attr_writer("readers", "serializers");
          
          Opal.def(self, '$reset_readers', $Properties_reset_readers$4 = function $$reset_readers() {
            var self = this, plain_text_reader = nil;

            
            plain_text_reader = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Readers'), 'PlainText').$new();
            return (self.readers = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Configuration'), 'ProviderCollection').$new("reader", $hash2(["txt"], {"txt": plain_text_reader})));
          }, $Properties_reset_readers$4.$$arity = 0);
          return (Opal.def(self, '$reset_serializers', $Properties_reset_serializers$5 = function $$reset_serializers() {
            var self = this, marshal_serializer = nil, yaml_serializer = nil;

            
            marshal_serializer = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Serializers'), 'Marshal').$new();
            yaml_serializer = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Serializers'), 'Yaml').$new();
            if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
            } else {
              nil
            };
            if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
              return (self.serializers = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Configuration'), 'ProviderCollection').$new("serializer", $hash2(["marshal", "yml", "yaml"], {"marshal": marshal_serializer, "yml": yaml_serializer, "yaml": yaml_serializer})))
            } else {
              return nil
            };
          }, $Properties_reset_serializers$5.$$arity = 0), nil) && 'reset_serializers';
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/configuration/provider_collection"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$first', '$values', '$reset', '$[]=', '$providers', '$-', '$contains?', '$raise', '$name', '$[]', '$file_format', '$default', '$clear', '$each', '$configured_providers', '$configured_default', '$default=', '$keys', '$private', '$extname', '$slice!', '$to_sym', '$nil?', '$any?', '$include?', '$provider_instances', '$alias_method']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Configuration');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'ProviderCollection');

          var $nesting = [self].concat($parent_nesting), $ProviderCollection_initialize$1, $ProviderCollection_add$2, $ProviderCollection_default$eq$3, $ProviderCollection_providers$4, $ProviderCollection_resolve$5, $ProviderCollection_reset$6, $ProviderCollection_formats$8, $ProviderCollection_$$$9, $ProviderCollection_$$$eq$10, $ProviderCollection_values$11, $ProviderCollection_file_format$12, $ProviderCollection_contains$ques$13;

          self.$$prototype.providers = nil;
          
          self.$attr_reader("name");
          self.$attr_reader("default");
          
          Opal.def(self, '$initialize', $ProviderCollection_initialize$1 = function $$initialize(name, providers, default$) {
            var $a, self = this;

            
            
            if (providers == null) {
              providers = $hash2([], {});
            };
            
            if (default$ == null) {
              default$ = nil;
            };
            self.name = name;
            self.configured_providers = providers;
            self.configured_default = ($truthy($a = default$) ? $a : providers.$values().$first());
            return self.$reset();
          }, $ProviderCollection_initialize$1.$$arity = -2);
          
          Opal.def(self, '$add', $ProviderCollection_add$2 = function $$add(extension, provider) {
            var self = this, $writer = nil;

            
            $writer = [extension, provider];
            $send(self.$providers(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $ProviderCollection_add$2.$$arity = 2);
          
          Opal.def(self, '$default=', $ProviderCollection_default$eq$3 = function(provider) {
            var self = this;

            
            if ($truthy(self['$contains?'](provider))) {
            } else {
              self.$raise($$($nesting, 'ArgumentError'), "" + "default " + (self.$name()) + " should be part of configured " + (self.$name()) + "s")
            };
            return (self["default"] = provider);
          }, $ProviderCollection_default$eq$3.$$arity = 1);
          
          Opal.def(self, '$providers', $ProviderCollection_providers$4 = function $$providers() {
            var $a, self = this;

            return (self.providers = ($truthy($a = self.providers) ? $a : $hash2([], {})))
          }, $ProviderCollection_providers$4.$$arity = 0);
          
          Opal.def(self, '$resolve', $ProviderCollection_resolve$5 = function $$resolve(filepath) {
            var $a, self = this;

            return ($truthy($a = self.$providers()['$[]'](self.$file_format(filepath))) ? $a : self.$default())
          }, $ProviderCollection_resolve$5.$$arity = 1);
          
          Opal.def(self, '$reset', $ProviderCollection_reset$6 = function $$reset() {
            var $$7, self = this, $writer = nil;

            
            self.$providers().$clear();
            $send(self.$configured_providers(), 'each', [], ($$7 = function(k, v){var self = $$7.$$s || this, $writer = nil;

            
              
              if (k == null) {
                k = nil;
              };
              
              if (v == null) {
                v = nil;
              };
              $writer = [k, v];
              $send(self, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$7.$$s = self, $$7.$$arity = 2, $$7));
            
            $writer = [self.$configured_default()];
            $send(self, 'default=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          }, $ProviderCollection_reset$6.$$arity = 0);
          
          Opal.def(self, '$formats', $ProviderCollection_formats$8 = function $$formats() {
            var self = this;

            return self.$providers().$keys()
          }, $ProviderCollection_formats$8.$$arity = 0);
          
          Opal.def(self, '$[]', $ProviderCollection_$$$9 = function(format) {
            var self = this;

            return self.$providers()['$[]'](format)
          }, $ProviderCollection_$$$9.$$arity = 1);
          self.$private();
          self.$attr_reader("configured_providers", "configured_default");
          
          Opal.def(self, '$[]=', $ProviderCollection_$$$eq$10 = function(format, instance) {
            var self = this, $writer = nil;

            
            $writer = [format, instance];
            $send(self.$providers(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $ProviderCollection_$$$eq$10.$$arity = 2);
          
          Opal.def(self, '$values', $ProviderCollection_values$11 = function $$values() {
            var self = this;

            return self.$providers().$values()
          }, $ProviderCollection_values$11.$$arity = 0);
          
          Opal.def(self, '$file_format', $ProviderCollection_file_format$12 = function $$file_format(filepath) {
            var self = this, format = nil;

            
            format = $$($nesting, 'File').$extname(filepath);
            format['$slice!'](0);
            return format.$to_sym();
          }, $ProviderCollection_file_format$12.$$arity = 1);
          
          Opal.def(self, '$contains?', $ProviderCollection_contains$ques$13 = function(provider) {
            var $a, $b, self = this;

            return ($truthy($a = provider['$nil?']()) ? $a : ($truthy($b = self.$providers()['$any?']()) ? self.$provider_instances()['$include?'](provider) : $b))
          }, $ProviderCollection_contains$ques$13.$$arity = 1);
          return self.$alias_method("provider_instances", "values");
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/configuration"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$require']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    
    self.$require("rambling/trie/configuration/properties");
    self.$require("rambling/trie/configuration/provider_collection");
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Configuration');

        var $nesting = [self].concat($parent_nesting);

        nil
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/comparable"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$letter', '$terminal?', '$children_tree']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Comparable');

        var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1;

        
        Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
          var $a, $b, self = this;

          return ($truthy($a = (($b = self.$letter()['$=='](other.$letter())) ? self['$terminal?']()['$=='](other['$terminal?']()) : self.$letter()['$=='](other.$letter()))) ? self.$children_tree()['$=='](other.$children_tree()) : $a)
        }, $Comparable_$eq_eq$1.$$arity = 1)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/compressible"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$!', '$root?', '$terminal?', '$==', '$size', '$children_tree']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Compressible');

        var $nesting = [self].concat($parent_nesting), $Compressible_compressible$ques$1;

        
        Opal.def(self, '$compressible?', $Compressible_compressible$ques$1 = function() {
          var $a, $b, self = this;

          return ($truthy($a = ($truthy($b = self['$root?']()) ? $b : self['$terminal?']())['$!']()) ? self.$children_tree().$size()['$=='](1) : $a)
        }, $Compressible_compressible$ques$1.$$arity = 0)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/compressor"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$compressible?', '$compress_child_and_merge', '$compress_children_and_copy', '$private', '$merge', '$compress', '$first_child', '$<<', '$to_s', '$letter', '$new_compressed_node', '$to_sym', '$parent', '$children_tree', '$terminal?', '$compress_children', '$each', '$[]=', '$-', '$new', '$terminal!', '$each_value', '$parent=']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Compressor');

        var $nesting = [self].concat($parent_nesting), $Compressor_compress$1, $Compressor_compress_child_and_merge$2, $Compressor_merge$3, $Compressor_compress_children_and_copy$4, $Compressor_compress_children$5, $Compressor_new_compressed_node$7;

        
        
        Opal.def(self, '$compress', $Compressor_compress$1 = function $$compress(node) {
          var self = this;

          if ($truthy(node['$compressible?']())) {
            return self.$compress_child_and_merge(node)
          } else {
            return self.$compress_children_and_copy(node)
          }
        }, $Compressor_compress$1.$$arity = 1);
        self.$private();
        
        Opal.def(self, '$compress_child_and_merge', $Compressor_compress_child_and_merge$2 = function $$compress_child_and_merge(node) {
          var self = this;

          return self.$merge(node, self.$compress(node.$first_child()))
        }, $Compressor_compress_child_and_merge$2.$$arity = 1);
        
        Opal.def(self, '$merge', $Compressor_merge$3 = function $$merge(node, other) {
          var self = this, letter = nil;

          
          letter = node.$letter().$to_s()['$<<'](other.$letter().$to_s());
          return self.$new_compressed_node(letter.$to_sym(), node.$parent(), other.$children_tree(), other['$terminal?']());
        }, $Compressor_merge$3.$$arity = 2);
        
        Opal.def(self, '$compress_children_and_copy', $Compressor_compress_children_and_copy$4 = function $$compress_children_and_copy(node) {
          var self = this;

          return self.$new_compressed_node(node.$letter(), node.$parent(), self.$compress_children(node.$children_tree()), node['$terminal?']())
        }, $Compressor_compress_children_and_copy$4.$$arity = 1);
        
        Opal.def(self, '$compress_children', $Compressor_compress_children$5 = function $$compress_children(tree) {
          var $$6, self = this, new_tree = nil;

          
          new_tree = $hash2([], {});
          $send(tree, 'each', [], ($$6 = function(letter, child){var self = $$6.$$s || this, compressed_child = nil, $writer = nil;

          
            
            if (letter == null) {
              letter = nil;
            };
            
            if (child == null) {
              child = nil;
            };
            compressed_child = self.$compress(child);
            
            $writer = [letter, compressed_child];
            $send(new_tree, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, $$6.$$s = self, $$6.$$arity = 2, $$6));
          return new_tree;
        }, $Compressor_compress_children$5.$$arity = 1);
        return (Opal.def(self, '$new_compressed_node', $Compressor_new_compressed_node$7 = function $$new_compressed_node(letter, parent, tree, terminal) {
          var $$8, self = this, node = nil;

          
          node = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Compressed').$new(letter, parent, tree);
          if ($truthy(terminal)) {
            node['$terminal!']()};
          $send(tree, 'each_value', [], ($$8 = function(child){var self = $$8.$$s || this, $writer = nil;

          
            
            if (child == null) {
              child = nil;
            };
            $writer = [node];
            $send(child, 'parent=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$8.$$s = self, $$8.$$arity = 1, $$8));
          return node;
        }, $Compressor_new_compressed_node$7.$$arity = 4), nil) && 'new_compressed_node';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/container"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$attr_reader', '$add', '$root', '$char_symbols', '$map', '$compressed?', '$compress_root', '$root=', '$-', '$new', '$compressor', '$partial_word?', '$chars', '$word?', '$to_a', '$scan', '$words_within_root', '$any?', '$==', '$enum_for', '$each', '$name', '$class', '$inspect', '$[]', '$children', '$children_tree', '$key?', '$size', '$alias_method', '$private', '$attr_writer', '$upto', '$length', '$slice', '$match_prefix', '$compress', '$each_char', '$reverse', '$<<', '$to_sym']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Container');

        var $nesting = [self].concat($parent_nesting), $Container_initialize$1, $Container_add$2, $Container_concat$3, $Container_compress$excl$5, $Container_compress$6, $Container_partial_word$ques$7, $Container_word$ques$8, $Container_scan$9, $Container_words_within$10, $Container_words_within$ques$11, $Container_$eq_eq$12, $Container_each$13, $Container_inspect$15, $Container_$$$16, $Container_children$17, $Container_children_tree$18, $Container_compressed$ques$19, $Container_to_a$20, $Container_key$ques$21, $Container_size$22, $Container_words_within_root$23, $Container_compress_root$26, $Container_char_symbols$27;

        
        self.$include($$$('::', 'Enumerable'));
        self.$attr_reader("root");
        
        Opal.def(self, '$initialize', $Container_initialize$1 = function $$initialize(root, compressor) {
          var $iter = $Container_initialize$1.$$p, $yield = $iter || nil, self = this;

          if ($iter) $Container_initialize$1.$$p = null;
          
          self.root = root;
          self.compressor = compressor;
          if (($yield !== nil)) {
            return Opal.yield1($yield, self);
          } else {
            return nil
          };
        }, $Container_initialize$1.$$arity = 2);
        
        Opal.def(self, '$add', $Container_add$2 = function $$add(word) {
          var self = this;

          return self.$root().$add(self.$char_symbols(word))
        }, $Container_add$2.$$arity = 1);
        
        Opal.def(self, '$concat', $Container_concat$3 = function $$concat(words) {
          var $$4, self = this;

          return $send(words, 'map', [], ($$4 = function(word){var self = $$4.$$s || this;

          
            
            if (word == null) {
              word = nil;
            };
            return self.$add(word);}, $$4.$$s = self, $$4.$$arity = 1, $$4))
        }, $Container_concat$3.$$arity = 1);
        
        Opal.def(self, '$compress!', $Container_compress$excl$5 = function() {
          var self = this, $writer = nil;

          
          if ($truthy(self.$root()['$compressed?']())) {
          } else {
            
            $writer = [self.$compress_root()];
            $send(self, 'root=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          return self;
        }, $Container_compress$excl$5.$$arity = 0);
        
        Opal.def(self, '$compress', $Container_compress$6 = function $$compress() {
          var self = this;

          
          if ($truthy(self.$root()['$compressed?']())) {
            return self};
          return $$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Container').$new(self.$compress_root(), self.$compressor());
        }, $Container_compress$6.$$arity = 0);
        
        Opal.def(self, '$partial_word?', $Container_partial_word$ques$7 = function(word) {
          var self = this;

          
          
          if (word == null) {
            word = "";
          };
          return self.$root()['$partial_word?'](word.$chars());
        }, $Container_partial_word$ques$7.$$arity = -1);
        
        Opal.def(self, '$word?', $Container_word$ques$8 = function(word) {
          var self = this;

          
          
          if (word == null) {
            word = "";
          };
          return self.$root()['$word?'](word.$chars());
        }, $Container_word$ques$8.$$arity = -1);
        
        Opal.def(self, '$scan', $Container_scan$9 = function $$scan(word) {
          var self = this;

          
          
          if (word == null) {
            word = "";
          };
          return self.$root().$scan(word.$chars()).$to_a();
        }, $Container_scan$9.$$arity = -1);
        
        Opal.def(self, '$words_within', $Container_words_within$10 = function $$words_within(phrase) {
          var self = this;

          return self.$words_within_root(phrase).$to_a()
        }, $Container_words_within$10.$$arity = 1);
        
        Opal.def(self, '$words_within?', $Container_words_within$ques$11 = function(phrase) {
          var self = this;

          return self.$words_within_root(phrase)['$any?']()
        }, $Container_words_within$ques$11.$$arity = 1);
        
        Opal.def(self, '$==', $Container_$eq_eq$12 = function(other) {
          var self = this;

          return self.$root()['$=='](other.$root())
        }, $Container_$eq_eq$12.$$arity = 1);
        
        Opal.def(self, '$each', $Container_each$13 = function $$each() {
          var $$14, $iter = $Container_each$13.$$p, $yield = $iter || nil, self = this;

          if ($iter) $Container_each$13.$$p = null;
          
          if (($yield !== nil)) {
          } else {
            return self.$enum_for("each")
          };
          return $send(self.$root(), 'each', [], ($$14 = function(word){var self = $$14.$$s || this;

          
            
            if (word == null) {
              word = nil;
            };
            return Opal.yield1($yield, word);;}, $$14.$$s = self, $$14.$$arity = 1, $$14));
        }, $Container_each$13.$$arity = 0);
        
        Opal.def(self, '$inspect', $Container_inspect$15 = function $$inspect() {
          var self = this;

          return "" + "#<" + (self.$class().$name()) + " root: " + (self.$root().$inspect()) + ">"
        }, $Container_inspect$15.$$arity = 0);
        
        Opal.def(self, '$[]', $Container_$$$16 = function(letter) {
          var self = this;

          return self.$root()['$[]'](letter)
        }, $Container_$$$16.$$arity = 1);
        
        Opal.def(self, '$children', $Container_children$17 = function $$children() {
          var self = this;

          return self.$root().$children()
        }, $Container_children$17.$$arity = 0);
        
        Opal.def(self, '$children_tree', $Container_children_tree$18 = function $$children_tree() {
          var self = this;

          return self.$root().$children_tree()
        }, $Container_children_tree$18.$$arity = 0);
        
        Opal.def(self, '$compressed?', $Container_compressed$ques$19 = function() {
          var self = this;

          return self.$root()['$compressed?']()
        }, $Container_compressed$ques$19.$$arity = 0);
        
        Opal.def(self, '$to_a', $Container_to_a$20 = function $$to_a() {
          var self = this;

          return self.$root().$to_a()
        }, $Container_to_a$20.$$arity = 0);
        
        Opal.def(self, '$key?', $Container_key$ques$21 = function(letter) {
          var self = this;

          return self.$root()['$key?'](letter)
        }, $Container_key$ques$21.$$arity = 1);
        
        Opal.def(self, '$size', $Container_size$22 = function $$size() {
          var self = this;

          return self.$root().$size()
        }, $Container_size$22.$$arity = 0);
        self.$alias_method("include?", "word?");
        self.$alias_method("match?", "partial_word?");
        self.$alias_method("words", "scan");
        self.$alias_method("<<", "add");
        self.$alias_method("has_key?", "key?");
        self.$alias_method("has_letter?", "key?");
        self.$private();
        self.$attr_reader("compressor");
        self.$attr_writer("root");
        
        Opal.def(self, '$words_within_root', $Container_words_within_root$23 = function $$words_within_root(phrase) {
          var $$24, $iter = $Container_words_within_root$23.$$p, $yield = $iter || nil, self = this, chars = nil;

          if ($iter) $Container_words_within_root$23.$$p = null;
          
          if (($yield !== nil)) {
          } else {
            return self.$enum_for("words_within_root", phrase)
          };
          chars = phrase.$chars();
          return $send((0).$upto($rb_minus(chars.$length(), 1)), 'each', [], ($$24 = function(starting_index){var self = $$24.$$s || this, $$25, new_phrase = nil;

          
            
            if (starting_index == null) {
              starting_index = nil;
            };
            new_phrase = chars.$slice(Opal.Range.$new(starting_index, $rb_minus(chars.$length(), 1), false));
            return $send(self.$root(), 'match_prefix', [new_phrase], ($$25 = function(word){var self = $$25.$$s || this;

            
              
              if (word == null) {
                word = nil;
              };
              return Opal.yield1($yield, word);;}, $$25.$$s = self, $$25.$$arity = 1, $$25));}, $$24.$$s = self, $$24.$$arity = 1, $$24));
        }, $Container_words_within_root$23.$$arity = 1);
        
        Opal.def(self, '$compress_root', $Container_compress_root$26 = function $$compress_root() {
          var self = this;

          return self.$compressor().$compress(self.$root())
        }, $Container_compress_root$26.$$arity = 0);
        return (Opal.def(self, '$char_symbols', $Container_char_symbols$27 = function $$char_symbols(word) {
          var $$28, self = this, symbols = nil;

          
          symbols = [];
          $send(word.$reverse(), 'each_char', [], ($$28 = function(c){var self = $$28.$$s || this;

          
            
            if (c == null) {
              c = nil;
            };
            return symbols['$<<'](c.$to_sym());}, $$28.$$s = self, $$28.$$arity = 1, $$28));
          return symbols;
        }, $Container_char_symbols$27.$$arity = 1), nil) && 'char_symbols';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/enumerable"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$alias_method', '$enum_for', '$terminal?', '$as_word', '$each_value', '$children_tree', '$each']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Enumerable');

        var $nesting = [self].concat($parent_nesting), $Enumerable_each$1;

        
        self.$include($$$('::', 'Enumerable'));
        self.$alias_method("size", "count");
        
        Opal.def(self, '$each', $Enumerable_each$1 = function $$each() {
          var $$2, $iter = $Enumerable_each$1.$$p, $yield = $iter || nil, self = this;

          if ($iter) $Enumerable_each$1.$$p = null;
          
          if (($yield !== nil)) {
          } else {
            return self.$enum_for("each")
          };
          if ($truthy(self['$terminal?']())) {
            Opal.yield1($yield, self.$as_word())};
          return $send(self.$children_tree(), 'each_value', [], ($$2 = function(child){var self = $$2.$$s || this, $$3;

          
            
            if (child == null) {
              child = nil;
            };
            return $send(child, 'each', [], ($$3 = function(word){var self = $$3.$$s || this;

            
              
              if (word == null) {
                word = nil;
              };
              return Opal.yield1($yield, word);;}, $$3.$$s = self, $$3.$$arity = 1, $$3));}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        }, $Enumerable_each$1.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/inspectable"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$class_name', '$attributes', '$private', '$name', '$class', '$join', '$letter_inspect', '$terminal_inspect', '$children_inspect', '$inspect', '$letter', '$terminal', '$keys', '$children_tree']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Inspectable');

        var $nesting = [self].concat($parent_nesting), $Inspectable_inspect$1, $Inspectable_class_name$2, $Inspectable_attributes$3, $Inspectable_letter_inspect$4, $Inspectable_terminal_inspect$5, $Inspectable_children_inspect$6;

        
        
        Opal.def(self, '$inspect', $Inspectable_inspect$1 = function $$inspect() {
          var self = this;

          return "" + "#<" + (self.$class_name()) + " " + (self.$attributes()) + ">"
        }, $Inspectable_inspect$1.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$class_name', $Inspectable_class_name$2 = function $$class_name() {
          var self = this;

          return self.$class().$name()
        }, $Inspectable_class_name$2.$$arity = 0);
        
        Opal.def(self, '$attributes', $Inspectable_attributes$3 = function $$attributes() {
          var self = this;

          return [self.$letter_inspect(), self.$terminal_inspect(), self.$children_inspect()].$join(", ")
        }, $Inspectable_attributes$3.$$arity = 0);
        
        Opal.def(self, '$letter_inspect', $Inspectable_letter_inspect$4 = function $$letter_inspect() {
          var self = this;

          return "" + "letter: " + (self.$letter().$inspect())
        }, $Inspectable_letter_inspect$4.$$arity = 0);
        
        Opal.def(self, '$terminal_inspect', $Inspectable_terminal_inspect$5 = function $$terminal_inspect() {
          var self = this;

          return "" + "terminal: " + (self.$terminal().$inspect())
        }, $Inspectable_terminal_inspect$5.$$arity = 0);
        
        Opal.def(self, '$children_inspect', $Inspectable_children_inspect$6 = function $$children_inspect() {
          var self = this;

          return "" + "children: " + (self.$children_tree().$keys().$inspect())
        }, $Inspectable_children_inspect$6.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/invalid_operation"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'InvalidOperation');

        var $nesting = [self].concat($parent_nesting), $InvalidOperation_initialize$1;

        return (Opal.def(self, '$initialize', $InvalidOperation_initialize$1 = function $$initialize(message) {
          var $iter = $InvalidOperation_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $InvalidOperation_initialize$1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          if (message == null) {
            message = nil;
          };
          return $send(self, Opal.find_super_dispatcher(self, 'initialize', $InvalidOperation_initialize$1, false), $zuper, $iter);
        }, $InvalidOperation_initialize$1.$$arity = -1), nil) && 'initialize'
      })($nesting[0], $$($nesting, 'RuntimeError'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/readers/plain_text"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$foreach', '$chomp!']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Readers');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'PlainText');

          var $nesting = [self].concat($parent_nesting), $PlainText_each_word$1;

          return (Opal.def(self, '$each_word', $PlainText_each_word$1 = function $$each_word(filepath) {
            var $$2, $iter = $PlainText_each_word$1.$$p, $yield = $iter || nil, self = this;

            if ($iter) $PlainText_each_word$1.$$p = null;
            return $send($$($nesting, 'File'), 'foreach', [filepath], ($$2 = function(line){var self = $$2.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return Opal.yield1($yield, line['$chomp!']());;}, $$2.$$s = self, $$2.$$arity = 1, $$2))
          }, $PlainText_each_word$1.$$arity = 1), nil) && 'each_word'
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/readers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$require']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    self.$require("rambling/trie/readers/plain_text")
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Readers');

        var $nesting = [self].concat($parent_nesting);

        nil
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/serializers/file"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$read', '$open', '$write']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Serializers');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'File');

          var $nesting = [self].concat($parent_nesting), $File_load$1, $File_dump$2;

          
          
          Opal.def(self, '$load', $File_load$1 = function $$load(filepath) {
            var self = this;

            return $$$('::', 'File').$read(filepath)
          }, $File_load$1.$$arity = 1);
          return (Opal.def(self, '$dump', $File_dump$2 = function $$dump(contents, filepath) {
            var $$3, self = this;

            return $send($$$('::', 'File'), 'open', [filepath, "w+"], ($$3 = function(f){var self = $$3.$$s || this;

            
              
              if (f == null) {
                f = nil;
              };
              return f.$write(contents);}, $$3.$$s = self, $$3.$$arity = 1, $$3))
          }, $File_dump$2.$$arity = 2), nil) && 'dump';
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/serializers/marshal"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$load', '$serializer', '$dump', '$private', '$attr_reader']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Serializers');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Marshal');

          var $nesting = [self].concat($parent_nesting), $Marshal_initialize$1, $Marshal_load$2, $Marshal_dump$3;

          
          
          Opal.def(self, '$initialize', $Marshal_initialize$1 = function $$initialize(serializer) {
            var $a, self = this;

            
            
            if (serializer == null) {
              serializer = nil;
            };
            return (self.serializer = ($truthy($a = serializer) ? $a : $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Serializers'), 'File').$new()));
          }, $Marshal_initialize$1.$$arity = -1);
          
          Opal.def(self, '$load', $Marshal_load$2 = function $$load(filepath) {
            var self = this;

            return $$$('::', 'Marshal').$load(self.$serializer().$load(filepath))
          }, $Marshal_load$2.$$arity = 1);
          
          Opal.def(self, '$dump', $Marshal_dump$3 = function $$dump(node, filepath) {
            var self = this;

            return self.$serializer().$dump($$$('::', 'Marshal').$dump(node), filepath)
          }, $Marshal_dump$3.$$arity = 2);
          self.$private();
          return self.$attr_reader("serializer");
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/serializers/yaml"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$require', '$safe_load', '$load', '$serializer', '$dump', '$private', '$attr_reader']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Serializers');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Yaml');

          var $nesting = [self].concat($parent_nesting), $Yaml_initialize$1, $Yaml_load$2, $Yaml_dump$3;

          
          
          Opal.def(self, '$initialize', $Yaml_initialize$1 = function $$initialize(serializer) {
            var $a, self = this;

            
            
            if (serializer == null) {
              serializer = nil;
            };
            return (self.serializer = ($truthy($a = serializer) ? $a : $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Serializers'), 'File').$new()));
          }, $Yaml_initialize$1.$$arity = -1);
          
          Opal.def(self, '$load', $Yaml_load$2 = function $$load(filepath) {
            var self = this;

            
            self.$require("yaml");
            return $$$('::', 'YAML').$safe_load(self.$serializer().$load(filepath), [$$($nesting, 'Symbol'), $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Raw'), $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Compressed')], [], true);
          }, $Yaml_load$2.$$arity = 1);
          
          Opal.def(self, '$dump', $Yaml_dump$3 = function $$dump(node, filepath) {
            var self = this;

            
            self.$require("yaml");
            return self.$serializer().$dump($$$('::', 'YAML').$dump(node), filepath);
          }, $Yaml_dump$3.$$arity = 2);
          self.$private();
          return self.$attr_reader("serializer");
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/serializers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$require']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    
    self.$require("rambling/trie/serializers/file");
    self.$require("rambling/trie/serializers/marshal");
    self.$require("rambling/trie/serializers/yaml");
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Serializers');

        var $nesting = [self].concat($parent_nesting);

        nil
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/stringifyable"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$letter', '$!', '$terminal?', '$raise', '$to_s', '$+', '$parent']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Stringifyable');

        var $nesting = [self].concat($parent_nesting), $Stringifyable_as_word$1, $Stringifyable_to_s$2;

        
        
        Opal.def(self, '$as_word', $Stringifyable_as_word$1 = function $$as_word() {
          var $a, self = this;

          
          if ($truthy(($truthy($a = self.$letter()) ? self['$terminal?']()['$!']() : $a))) {
            self.$raise($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'InvalidOperation'), "Cannot represent branch as a word")};
          return self.$to_s();
        }, $Stringifyable_as_word$1.$$arity = 0);
        
        Opal.def(self, '$to_s', $Stringifyable_to_s$2 = function $$to_s() {
          var self = this;

          return $rb_plus(self.$parent().$to_s(), self.$letter().$to_s())
        }, $Stringifyable_to_s$2.$$arity = 0);
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/nodes/node"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$attr_reader', '$attr_accessor', '$values', '$children_tree', '$empty?', '$each_value', '$!', '$parent', '$terminal', '$terminal=', '$-', '$to_sym', '$partial_word_chars?', '$terminal?', '$word_chars?', '$closest_node', '$enum_for', '$as_word', '$children_match_prefix', '$[]', '$[]=', '$key?', '$delete', '$alias_method', '$protected', '$new', '$private']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Nodes');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Node');

          var $nesting = [self].concat($parent_nesting), $Node_initialize$1, $Node_children$2, $Node_first_child$3, $Node_root$ques$5, $Node_terminal$ques$6, $Node_terminal$excl$7, $Node_letter$eq$8, $Node_partial_word$ques$9, $Node_word$ques$10, $Node_scan$11, $Node_match_prefix$12, $Node_$$$14, $Node_$$$eq$15, $Node_key$ques$16, $Node_delete$17, $Node_missing$18;

          
          self.$include($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Compressible'));
          self.$include($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Enumerable'));
          self.$include($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Comparable'));
          self.$include($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Stringifyable'));
          self.$include($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Inspectable'));
          self.$attr_reader("letter");
          self.$attr_accessor("children_tree");
          self.$attr_accessor("parent");
          
          Opal.def(self, '$initialize', $Node_initialize$1 = function $$initialize(letter, parent, children_tree) {
            var self = this;

            
            
            if (letter == null) {
              letter = nil;
            };
            
            if (parent == null) {
              parent = nil;
            };
            
            if (children_tree == null) {
              children_tree = $hash2([], {});
            };
            self.letter = letter;
            self.parent = parent;
            return (self.children_tree = children_tree);
          }, $Node_initialize$1.$$arity = -1);
          
          Opal.def(self, '$children', $Node_children$2 = function $$children() {
            var self = this;

            return self.$children_tree().$values()
          }, $Node_children$2.$$arity = 0);
          
          Opal.def(self, '$first_child', $Node_first_child$3 = function $$first_child() {try {

            var $$4, self = this;

            
            if ($truthy(self.$children_tree()['$empty?']())) {
              return nil};
            return $send(self.$children_tree(), 'each_value', [], ($$4 = function(child){var self = $$4.$$s || this;

            
              
              if (child == null) {
                child = nil;
              };
              Opal.ret(child);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
            } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
          }, $Node_first_child$3.$$arity = 0);
          
          Opal.def(self, '$root?', $Node_root$ques$5 = function() {
            var self = this;

            return self.$parent()['$!']()
          }, $Node_root$ques$5.$$arity = 0);
          
          Opal.def(self, '$terminal?', $Node_terminal$ques$6 = function() {
            var self = this;

            return self.$terminal()['$!']()['$!']()
          }, $Node_terminal$ques$6.$$arity = 0);
          
          Opal.def(self, '$terminal!', $Node_terminal$excl$7 = function() {
            var self = this, $writer = nil;

            
            
            $writer = [true];
            $send(self, 'terminal=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return self;
          }, $Node_terminal$excl$7.$$arity = 0);
          
          Opal.def(self, '$letter=', $Node_letter$eq$8 = function(letter) {
            var self = this;

            if ($truthy(letter)) {
              return (self.letter = letter.$to_sym())
            } else {
              return nil
            }
          }, $Node_letter$eq$8.$$arity = 1);
          
          Opal.def(self, '$partial_word?', $Node_partial_word$ques$9 = function(chars) {
            var self = this;

            
            if ($truthy(chars['$empty?']())) {
              return true};
            return self['$partial_word_chars?'](chars);
          }, $Node_partial_word$ques$9.$$arity = 1);
          
          Opal.def(self, '$word?', $Node_word$ques$10 = function(chars) {
            var self = this;

            
            
            if (chars == null) {
              chars = [];
            };
            if ($truthy(chars['$empty?']())) {
              return self['$terminal?']()};
            return self['$word_chars?'](chars);
          }, $Node_word$ques$10.$$arity = -1);
          
          Opal.def(self, '$scan', $Node_scan$11 = function $$scan(chars) {
            var self = this;

            
            if ($truthy(chars['$empty?']())) {
              return self};
            return self.$closest_node(chars);
          }, $Node_scan$11.$$arity = 1);
          
          Opal.def(self, '$match_prefix', $Node_match_prefix$12 = function $$match_prefix(chars) {
            var $$13, $iter = $Node_match_prefix$12.$$p, $yield = $iter || nil, self = this;

            if ($iter) $Node_match_prefix$12.$$p = null;
            
            if (($yield !== nil)) {
            } else {
              return self.$enum_for("match_prefix", chars)
            };
            if ($truthy(self['$terminal?']())) {
              Opal.yield1($yield, self.$as_word())};
            return $send(self, 'children_match_prefix', [chars], ($$13 = function(word){var self = $$13.$$s || this;

            
              
              if (word == null) {
                word = nil;
              };
              return Opal.yield1($yield, word);;}, $$13.$$s = self, $$13.$$arity = 1, $$13));
          }, $Node_match_prefix$12.$$arity = 1);
          
          Opal.def(self, '$[]', $Node_$$$14 = function(letter) {
            var self = this;

            return self.$children_tree()['$[]'](letter)
          }, $Node_$$$14.$$arity = 1);
          
          Opal.def(self, '$[]=', $Node_$$$eq$15 = function(letter, node) {
            var self = this, $writer = nil;

            
            $writer = [letter, node];
            $send(self.$children_tree(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $Node_$$$eq$15.$$arity = 2);
          
          Opal.def(self, '$key?', $Node_key$ques$16 = function(letter) {
            var self = this;

            return self.$children_tree()['$key?'](letter)
          }, $Node_key$ques$16.$$arity = 1);
          
          Opal.def(self, '$delete', $Node_delete$17 = function(letter) {
            var self = this;

            return self.$children_tree().$delete(letter)
          }, $Node_delete$17.$$arity = 1);
          self.$alias_method("has_key?", "key?");
          self.$protected();
          
          Opal.def(self, '$missing', $Node_missing$18 = function $$missing() {
            var self = this;

            return $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Missing').$new()
          }, $Node_missing$18.$$arity = 0);
          self.$private();
          return self.$attr_accessor("terminal");
        })($nesting[0], null, $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/nodes/compressed"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$raise', '$private', '$[]', '$children_tree', '$to_sym', '$first', '$to_s', '$letter', '$>=', '$size', '$join', '$slice!', '$==', '$partial_word?', '$slice', '$loop', '$word?', '$empty?', '$<<', '$missing', '$scan', '$enum_for', '$match_prefix']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Nodes');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Compressed');

          var $nesting = [self].concat($parent_nesting), $Compressed_add$1, $Compressed_compressed$ques$2, $Compressed_partial_word_chars$ques$3, $Compressed_word_chars$ques$4, $Compressed_closest_node$6, $Compressed_children_match_prefix$7;

          
          
          Opal.def(self, '$add', $Compressed_add$1 = function $$add(_) {
            var self = this;

            return self.$raise($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'InvalidOperation'), "Cannot add word to compressed trie")
          }, $Compressed_add$1.$$arity = 1);
          
          Opal.def(self, '$compressed?', $Compressed_compressed$ques$2 = function() {
            var self = this;

            return true
          }, $Compressed_compressed$ques$2.$$arity = 0);
          self.$private();
          
          Opal.def(self, '$partial_word_chars?', $Compressed_partial_word_chars$ques$3 = function(chars) {
            var self = this, child = nil, child_letter = nil, letter = nil;

            
            child = self.$children_tree()['$[]'](chars.$first().$to_sym());
            if ($truthy(child)) {
            } else {
              return false
            };
            child_letter = child.$letter().$to_s();
            if ($truthy($rb_ge(chars.$size(), child_letter.$size()))) {
              
              letter = chars['$slice!'](0, child_letter.$size()).$join();
              if (child_letter['$=='](letter)) {
                return child['$partial_word?'](chars)};};
            letter = chars.$join();
            child_letter = child_letter.$slice(0, letter.$size());
            return child_letter['$=='](letter);
          }, $Compressed_partial_word_chars$ques$3.$$arity = 1);
          
          Opal.def(self, '$word_chars?', $Compressed_word_chars$ques$4 = function(chars) {try {

            var $$5, self = this, letter = nil, letter_sym = nil, child = nil;

            
            letter = chars['$slice!'](0);
            letter_sym = letter.$to_sym();
            child = self.$children_tree()['$[]'](letter_sym);
            if ($truthy(child)) {
            } else {
              return false
            };
            (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$5 = function(){var self = $$5.$$s || this;

            
              if (letter_sym['$=='](child.$letter())) {
                Opal.ret(child['$word?'](chars))};
              if ($truthy(chars['$empty?']())) {
                
                Opal.brk(nil, $brk)};
              letter['$<<'](chars['$slice!'](0));
              return (letter_sym = letter.$to_sym());}, $$5.$$s = self, $$5.$$brk = $brk, $$5.$$arity = 0, $$5))
            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
            return false;
            } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
          }, $Compressed_word_chars$ques$4.$$arity = 1);
          
          Opal.def(self, '$closest_node', $Compressed_closest_node$6 = function $$closest_node(chars) {
            var self = this, child = nil, child_letter = nil, letter = nil;

            
            child = self.$children_tree()['$[]'](chars.$first().$to_sym());
            if ($truthy(child)) {
            } else {
              return self.$missing()
            };
            child_letter = child.$letter().$to_s();
            if ($truthy($rb_ge(chars.$size(), child_letter.$size()))) {
              
              letter = chars['$slice!'](0, child_letter.$size()).$join();
              if (child_letter['$=='](letter)) {
                return child.$scan(chars)};};
            letter = chars.$join();
            child_letter = child_letter.$slice(0, letter.$size());
            if (child_letter['$=='](letter)) {
              return child
            } else {
              return self.$missing()
            };
          }, $Compressed_closest_node$6.$$arity = 1);
          return (Opal.def(self, '$children_match_prefix', $Compressed_children_match_prefix$7 = function $$children_match_prefix(chars) {
            var $$8, $iter = $Compressed_children_match_prefix$7.$$p, $yield = $iter || nil, self = this, child = nil, child_letter = nil, letter = nil;

            if ($iter) $Compressed_children_match_prefix$7.$$p = null;
            
            if (($yield !== nil)) {
            } else {
              return self.$enum_for("children_match_prefix", chars)
            };
            if ($truthy(chars['$empty?']())) {
              return nil};
            child = self.$children_tree()['$[]'](chars.$first().$to_sym());
            if ($truthy(child)) {
            } else {
              return nil
            };
            child_letter = child.$letter().$to_s();
            letter = chars['$slice!'](0, child_letter.$size()).$join();
            if (child_letter['$=='](letter)) {
            } else {
              return nil
            };
            return $send(child, 'match_prefix', [chars], ($$8 = function(word){var self = $$8.$$s || this;

            
              
              if (word == null) {
                word = nil;
              };
              return Opal.yield1($yield, word);;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
          }, $Compressed_children_match_prefix$7.$$arity = 1), nil) && 'children_match_prefix';
        })($nesting[0], $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Node'), $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/nodes/missing"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Nodes');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Missing');

          var $nesting = [self].concat($parent_nesting);

          return nil
        })($nesting[0], $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Node'), $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/nodes/raw"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$empty?', '$terminal!', '$add_to_children_tree', '$private', '$pop', '$[]', '$children_tree', '$new_node', '$add', '$new', '$[]=', '$-', '$to_sym', '$shift', '$partial_word?', '$word?', '$missing', '$scan', '$enum_for', '$match_prefix']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Nodes');

        var $nesting = [self].concat($parent_nesting);

        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Raw');

          var $nesting = [self].concat($parent_nesting), $Raw_add$1, $Raw_compressed$ques$2, $Raw_add_to_children_tree$3, $Raw_new_node$4, $Raw_partial_word_chars$ques$5, $Raw_word_chars$ques$6, $Raw_closest_node$7, $Raw_children_match_prefix$8;

          
          
          Opal.def(self, '$add', $Raw_add$1 = function $$add(chars) {
            var self = this;

            if ($truthy(chars['$empty?']())) {
              return self['$terminal!']()
            } else {
              return self.$add_to_children_tree(chars)
            }
          }, $Raw_add$1.$$arity = 1);
          
          Opal.def(self, '$compressed?', $Raw_compressed$ques$2 = function() {
            var self = this;

            return false
          }, $Raw_compressed$ques$2.$$arity = 0);
          self.$private();
          
          Opal.def(self, '$add_to_children_tree', $Raw_add_to_children_tree$3 = function $$add_to_children_tree(chars) {
            var $a, self = this, letter = nil, child = nil;

            
            letter = chars.$pop();
            child = ($truthy($a = self.$children_tree()['$[]'](letter)) ? $a : self.$new_node(letter));
            child.$add(chars);
            return child;
          }, $Raw_add_to_children_tree$3.$$arity = 1);
          
          Opal.def(self, '$new_node', $Raw_new_node$4 = function $$new_node(letter) {
            var self = this, node = nil, $writer = nil;

            
            node = $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Raw').$new(letter, self);
            
            $writer = [letter, node];
            $send(self.$children_tree(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return node;
          }, $Raw_new_node$4.$$arity = 1);
          
          Opal.def(self, '$partial_word_chars?', $Raw_partial_word_chars$ques$5 = function(chars) {
            var self = this, letter = nil, child = nil;

            
            
            if (chars == null) {
              chars = [];
            };
            letter = chars.$shift().$to_sym();
            child = self.$children_tree()['$[]'](letter);
            if ($truthy(child)) {
            } else {
              return false
            };
            return child['$partial_word?'](chars);
          }, $Raw_partial_word_chars$ques$5.$$arity = -1);
          
          Opal.def(self, '$word_chars?', $Raw_word_chars$ques$6 = function(chars) {
            var self = this, letter = nil, child = nil;

            
            
            if (chars == null) {
              chars = [];
            };
            letter = chars.$shift().$to_sym();
            child = self.$children_tree()['$[]'](letter);
            if ($truthy(child)) {
            } else {
              return false
            };
            return child['$word?'](chars);
          }, $Raw_word_chars$ques$6.$$arity = -1);
          
          Opal.def(self, '$closest_node', $Raw_closest_node$7 = function $$closest_node(chars) {
            var self = this, letter = nil, child = nil;

            
            letter = chars.$shift().$to_sym();
            child = self.$children_tree()['$[]'](letter);
            if ($truthy(child)) {
            } else {
              return self.$missing()
            };
            return child.$scan(chars);
          }, $Raw_closest_node$7.$$arity = 1);
          return (Opal.def(self, '$children_match_prefix', $Raw_children_match_prefix$8 = function $$children_match_prefix(chars) {
            var $$9, $iter = $Raw_children_match_prefix$8.$$p, $yield = $iter || nil, self = this, letter = nil, child = nil;

            if ($iter) $Raw_children_match_prefix$8.$$p = null;
            
            if (($yield !== nil)) {
            } else {
              return self.$enum_for("children_match_prefix", chars)
            };
            if ($truthy(chars['$empty?']())) {
              return nil};
            letter = chars.$shift().$to_sym();
            child = self.$children_tree()['$[]'](letter);
            if ($truthy(child)) {
            } else {
              return nil
            };
            return $send(child, 'match_prefix', [chars], ($$9 = function(word){var self = $$9.$$s || this;

            
              
              if (word == null) {
                word = nil;
              };
              return Opal.yield1($yield, word);;}, $$9.$$s = self, $$9.$$arity = 1, $$9));
          }, $Raw_children_match_prefix$8.$$arity = 1), nil) && 'children_match_prefix';
        })($nesting[0], $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Nodes'), 'Node'), $nesting)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/nodes"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$require']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    
    self.$require("rambling/trie/nodes/node");
    self.$require("rambling/trie/nodes/compressed");
    self.$require("rambling/trie/nodes/missing");
    self.$require("rambling/trie/nodes/raw");
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Nodes');

        var $nesting = [self].concat($parent_nesting);

        nil
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      Opal.const_set($nesting[0], 'VERSION', "2.1.1")
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling/trie"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$require', '$call', '$root_builder', '$new', '$compressor', '$resolve', '$readers', '$each_word', '$<<', '$serializers', '$load', '$dump', '$root', '$properties', '$private']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    
    self.$require("rambling/trie/configuration");
    self.$require("rambling/trie/comparable");
    self.$require("rambling/trie/compressible");
    self.$require("rambling/trie/compressor");
    self.$require("rambling/trie/container");
    self.$require("rambling/trie/enumerable");
    self.$require("rambling/trie/inspectable");
    self.$require("rambling/trie/invalid_operation");
    self.$require("rambling/trie/readers");
    self.$require("rambling/trie/serializers");
    self.$require("rambling/trie/stringifyable");
    self.$require("rambling/trie/nodes");
    self.$require("rambling/trie/version");
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Rambling');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Trie');

      var $nesting = [self].concat($parent_nesting);

      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting), $create$1, $load$4, $dump$6, $config$7, $properties$8, $readers$9, $serializers$10, $compressor$11, $root_builder$12;

        
        
        Opal.def(self, '$create', $create$1 = function $$create(filepath, reader) {
          var $$2, $iter = $create$1.$$p, $yield = $iter || nil, self = this, root = nil;

          if ($iter) $create$1.$$p = null;
          
          
          if (filepath == null) {
            filepath = nil;
          };
          
          if (reader == null) {
            reader = nil;
          };
          root = self.$root_builder().$call();
          return $send($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Container'), 'new', [root, self.$compressor()], ($$2 = function(container){var self = $$2.$$s || this, $a, $$3;

          
            
            if (container == null) {
              container = nil;
            };
            if ($truthy(filepath)) {
              
              reader = ($truthy($a = reader) ? $a : self.$readers().$resolve(filepath));
              $send(reader, 'each_word', [filepath], ($$3 = function(word){var self = $$3.$$s || this;

              
                
                if (word == null) {
                  word = nil;
                };
                return container['$<<'](word);}, $$3.$$s = self, $$3.$$arity = 1, $$3));};
            if (($yield !== nil)) {
              return Opal.yield1($yield, container);
            } else {
              return nil
            };}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        }, $create$1.$$arity = -1);
        
        Opal.def(self, '$load', $load$4 = function $$load(filepath, serializer) {
          var $a, $$5, $iter = $load$4.$$p, $yield = $iter || nil, self = this, root = nil;

          if ($iter) $load$4.$$p = null;
          
          
          if (serializer == null) {
            serializer = nil;
          };
          serializer = ($truthy($a = serializer) ? $a : self.$serializers().$resolve(filepath));
          root = serializer.$load(filepath);
          return $send($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Container'), 'new', [root, self.$compressor()], ($$5 = function(container){var self = $$5.$$s || this;

          
            
            if (container == null) {
              container = nil;
            };
            if (($yield !== nil)) {
              return Opal.yield1($yield, container);
            } else {
              return nil
            };}, $$5.$$s = self, $$5.$$arity = 1, $$5));
        }, $load$4.$$arity = -2);
        
        Opal.def(self, '$dump', $dump$6 = function $$dump(trie, filepath, serializer) {
          var $a, self = this;

          
          
          if (serializer == null) {
            serializer = nil;
          };
          serializer = ($truthy($a = serializer) ? $a : self.$serializers().$resolve(filepath));
          return serializer.$dump(trie.$root(), filepath);
        }, $dump$6.$$arity = -3);
        
        Opal.def(self, '$config', $config$7 = function $$config() {
          var $iter = $config$7.$$p, $yield = $iter || nil, self = this;

          if ($iter) $config$7.$$p = null;
          
          if (($yield !== nil)) {
            Opal.yield1($yield, self.$properties())};
          return self.$properties();
        }, $config$7.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$properties', $properties$8 = function $$properties() {
          var $a, self = this;
          if (self.properties == null) self.properties = nil;

          return (self.properties = ($truthy($a = self.properties) ? $a : $$$($$$($$$($$($nesting, 'Rambling'), 'Trie'), 'Configuration'), 'Properties').$new()))
        }, $properties$8.$$arity = 0);
        
        Opal.def(self, '$readers', $readers$9 = function $$readers() {
          var self = this;

          return self.$properties().$readers()
        }, $readers$9.$$arity = 0);
        
        Opal.def(self, '$serializers', $serializers$10 = function $$serializers() {
          var self = this;

          return self.$properties().$serializers()
        }, $serializers$10.$$arity = 0);
        
        Opal.def(self, '$compressor', $compressor$11 = function $$compressor() {
          var self = this;

          return self.$properties().$compressor()
        }, $compressor$11.$$arity = 0);
        return (Opal.def(self, '$root_builder', $root_builder$12 = function $$root_builder() {
          var self = this;

          return self.$properties().$root_builder()
        }, $root_builder$12.$$arity = 0), nil) && 'root_builder';
      })(Opal.get_singleton_class(self), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["rambling-trie"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  return self.$require("rambling/trie")
};

/* Generated by Opal 1.0.3 */
Opal.modules["json"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$new', '$push', '$[]=', '$-', '$[]', '$create_id', '$json_create', '$const_get', '$attr_accessor', '$create_id=', '$===', '$parse', '$generate', '$from_object', '$merge', '$to_json', '$responds_to?', '$to_io', '$write', '$to_s', '$to_a', '$strftime']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $nesting = [self].concat($parent_nesting), $JSON_$$$1, $JSON_parse$2, $JSON_parse$excl$3, $JSON_load$4, $JSON_from_object$5, $JSON_generate$6, $JSON_dump$7, $writer = nil;

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'JSONError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParserError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'JSONError'), $nesting);
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$($nesting, 'JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'null':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                (($writer = [k, to_opal(value[k], options)]), $send((hash), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$($nesting, 'JSON').$create_id())) != nil) {
              return $$$('::', 'Object').$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    
    $writer = ["json_class"];
    $send(self, 'create_id=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.defs(self, '$[]', $JSON_$$$1 = function(value, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      if ($truthy($$($nesting, 'String')['$==='](value))) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, $JSON_$$$1.$$arity = -2);
    Opal.defs(self, '$parse', $JSON_parse$2 = function $$parse(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, $JSON_parse$2.$$arity = -2);
    Opal.defs(self, '$parse!', $JSON_parse$excl$3 = function(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$parse(source, options);
    }, $JSON_parse$excl$3.$$arity = -2);
    Opal.defs(self, '$load', $JSON_load$4 = function $$load(source, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return self.$from_object($parse(source), options);
    }, $JSON_load$4.$$arity = -2);
    Opal.defs(self, '$from_object', $JSON_from_object$5 = function $$from_object(js_object, options) {
      var $a, self = this, $writer = nil;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      ($truthy($a = options['$[]']("object_class")) ? $a : (($writer = ["object_class", $$($nesting, 'Hash')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      ($truthy($a = options['$[]']("array_class")) ? $a : (($writer = ["array_class", $$($nesting, 'Array')]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
      return to_opal(js_object, options.$$smap);;
    }, $JSON_from_object$5.$$arity = -2);
    Opal.defs(self, '$generate', $JSON_generate$6 = function $$generate(obj, options) {
      var self = this;

      
      
      if (options == null) {
        options = $hash2([], {});
      };
      return obj.$to_json(options);
    }, $JSON_generate$6.$$arity = -2);
    Opal.defs(self, '$dump', $JSON_dump$7 = function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      
      if (io == null) {
        io = nil;
      };
      
      if (limit == null) {
        limit = nil;
      };
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()};
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, $JSON_dump$7.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_to_json$8;

    return (Opal.def(self, '$to_json', $Object_to_json$8 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Object_to_json$8.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_to_json$9;

    
    Opal.def(self, '$to_json', $Enumerable_to_json$9 = function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, $Enumerable_to_json$9.$$arity = 0)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_json$10;

    return (Opal.def(self, '$to_json', $Array_to_json$10 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_to_json$10.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_json$11;

    return (Opal.def(self, '$to_json', $Boolean_to_json$11 = function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_json$11.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_to_json$12;

    return (Opal.def(self, '$to_json', $Hash_to_json$12 = function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(', ') + '}';
    
    }, $Hash_to_json$12.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_json$13;

    return (Opal.def(self, '$to_json', $NilClass_to_json$13 = function $$to_json() {
      var self = this;

      return "null"
    }, $NilClass_to_json$13.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_json$14;

    return (Opal.def(self, '$to_json', $Numeric_to_json$14 = function $$to_json() {
      var self = this;

      return self.toString();
    }, $Numeric_to_json$14.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting);

    return Opal.alias(self, "to_json", "inspect")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_json$15;

    return (Opal.def(self, '$to_json', $Time_to_json$15 = function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, $Time_to_json$15.$$arity = 0), nil) && 'to_json'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Date');

    var $nesting = [self].concat($parent_nesting), $Date_to_json$16, $Date_as_json$17;

    
    
    Opal.def(self, '$to_json', $Date_to_json$16 = function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, $Date_to_json$16.$$arity = 0);
    return (Opal.def(self, '$as_json', $Date_as_json$17 = function $$as_json() {
      var self = this;

      return self.$to_s()
    }, $Date_as_json$17.$$arity = 0), nil) && 'as_json';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["mapping"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$attr_reader', '$to_i', '$fetch', '$load_and_serialize_system_mappings', '$new', '$<', '$depth', '$load_system_mappings', '$serialize_system_mappings', '$private', '$parse', '$system_code', '$raise', '$[]', '$include_inherited_mappings', '$build_hashes', '$build_trie', '$flatten', '$push', '$each', '$for', '$+', '$rules', '$postrules', '$merge', '$characters', '$dictionary', '$to_h', '$reverse', '$sort_by', '$size', '$create', '$concat', '$dictionary_trie', '$keys']);
  
  self.$require("rambling-trie");
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Interscript');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'InvalidSystemError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Mapping');

      var $nesting = [self].concat($parent_nesting), $Mapping_initialize$1, $Mapping_for$2, $Mapping_load_and_serialize_system_mappings$3, $Mapping_load_system_mappings$4, $Mapping_serialize_system_mappings$5, $Mapping_include_inherited_mappings$6, $Mapping_build_hashes$8, $Mapping_build_trie$11;

      
      self.$attr_reader("id", "url", "name", "notes", "rules", "tests", "language", "postrules", "characters", "description", "authority_id", "creation_date", "source_script", "destination_script", "chain", "character_separator", "word_separator", "title_case", "downcase", "dictionary", "characters_hash", "dictionary_hash", "segmentation", "transcription", "dictionary_trie");
      
      Opal.def(self, '$initialize', $Mapping_initialize$1 = function $$initialize(system_code, options) {
        var self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        self.system_code = system_code;
        self.depth = options.$fetch("depth", 0).$to_i();
        return self.$load_and_serialize_system_mappings();
      }, $Mapping_initialize$1.$$arity = -2);
      Opal.defs(self, '$for', $Mapping_for$2 = function(system_code, options) {
        var self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return self.$new(system_code, options);
      }, $Mapping_for$2.$$arity = -2);
      
      Opal.def(self, '$load_and_serialize_system_mappings', $Mapping_load_and_serialize_system_mappings$3 = function $$load_and_serialize_system_mappings() {
        var self = this, mappings = nil;

        if ($truthy($rb_lt(self.$depth(), 5))) {
          
          mappings = self.$load_system_mappings();
          return self.$serialize_system_mappings(mappings);
        } else {
          return nil
        }
      }, $Mapping_load_and_serialize_system_mappings$3.$$arity = 0);
      self.$private();
      self.$attr_reader("depth", "system_code");
      
      Opal.def(self, '$load_system_mappings', $Mapping_load_system_mappings$4 = function $$load_system_mappings() {
        var self = this;

        try {
          return $$($nesting, 'JSON').$parse(JSON.stringify(window.yaml_files[self.$system_code()]))
        } catch ($err) {
          if (Opal.rescue($err, [$$$($$($nesting, 'Errno'), 'ENOENT')])) {
            try {
              return self.$raise($$$($$($nesting, 'Interscript'), 'InvalidSystemError').$new("No system mappings found"))
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        }
      }, $Mapping_load_system_mappings$4.$$arity = 0);
      
      Opal.def(self, '$serialize_system_mappings', $Mapping_serialize_system_mappings$5 = function $$serialize_system_mappings(mappings) {
        var $a, self = this;

        
        self.id = mappings.$fetch("id", nil);
        self.url = mappings.$fetch("url", nil);
        self.name = mappings.$fetch("name", nil);
        self.notes = mappings.$fetch("notes", nil);
        self.tests = mappings.$fetch("tests", []);
        self.language = mappings.$fetch("language", nil);
        self.description = mappings.$fetch("description", nil);
        self.authority_id = mappings.$fetch("authority_id", nil);
        self.creation_date = mappings.$fetch("creation_date", nil);
        self.source_script = mappings.$fetch("source_script", nil);
        self.destination_script = mappings.$fetch("destination_script", nil);
        self.chain = mappings.$fetch("chain", []);
        self.character_separator = ($truthy($a = mappings['$[]']("map")['$[]']("character_separator")) ? $a : nil);
        self.word_separator = ($truthy($a = mappings['$[]']("map")['$[]']("word_separator")) ? $a : nil);
        self.title_case = ($truthy($a = mappings['$[]']("map")['$[]']("title_case")) ? $a : false);
        self.downcase = ($truthy($a = mappings['$[]']("map")['$[]']("downcase")) ? $a : false);
        self.rules = ($truthy($a = mappings['$[]']("map")['$[]']("rules")) ? $a : []);
        self.postrules = ($truthy($a = mappings['$[]']("map")['$[]']("postrules")) ? $a : []);
        self.characters = ($truthy($a = mappings['$[]']("map")['$[]']("characters")) ? $a : $hash2([], {}));
        self.dictionary = ($truthy($a = mappings['$[]']("map")['$[]']("dictionary")) ? $a : $hash2([], {}));
        self.segmentation = ($truthy($a = mappings['$[]']("map")['$[]']("segementation")) ? $a : nil);
        self.transcription = ($truthy($a = mappings['$[]']("map")['$[]']("transcription")) ? $a : nil);
        self.$include_inherited_mappings(mappings);
        self.$build_hashes();
        return self.$build_trie();
      }, $Mapping_serialize_system_mappings$5.$$arity = 1);
      
      Opal.def(self, '$include_inherited_mappings', $Mapping_include_inherited_mappings$6 = function $$include_inherited_mappings(mappings) {
        var $$7, self = this, inherit_systems = nil, inherit_system = nil, inherited_mapping = nil;

        
        inherit_systems = [].$push(mappings['$[]']("map")['$[]']("inherit")).$flatten();
        
        ;
        ;
        return $send(inherit_systems, 'each', [], ($$7 = function($for_tmp1){var self = $$7.$$s || this, $a;

        
          
          if ($for_tmp1 == null) {
            $for_tmp1 = nil;
          };
          inherit_system = $for_tmp1;
          if ($truthy(inherit_system)) {
            
            inherited_mapping = $$($nesting, 'Mapping').$for(inherit_system, $hash2(["depth"], {"depth": $rb_plus(self.$depth(), 1)}));
            self.rules = [inherited_mapping.$rules(), self.$rules()].$flatten();
            self.postrules = [inherited_mapping.$postrules(), self.$postrules()].$flatten();
            self.characters = ($truthy($a = inherited_mapping.$characters()) ? $a : $hash2([], {})).$merge(self.$characters());
            return (self.dictionary = ($truthy($a = inherited_mapping.$dictionary()) ? $a : $hash2([], {})).$merge(self.$dictionary()));
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = 1, $$7));;
      }, $Mapping_include_inherited_mappings$6.$$arity = 1);
      
      Opal.def(self, '$build_hashes', $Mapping_build_hashes$8 = function $$build_hashes() {
        var $a, $$9, $b, $c, $d, $$10, $e, $f, self = this;

        
        self.characters_hash = ($c = ($b = ($a = self.$characters(), ($a === nil || $a == null) ? nil : $send($a, 'sort_by', [], ($$9 = function(k, _v){var self = $$9.$$s || this;

        
          
          if (k == null) {
            k = nil;
          };
          
          if (_v == null) {
            _v = nil;
          };
          return k.$size();}, $$9.$$s = self, $$9.$$arity = 2, $$9))), ($b === nil || $b == null) ? nil : $send($b, 'reverse', [])), ($c === nil || $c == null) ? nil : $send($c, 'to_h', []));
        return (self.dictionary_hash = ($f = ($e = ($d = self.$dictionary(), ($d === nil || $d == null) ? nil : $send($d, 'sort_by', [], ($$10 = function(k, _v){var self = $$10.$$s || this;

        
          
          if (k == null) {
            k = nil;
          };
          
          if (_v == null) {
            _v = nil;
          };
          return k.$size();}, $$10.$$s = self, $$10.$$arity = 2, $$10))), ($e === nil || $e == null) ? nil : $send($e, 'reverse', [])), ($f === nil || $f == null) ? nil : $send($f, 'to_h', [])));
      }, $Mapping_build_hashes$8.$$arity = 0);
      return (Opal.def(self, '$build_trie', $Mapping_build_trie$11 = function $$build_trie() {
        var self = this;

        
        self.dictionary_trie = $$$($$($nesting, 'Rambling'), 'Trie').$create();
        return self.$dictionary_trie().$concat(self.$dictionary().$keys());
      }, $Mapping_build_trie$11.$$arity = 0), nil) && 'build_trie';
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$!', '$has_key?', '$for', '$[]=', '$-', '$[]', '$dup', '$chain', '$>', '$length', '$transliterate', '$shift', '$character_separator', '$word_separator', '$title_case', '$downcase', '$characters_hash', '$dictionary_hash', '$dictionary_trie', '$<', '$size', '$to_s', '$+', '$partial_word?', '$word?', '$clone', '$new', '$each', '$rules', '$gsub', '$match', '$first', '$offset', '$up_case_around?', '$upcase', '$is_a?', '$add_separator', '$postrules', '$sub', '$to_proc', '$!=', '$unicode_normalize', '$private', '$==', '$positive?', '$!~', '$>=', '$strip', '$empty?']);
  
  self.$require("opal");
  self.$require("yaml");
  self.$require("mapping");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Interscript');

    var $nesting = [self].concat($parent_nesting);

    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $transliterate$1, $add_separator$5, $up_case_around$ques$6;

      
      
      Opal.def(self, '$transliterate', $transliterate$1 = function $$transliterate(system_code, string, maps) {
        var $a, $b, $c, $$2, $$3, $$4, self = this, $writer = nil, mapping = nil, chain = nil, separator = nil, word_separator = nil, title_case = nil, downcase = nil, charmap = nil, dictmap = nil, trie = nil, pos = nil, m = nil, wordmatch = nil, repl = nil, output = nil, offsets = nil;

        
        
        if (maps == null) {
          maps = $hash2([], {});
        };
        if ($truthy(maps['$has_key?'](system_code)['$!']())) {
          
          $writer = [system_code, $$$($$($nesting, 'Interscript'), 'Mapping').$for(system_code)];
          $send(maps, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        mapping = maps['$[]'](system_code);
        chain = mapping.$chain().$dup();
        while ($truthy($rb_gt(chain.$length(), 0))) {
          string = self.$transliterate(chain.$shift(), string, maps)
        };
        separator = ($truthy($a = mapping.$character_separator()) ? $a : "");
        word_separator = ($truthy($a = mapping.$word_separator()) ? $a : "");
        title_case = mapping.$title_case();
        downcase = mapping.$downcase();
        charmap = mapping.$characters_hash();
        dictmap = mapping.$dictionary_hash();
        trie = mapping.$dictionary_trie();
        pos = 0;
        while ($truthy($rb_lt(pos, string.$to_s().$size()))) {
          
          m = 0;
          wordmatch = "";
          while ($truthy(($truthy($c = $rb_lt($rb_plus(pos, m), string.$to_s().$size())) ? trie['$partial_word?'](string['$[]'](Opal.Range.$new(pos, $rb_plus(pos, m), false))) : $c))) {
            
            if ($truthy(trie['$word?'](string['$[]'](Opal.Range.$new(pos, $rb_plus(pos, m), false))))) {
              wordmatch = string['$[]'](Opal.Range.$new(pos, $rb_plus(pos, m), false))};
            m = $rb_plus(m, 1);
          };
          m = wordmatch.$length();
          if ($truthy($rb_gt(m, 0))) {
            
            repl = dictmap['$[]'](string['$[]'](Opal.Range.$new(pos, $rb_minus($rb_plus(pos, m), 1), false)));
            
            $writer = [Opal.Range.$new(pos, $rb_minus($rb_plus(pos, m), 1), false), repl];
            $send(string, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            pos = $rb_plus(pos, repl.$length());
          } else {
            pos = $rb_plus(pos, 1)
          };
        };
        output = string.$clone();
        offsets = $$($nesting, 'Array').$new(string.$to_s().$size(), 1);
        $send(mapping.$rules(), 'each', [], ($$2 = function(r){var self = $$2.$$s || this;

        
          
          if (r == null) {
            r = nil;
          };
          return (output = output.$gsub(new RegExp(r['$[]']("pattern"), 'u'), r['$[]']("result")));}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        $send(charmap, 'each', [], ($$3 = function(k, v){var self = $$3.$$s || this, $d, $e, $f, match = nil, result = nil;

        
          
          if (k == null) {
            k = nil;
          };
          
          if (v == null) {
            v = nil;
          };
          while ($truthy((match = ($e = output, ($e === nil || $e == null) ? nil : $send($e, 'match', [new RegExp(k, 'u')]))))) {
            
            pos = match.$offset(0).$first();
            result = (function() {if ($truthy(($truthy($f = downcase['$!']()) ? self['$up_case_around?'](output, pos) : $f))) {
              return v.$upcase()
            } else {
              return v
            }; return nil; })();
            if ($truthy(result['$is_a?']($$($nesting, 'Array')))) {
              result = result['$[]'](0)};
            output = $rb_plus($rb_plus(output['$[]'](0, pos), self.$add_separator(separator, pos, result)), output['$[]'](Opal.Range.$new($rb_plus(pos, match['$[]'](0).$size()), -1, false)));
          };}, $$3.$$s = self, $$3.$$arity = 2, $$3));
        $send(mapping.$postrules(), 'each', [], ($$4 = function(r){var self = $$4.$$s || this;

        
          
          if (r == null) {
            r = nil;
          };
          return (output = output.$gsub(new RegExp(r['$[]']("pattern"), 'u'), r['$[]']("result")));}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        if ($truthy(output)) {
          
          if ($truthy(title_case)) {
            output = $send(output, 'sub', [/^(.)/], "upcase".$to_proc())};
          if ($truthy(word_separator['$!='](""))) {
            
            output = output.$gsub(new RegExp("" + (word_separator) + (separator), 'u'), word_separator);
            if ($truthy(title_case)) {
              output = $send(output, 'gsub', [new RegExp("" + (word_separator) + "(.)", 'u')], "upcase".$to_proc())};};};
        if ($truthy(output)) {
          return output.$unicode_normalize()
        } else {
          return output
        };
      }, $transliterate$1.$$arity = -3);
      self.$private();
      
      Opal.def(self, '$add_separator', $add_separator$5 = function $$add_separator(separator, pos, result) {
        var self = this;

        if (pos['$=='](0)) {
          return result
        } else {
          return $rb_plus(separator, result)
        }
      }, $add_separator$5.$$arity = 3);
      return (Opal.def(self, '$up_case_around?', $up_case_around$ques$6 = function(string, pos) {
        var $a, $b, self = this, i = nil, before = nil, after = nil, before_uc = nil, after_uc = nil;

        
        if (string['$[]'](pos)['$=='](string['$[]'](pos).$downcase())) {
          return false};
        i = $rb_minus(pos, 1);
        while ($truthy(($truthy($b = i['$positive?']()) ? string['$[]'](i)['$!~'](/\p{L}/u) : $b))) {
          i = $rb_minus(i, 1)
        };
        before = (function() {if ($truthy(($truthy($a = $rb_ge(i, 0)) ? $rb_lt(i, pos) : $a))) {
          return string['$[]'](i).$to_s().$strip()
        } else {
          return ""
        }; return nil; })();
        i = $rb_plus(pos, 1);
        while ($truthy(($truthy($b = $rb_lt(i, $rb_minus(string.$size(), 1))) ? string['$[]'](i)['$!~'](/\p{L}/u) : $b))) {
          i = $rb_plus(i, 1)
        };
        after = (function() {if ($truthy($rb_gt(i, pos))) {
          return string['$[]'](i).$to_s().$strip()
        } else {
          return ""
        }; return nil; })();
        before_uc = ($truthy($a = before['$empty?']()['$!']()) ? before['$=='](before.$upcase()) : $a);
        after_uc = ($truthy($a = after['$empty?']()['$!']()) ? after['$=='](after.$upcase()) : $a);
        return ($truthy($a = before_uc) ? $a : after_uc);
      }, $up_case_around$ques$6.$$arity = 2), nil) && 'up_case_around?';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], $nesting);
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAvLyBAbm90ZVxuICAvLyAgIEEgZmV3IGNvbnZlbnRpb25zIGZvciB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZpbGU6XG4gIC8vICAgMS4gQWx3YXlzIHVzZSBcIi8vXCIgKGluIGNvbnRyYXN0IHdpdGggXCIvKiovXCIpXG4gIC8vICAgMi4gVGhlIHN5bnRheCB1c2VkIGlzIFlhcmRvYyAoeWFyZG9jLm9yZyksIHdoaWNoIGlzIGludGVuZGVkIGZvciBSdWJ5IChzZSBiZWxvdylcbiAgLy8gICAzLiBgQHBhcmFtYCBhbmQgYEByZXR1cm5gIHR5cGVzIHNob3VsZCBiZSBwcmVjZWRlZCBieSBgSlMuYCB3aGVuIHJlZmVycmluZyB0b1xuICAvLyAgICAgIEphdmFTY3JpcHQgY29uc3RydWN0b3JzIChlLmcuIGBKUy5GdW5jdGlvbmApIG90aGVyd2lzZSBSdWJ5IGlzIGFzc3VtZWQuXG4gIC8vICAgNC4gYG5pbGAgYW5kIGBudWxsYCBiZWluZyB1bmFtYmlndW91cyByZWZlciB0byB0aGUgcmVzcGVjdGl2ZVxuICAvLyAgICAgIG9iamVjdHMvdmFsdWVzIGluIFJ1YnkgYW5kIEphdmFTY3JpcHRcbiAgLy8gICA1LiBUaGlzIGlzIHN0aWxsIFdJUCA6KSBzbyBwbGVhc2UgZ2l2ZSBmZWVkYmFjayBhbmQgc3VnZ2VzdGlvbnMgb24gaG93XG4gIC8vICAgICAgdG8gaW1wcm92ZSBvciBmb3IgYWx0ZXJuYXRpdmUgc29sdXRpb25zXG4gIC8vXG4gIC8vICAgVGhlIHdheSB0aGUgY29kZSBpcyBkaWdlc3RlZCBiZWZvcmUgZ29pbmcgdGhyb3VnaCBZYXJkb2MgaXMgYSBzZWNyZXQga2VwdFxuICAvLyAgIGluIHRoZSBkb2NzIHJlcG8gKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL2RvY3MvdHJlZS9tYXN0ZXIpLlxuXG4gIHZhciBnbG9iYWxfb2JqZWN0ID0gdGhpcywgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWwpICE9PSAndW5kZWZpbmVkJykgeyBnbG9iYWxfb2JqZWN0ID0gZ2xvYmFsOyB9XG4gIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IHdpbmRvdzsgfVxuXG4gIC8vIFNldHVwIGEgZHVtbXkgY29uc29sZSBvYmplY3QgaWYgbWlzc2luZ1xuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIGlmIChnbG9iYWxfb2JqZWN0LmNvbnNvbGUgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGUgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YodGhpcy5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIHRoaXMuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsIG9iamVjdCB0aGF0IGlzIGV4cG9zZWQgZ2xvYmFsbHlcbiAgdmFyIE9wYWwgPSB0aGlzLk9wYWwgPSB7fTtcblxuICAvLyBUaGlzIGlzIGEgdXNlZnVsIHJlZmVyZW5jZSB0byBnbG9iYWwgb2JqZWN0IGluc2lkZSBydWJ5IGZpbGVzXG4gIE9wYWwuZ2xvYmFsID0gZ2xvYmFsX29iamVjdDtcbiAgZ2xvYmFsX29iamVjdC5PcGFsID0gT3BhbDtcblxuICAvLyBDb25maWd1cmUgcnVudGltZSBiZWhhdmlvciB3aXRoIHJlZ2FyZHMgdG8gcmVxdWlyZSBhbmQgdW5zdXBwb3J0ZWQgZmVhcnVyZXNcbiAgT3BhbC5jb25maWcgPSB7XG4gICAgbWlzc2luZ19yZXF1aXJlX3NldmVyaXR5OiAnZXJyb3InLCAgICAgICAgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIHVuc3VwcG9ydGVkX2ZlYXR1cmVzX3NldmVyaXR5OiAnd2FybmluZycsIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICBlbmFibGVfc3RhY2tfdHJhY2U6IHRydWUgICAgICAgICAgICAgICAgICAvLyB0cnVlLCBmYWxzZVxuICB9O1xuXG4gIC8vIE1pbmlmeSBjb21tb24gZnVuY3Rpb24gY2FsbHNcbiAgdmFyICRoYXNPd24gICAgICAgPSBPYmplY3QuaGFzT3duUHJvcGVydHk7XG4gIHZhciAkYmluZCAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG4gIHZhciAkc2V0UHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICB2YXIgJHNsaWNlICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgdmFyICRzcGxpY2UgICAgICAgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXG4gIC8vIE5pbCBvYmplY3QgaWQgaXMgYWx3YXlzIDRcbiAgdmFyIG5pbF9pZCA9IDQ7XG5cbiAgLy8gR2VuZXJhdGVzIGV2ZW4gc2VxdWVudGlhbCBudW1iZXJzIGdyZWF0ZXIgdGhhbiA0XG4gIC8vIChuaWxfaWQpIHRvIHNlcnZlIGFzIHVuaXF1ZSBpZHMgZm9yIHJ1Ynkgb2JqZWN0c1xuICB2YXIgdW5pcXVlX2lkID0gbmlsX2lkO1xuXG4gIC8vIFJldHVybiBuZXh0IHVuaXF1ZSBpZFxuICBPcGFsLnVpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHVuaXF1ZV9pZCArPSAyO1xuICAgIHJldHVybiB1bmlxdWVfaWQ7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgb3IgYXNzaWduIHRoZSBpZCBvZiBhbiBvYmplY3RcbiAgT3BhbC5pZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouJCRpc19udW1iZXIpIHJldHVybiAob2JqICogMikrMTtcbiAgICBpZiAob2JqLiQkaWQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iai4kJGlkO1xuICAgIH1cbiAgICAkZGVmaW5lUHJvcGVydHkob2JqLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xuICAgIHJldHVybiBvYmouJCRpZDtcbiAgfTtcblxuICAvLyBHbG9iYWxzIHRhYmxlXG4gIE9wYWwuZ3ZhcnMgPSB7fTtcblxuICAvLyBFeGl0IGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXBsYWNlZCBieSBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAvLyAoU2VlIG5vZGVqcyBhbmQgY2hyb21lIGZvciBleGFtcGxlcylcbiAgT3BhbC5leGl0ID0gZnVuY3Rpb24oc3RhdHVzKSB7IGlmIChPcGFsLmd2YXJzLkRFQlVHKSBjb25zb2xlLmxvZygnRXhpdGVkIHdpdGggc3RhdHVzICcrc3RhdHVzKTsgfTtcblxuICAvLyBrZWVwcyB0cmFjayBvZiBleGNlcHRpb25zIGZvciAkIVxuICBPcGFsLmV4Y2VwdGlvbnMgPSBbXTtcblxuICAvLyBAcHJpdmF0ZVxuICAvLyBQb3BzIGFuIGV4Y2VwdGlvbiBmcm9tIHRoZSBzdGFjayBhbmQgdXBkYXRlcyBgJCFgLlxuICBPcGFsLnBvcF9leGNlcHRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKSB8fCBuaWw7XG4gIH07XG5cbiAgLy8gSW5zcGVjdCBhbnkga2luZCBvZiBvYmplY3QsIGluY2x1ZGluZyBub24gUnVieSBvbmVzXG4gIE9wYWwuaW5zcGVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqLiQkY2xhc3MpIHtcbiAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gb2JqLiRpbnNwZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2Yob2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvcjpcbiAgICAgIC8vICAgcyA9IFwic3RyaW5nXCJcbiAgICAgIC8vICAgZGVmIHMubTsgZW5kXG4gICAgICAvLyBTdHJpbmcgY2xhc3MgaXMgdGhlIG9ubHkgY2xhc3MgdGhhdDpcbiAgICAgIC8vICsgY29tcGlsZXMgdG8gSlMgcHJpbWl0aXZlXG4gICAgICAvLyArIGFsbG93cyBtZXRob2QgZGVmaW5pdGlvbiBkaXJlY3RseSBvbiBpbnN0YW5jZXNcbiAgICAgIC8vIG51bWJlcnMsIHRydWUsIGZhbHNlIGFuZCBuaWwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSAkZGVmaW5lUHJvcGVydHk7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIFRydXRoXG4gIC8vIC0tLS0tXG5cbiAgT3BhbC50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCAhPT0gbmlsICYmIHZhbCAhPSBudWxsICYmICghdmFsLiQkaXNfYm9vbGVhbiB8fCB2YWwgPT0gdHJ1ZSkpO1xuICB9O1xuXG4gIE9wYWwuZmFsc3kgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCA9PT0gbmlsIHx8IHZhbCA9PSBudWxsIHx8ICh2YWwuJCRpc19ib29sZWFuICYmIHZhbCA9PSBmYWxzZSkpXG4gIH07XG5cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIHJlc3VsdCwgY29uc3RhbnQ7XG5cbiAgICBpZiAobmVzdGluZy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIElmIHRoZSBuZXN0aW5nIGlzIG5vdCBlbXB0eSB0aGUgY29uc3RhbnQgaXMgbG9va2VkIHVwIGluIGl0cyBlbGVtZW50c1xuICAgIC8vIGFuZCBpbiBvcmRlci4gVGhlIGFuY2VzdG9ycyBvZiB0aG9zZSBlbGVtZW50cyBhcmUgaWdub3JlZC5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3RhbnQgPSBuZXN0aW5nW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICBpZiAoY29uc3RhbnQgIT0gbnVsbCkgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCByZXN1bHQsIGFuY2VzdG9ycztcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKGNyZWYpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGNvbnN0ICYmICRoYXNPd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEb24gbm90IHNob3cgT2JqZWN0cyBjb25zdGFudHMgdW5sZXNzIHdlJ3JlIHF1ZXJ5aW5nIE9iamVjdCBpdHNlbGZcbiAgICAgIGlmIChjcmVmICE9PSBfT2JqZWN0ICYmIG1vZHVsZSA9PSBfT2JqZWN0KSBicmVhaztcblxuICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRjb25zdCkge1xuICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgfTtcblxuICAvLyBSZW1vdmUgYSBjb25zdGFudCBmcm9tIGEgY3JlZi5cbiAgT3BhbC5jb25zdF9yZW1vdmUgPSBmdW5jdGlvbihjcmVmLCBuYW1lKSB7XG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG5cbiAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgIHZhciBvbGQgPSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICBkZWxldGUgY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgcmV0dXJuIG9sZDtcbiAgICB9XG5cbiAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICE9IG51bGwgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdICE9IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cblxuICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJjb25zdGFudCBcIitjcmVmK1wiOjpcIitjcmVmLiRuYW1lKCkrXCIgbm90IGRlZmluZWRcIik7XG4gIH07XG5cblxuICAvLyBNb2R1bGVzICYgQ2xhc3Nlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgYGNsYXNzIEZvbzsgZW5kYCBleHByZXNzaW9uIGluIHJ1YnkgaXMgY29tcGlsZWQgdG8gY2FsbCB0aGlzIHJ1bnRpbWVcbiAgLy8gbWV0aG9kIHdoaWNoIGVpdGhlciByZXR1cm5zIGFuIGV4aXN0aW5nIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lLCBvciBjcmVhdGVzXG4gIC8vIGEgbmV3IGNsYXNzIGluIHRoZSBnaXZlbiBgYmFzZWAgc2NvcGUuXG4gIC8vXG4gIC8vIElmIGEgY29uc3RhbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHRoZW4gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXRcbiAgLy8gaXQgaXMgYSBjbGFzcyBhbmQgYWxzbyB0aGF0IHRoZSBzdXBlcmNsYXNzZXMgbWF0Y2guIElmIGVpdGhlciBvZiB0aGVzZVxuICAvLyBmYWlsLCB0aGVuIHdlIHJhaXNlIGEgYFR5cGVFcnJvcmAuIE5vdGUsIGBzdXBlcmNsYXNzYCBtYXkgYmUgbnVsbCBpZiBvbmVcbiAgLy8gd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHJ1YnkgY29kZS5cbiAgLy9cbiAgLy8gV2UgcGFzcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgbWV0aG9kIG9mIHRoZSBmb3JtIGBmdW5jdGlvbiBDbGFzc05hbWUoKSB7fWBcbiAgLy8gc2ltcGx5IHNvIHRoYXQgY2xhc3NlcyBzaG93IHVwIHdpdGggbmljZWx5IGZvcm1hdHRlZCBuYW1lcyBpbnNpZGUgZGVidWdnZXJzXG4gIC8vIGluIHRoZSB3ZWIgYnJvd3NlciAob3Igbm9kZS9zcHJvY2tldHMpLlxuICAvL1xuICAvLyBUaGUgYHNjb3BlYCBpcyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gZnJvbS4gV2UgdXNlIHRoaXMgdG8gZ2V0IHRoZSBzY29wZSBmb3Igd2hlcmUgdGhlIGNsYXNzIHNob3VsZCBiZSBjcmVhdGVkLlxuICAvLyBJZiBgc2NvcGVgIGlzIGFuIG9iamVjdCAobm90IGEgY2xhc3MvbW9kdWxlKSwgd2Ugc2ltcGxlIGdldCBpdHMgY2xhc3MgYW5kXG4gIC8vIHVzZSB0aGF0IGFzIHRoZSBzY29wZSBpbnN0ZWFkLlxuICAvL1xuICAvLyBAcGFyYW0gc2NvcGUgICAgICAgIFtPYmplY3RdIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIEBwYXJhbSBzdXBlcmNsYXNzICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIGlkICAgICAgICAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBiZSBjcmVhdGVkXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIGZ1bmN0aW9uIHRvIHVzZSBhcyBjb25zdHJ1Y3RvclxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSBmdW5jdGlvbihuYW1lLCBzdXBlcmNsYXNzKSB7XG4gICAgdmFyIGtsYXNzLCBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwgJiYgc3VwZXJjbGFzcy4kJGJyaWRnZSkge1xuICAgICAgLy8gSW5oZXJpdGFuY2UgZnJvbSBicmlkZ2VkIGNsYXNzZXMgcmVxdWlyZXNcbiAgICAgIC8vIGNhbGxpbmcgb3JpZ2luYWwgSlMgY29uc3RydWN0b3JzXG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBzZWxmID0gbmV3ICgkYmluZC5hcHBseShzdXBlcmNsYXNzLiQkY29uc3RydWN0b3IsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcbiAgICAgICAgJHNldFByb3RvdHlwZShzZWxmLCBrbGFzcy4kJHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xuICAgIH1cblxuICAgIGtsYXNzID0gY29uc3RydWN0b3I7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0cnVjdG9yJywgY29uc3RydWN0b3IpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkaXNfY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9ycycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcbiAgICAvLyBfX3Byb3RvX18gaXMgQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gTGF0ZXIgc2luZ2xldG9uIG1ldGhvZHMgZ2VuZXJhdGUgYSBzaW5nbGV0b25fY2xhc3NcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXG4gICAgaWYgKE9wYWwuQ2xhc3MpIHtcbiAgICAgICRzZXRQcm90b3R5cGUoa2xhc3MsIE9wYWwuQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsKSB7XG4gICAgICAkc2V0UHJvdG90eXBlKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XG4gICAgICAgIC8vIElmIHN1cGVyY2xhc3MgaGFzIG1ldGFjbGFzcyB0aGVuIHdlIGhhdmUgZXhwbGljaXRlbHkgaW5oZXJpdCBpdC5cbiAgICAgICAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Moa2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICB2YXIga2xhc3MgPSBjb25zdF9nZXRfbmFtZShzY29wZSwgbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGV4aXN0aW5nIGNvbnN0YW50IGlzIGEgY2xhc3MsIG9yIHJhaXNlIGVycm9yXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbWlzbWF0Y2ggZm9yIGNsYXNzIFwiICsga2xhc3MuJCRuYW1lKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmtsYXNzID0gZnVuY3Rpb24oc2NvcGUsIHN1cGVyY2xhc3MsIG5hbWUpIHtcbiAgICB2YXIgYnJpZGdlZDtcblxuICAgIGlmIChzY29wZSA9PSBudWxsKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmICFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIGJyaWRnZWQgPSBzdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAoa2xhc3MpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLy8gQ2xhc3MgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIGdpdmVuIHN1cGVyY2xhc3MuLi5cblxuICAgIC8vIE5vdCBzcGVjaWZ5aW5nIGEgc3VwZXJjbGFzcyBtZWFucyB3ZSBjYW4gYXNzdW1lIGl0IHRvIGJlIE9iamVjdFxuICAgIGlmIChzdXBlcmNsYXNzID09IG51bGwpIHtcbiAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgY2xhc3Mgb2JqZWN0IChpbnN0YW5jZSBvZiBDbGFzcylcbiAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmFtZSwgc3VwZXJjbGFzcyk7XG4gICAgT3BhbC5jb25zdF9zZXQoc2NvcGUsIG5hbWUsIGtsYXNzKTtcblxuICAgIC8vIENhbGwgLmluaGVyaXRlZCgpIGhvb2sgd2l0aCBuZXcgY2xhc3Mgb24gdGhlIHN1cGVyY2xhc3NcbiAgICBpZiAoc3VwZXJjbGFzcy4kaW5oZXJpdGVkKSB7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChicmlkZ2VkKSB7XG4gICAgICBPcGFsLmJyaWRnZShicmlkZ2VkLCBrbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIC8vIERlZmluZSBuZXcgbW9kdWxlIChvciByZXR1cm4gZXhpc3RpbmcgbW9kdWxlKS4gVGhlIGdpdmVuIGBzY29wZWAgaXMgYmFzaWNhbGx5XG4gIC8vIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB0aGUgYG1vZHVsZWAgc3RhdGVtZW50IHdhcyBkZWZpbmVkIGluLiBJZiB0aGlzIGlzXG4gIC8vIGEgcnVieSBtb2R1bGUgb3IgY2xhc3MsIHRoZW4gaXQgaXMgdXNlZCwgb3RoZXJ3aXNlIGlmIHRoZSBzY29wZSBpcyBhIHJ1YnlcbiAgLy8gb2JqZWN0IHRoZW4gdGhhdCBvYmplY3RzIHJlYWwgcnVieSBjbGFzcyBpcyB1c2VkIChlLmcuIGlmIHRoZSBzY29wZSBpcyB0aGVcbiAgLy8gbWFpbiBvYmplY3QsIHRoZW4gdGhlIHRvcCBsZXZlbCBgT2JqZWN0YCBjbGFzcyBpcyB1c2VkIGFzIHRoZSBzY29wZSkuXG4gIC8vXG4gIC8vIElmIGEgbW9kdWxlIG9mIHRoZSBnaXZlbiBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgc2NvcGUsIHRoZW4gdGhhdFxuICAvLyBpbnN0YW5jZSBpcyBqdXN0IHJldHVybmVkLlxuICAvL1xuICAvLyBJZiB0aGVyZSBpcyBhIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBzY29wZSwgdGhlbiBhbiBlcnJvciBpc1xuICAvLyBnZW5lcmF0ZWQgaW5zdGVhZCAoY2Fubm90IGhhdmUgYSBjbGFzcyBhbmQgbW9kdWxlIG9mIHNhbWUgbmFtZSBpbiBzYW1lIHNjb3BlKS5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBtb2R1bGUgaXMgY3JlYXRlZCBpbiB0aGUgc2NvcGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoYXRcbiAgLy8gbmV3IGluc3RhbmNlIGlzIHJldHVybmVkIGJhY2sgKHRvIGJlIHJlZmVyZW5jZWQgYXQgcnVudGltZSkuXG4gIC8vXG4gIC8vIEBwYXJhbSAgc2NvcGUgW01vZHVsZSwgQ2xhc3NdIGNsYXNzIG9yIG1vZHVsZSB0aGlzIGRlZmluaXRpb24gaXMgaW5zaWRlXG4gIC8vIEBwYXJhbSAgaWQgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgbmV3IChvciBleGlzdGluZykgbW9kdWxlXG4gIC8vXG4gIC8vIEByZXR1cm4gW01vZHVsZV1cbiAgT3BhbC5hbGxvY2F0ZV9tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKXt9O1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy4kJGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKG5hbWUpXG4gICAgICAkZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy5jb25zdHJ1Y3RvcicpO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkbmFtZScsIG5hbWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY29uc3QnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaXNfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaXNfYV9tb2R1bGUnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRjdmFycycsIHt9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRpY2xhc3NlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkYW5jZXN0b3JzJywgW21vZHVsZV0pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkc2V0UHJvdG90eXBlKG1vZHVsZSwgT3BhbC5Nb2R1bGUucHJvdG90eXBlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIE9wYWwubW9kdWxlID0gZnVuY3Rpb24oc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICBPcGFsLmNvbnN0X3NldChzY29wZSwgbmFtZSwgbW9kdWxlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldGluX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0UHJvdG90eXBlKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldGluX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldFByb3RvdHlwZShtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0UHJvdG90eXBlKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzT3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgYW5jZXN0b3IuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcHJvdG8gPSBpbmNsdWRlci4kJHByb3RvdHlwZSwgcGFyZW50ID0gcHJvdG8sIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSb290KG1vZHVsZV9pY2xhc3MpICYmIG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG5cbiAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgIHdoaWxlIChuZXh0X2FuY2VzdG9yLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmICFpc1Jvb3QobmV4dF9hbmNlc3RvcikpIHtcbiAgICAgICAgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXh0X2FuY2VzdG9yKTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICBlbmRfY2hhaW5fb24gPSBuZXh0X2FuY2VzdG9yO1xuICAgIH1cblxuICAgICRzZXRQcm90b3R5cGUoc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0UHJvdG90eXBlKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxuICAgIGluY2x1ZGVyLiQkb3duX2luY2x1ZGVkX21vZHVsZXMgPSBvd25faW5jbHVkZWRfbW9kdWxlcyhpbmNsdWRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xuICAgIC8vIEhlcmUgd2UgY2hhbmdlIHRoZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgIC8vXG4gICAgLy8gICBwcmVwZW5kZXJcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICAvL1xuICAgIC8vIHRvOlxuICAgIC8vXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICBpY2xhc3MobW9kdWxlKVxuICAgIC8vICAgICAgfFxuICAgIC8vIGljbGFzcyhwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpO1xuICAgIHZhciBpY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKG1vZHVsZV9hbmNlc3RvcnMuaW5kZXhPZihwcmVwZW5kZXIpICE9PSAtMSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ2N5Y2xpYyBwcmVwZW5kIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1vZHVsZV9hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG1vZHVsZV9hbmNlc3RvcnNbaV0sIGljbGFzcyA9IGNyZWF0ZV9pY2xhc3MoYW5jZXN0b3IpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkcHJlcGVuZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBkdW1teV9wcmVwZW5kZXIgPSBwcmVwZW5kZXIuJCRwcm90b3R5cGUsXG4gICAgICAgIHByZXZpb3VzX3BhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpLFxuICAgICAgICBwcmVwZW5kZXJfaWNsYXNzLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGR1bW15X3ByZXBlbmRlci5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGFscmVhZHkgaGFzIHNvbWUgcHJlcGVuZGVkIG1vZHVsZXNcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGl0IFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGR1bW15X3ByZXBlbmRlci4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYWtpbmcgdGhlIG1vZHVsZSBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKHByZXBlbmRlcik7XG4gICAgICBmbHVzaF9tZXRob2RzX2luKHByZXBlbmRlcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkdW1teScsIHRydWUpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KGR1bW15X3ByZXBlbmRlciwgJyQkZGVmaW5lX21ldGhvZHNfb24nLCBwcmVwZW5kZXJfaWNsYXNzKTtcblxuICAgICAgLy8gQ29udmVydGluZ1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgLy8gdG9cbiAgICAgIC8vICAgZHVtbXkocHJlcGVuZGVyKSAtPiBpY2xhc3MocHJlcGVuZGVyKSAtPiBwcmV2aW91c19wYXJlbnRcbiAgICAgICRzZXRQcm90b3R5cGUoZHVtbXlfcHJlcGVuZGVyLCBwcmVwZW5kZXJfaWNsYXNzKTtcbiAgICAgICRzZXRQcm90b3R5cGUocHJlcGVuZGVyX2ljbGFzcywgcHJldmlvdXNfcGFyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgcHJlcGVuZGVyX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHByZXBlbmRlcik7XG5cbiAgICBpZiAocHJlcGVuZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIHByZXBlbmRcblxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBkdW1teV9wcmVwZW5kZXI7XG5cbiAgICAgIC8vIG5leHQgJCRyb290IG9yIHByZXBlbmRlcl9pY2xhc3Mgb3Igbm9uLSQkaWNsYXNzXG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKTtcbiAgICAgIHdoaWxlIChlbmRfY2hhaW5fb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJHJvb3QnKSB8fFxuICAgICAgICAgIGVuZF9jaGFpbl9vbiA9PT0gcHJlcGVuZGVyX2ljbGFzcyB8fFxuICAgICAgICAgICFlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZW5kX2NoYWluX29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5SdW50aW1lRXJyb3IuJG5ldyhcIlByZXBlbmRpbmcgYSBtb2R1bGUgbXVsdGlwbGUgdGltZXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG5cbiAgICAkc2V0UHJvdG90eXBlKHN0YXJ0X2NoYWluX2FmdGVyLCBjaGFpbi5maXJzdCk7XG4gICAgJHNldFByb3RvdHlwZShjaGFpbi5sYXN0LCBlbmRfY2hhaW5fb24pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgb3duX3ByZXBlbmRlZF9tb2R1bGVzIGNhY2hlXG4gICAgcHJlcGVuZGVyLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzID0gb3duX3ByZXBlbmRlZF9tb2R1bGVzKHByZXBlbmRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBmdW5jdGlvbiBmbHVzaF9tZXRob2RzX2luKG1vZHVsZSkge1xuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgIGRlbGV0ZSBwcm90b1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBtb2R1bGUuJCRpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIC8vIER1bW15IGljbGFzcyBkb2Vzbid0IHJlY2VpdmUgdXBkYXRlcyB3aGVuIHRoZSBtb2R1bGUgZ2V0cyBhIG5ldyBtZXRob2QuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IHt9LFxuICAgICAgICBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkaWNsYXNzJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkbW9kdWxlJywgbW9kdWxlKTtcblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFpbl9pY2xhc3NlcyhpY2xhc3Nlcykge1xuICAgIHZhciBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGgsIGZpcnN0ID0gaWNsYXNzZXNbMF07XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0UHJvdG90eXBlKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzX3RvX2luamVjdCwga2xhc3NfcmVmZXJlbmNlO1xuXG4gICAga2xhc3NfdG9faW5qZWN0ID0ga2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdDtcbiAgICBrbGFzc19yZWZlcmVuY2UgPSBrbGFzcztcbiAgICB2YXIgb3JpZ2luYWxfcHJvdG90eXBlID0ga2xhc3MuJCRwcm90b3R5cGU7XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldFByb3RvdHlwZShuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG4gICAgZnVuY3Rpb24gbWV0aG9kX21pc3Npbmdfc3R1YigpIHtcbiAgICAgIC8vIENvcHkgYW55IGdpdmVuIGJsb2NrIG9udG8gdGhlIG1ldGhvZF9taXNzaW5nIGRpc3BhdGNoZXJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xuXG4gICAgICAvLyBTZXQgYmxvY2sgcHJvcGVydHkgdG8gbnVsbCByZWFkeSBmb3IgdGhlIG5leHQgY2FsbCAoc3RvcCBmYWxzZS1wb3NpdGl2ZXMpXG4gICAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkcCA9IG51bGw7XG5cbiAgICAgIC8vIGNhbGwgbWV0aG9kIG1pc3Npbmcgd2l0aCBjb3JyZWN0IGFyZ3MgKHJlbW92ZSAnJCcgcHJlZml4IG9uIG1ldGhvZCBuYW1lKVxuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgW21ldGhvZF9uYW1lLnNsaWNlKDEpXS5jb25jYXQoYXJnc19hcnkpKTtcbiAgICB9XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMoJyArIGFjdHVhbCArICcgZm9yICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgLy8gQXJpdHkgY291bnQgZXJyb3IgZGlzcGF0Y2hlciBmb3IgYmxvY2tzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBibG9ja1xuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gY29udGV4dCBbT2JqZWN0XSBjb250ZXh0IG9mIHRoZSBibG9jayBkZWZpbml0aW9uXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5ibG9ja19hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zcGVjdCA9IFwiYGJsb2NrIGluIFwiICsgY29udGV4dCArIFwiJ1wiO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoaW5zcGVjdCArICc6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcbiAgT3BhbC5maW5kX3N1cGVyX2Rpc3BhdGNoZXIgPSBmdW5jdGlvbihvYmosIG1pZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjaywgZGVmcykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW2pzaWRdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHN1cGVyX21ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRlZmNoZWNrICYmIHN1cGVyX21ldGhvZCA9PSBudWxsICYmIE9wYWwuS2VybmVsLiRtZXRob2RfbWlzc2luZyA9PT0gb2JqLiRtZXRob2RfbWlzc2luZykge1xuICAgICAgLy8gbWV0aG9kX21pc3NpbmcgaGFzbid0IGJlZW4gZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICB0aHJvdyBPcGFsLk5vTWV0aG9kRXJyb3IuJG5ldygnc3VwZXI6IG5vIHN1cGVyY2xhc3MgbWV0aG9kIGAnK21pZCtcIicgZm9yIFwiK29iaiwgbWlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpLCBsZW5ndGgsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBrbGFzcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLiBJZiBwcm92aWRlZCArYXJndW1lbnRzKyBsaXN0IGRvZXNuJ3QgaGF2ZSBhIEhhc2hcbiAgLy8gYXMgYSBsYXN0IGl0ZW0sIHJldHVybnMgYSBibGFuayBIYXNoLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGt3YXJncyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoa3dhcmdzICE9IG51bGwgJiYga3dhcmdzWyckcmVzcG9uZF90bz8nXSgndG9faGFzaCcsIHRydWUpKSB7XG4gICAgICAkc3BsaWNlLmNhbGwocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxLCAxKTtcbiAgICAgIHJldHVybiBrd2FyZ3MuJHRvX2hhc2goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5oYXNoMihbXSwge30pO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIGdldCBhIGxpc3Qgb2YgcmVzdCBrZXl3b3JkIGFyZ3VtZW50cy4gTWV0aG9kIHRha2VzIHRoZSBnaXZlblxuICAvLyBrZXl3b3JkIGFyZ3MsIGkuZS4gdGhlIGhhc2ggbGl0ZXJhbCBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjb250YWluaW5nIGFsbFxuICAvLyBrZXl3b3JkIGFyZ3VlbW50cyBwYXNzZWQgdG8gbWV0aG9kLCBhcyB3ZWxsIGFzIHRoZSB1c2VkIGFyZ3Mgd2hpY2ggYXJlXG4gIC8vIHRoZSBuYW1lcyBvZiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIGRlZmluZWQuIFRoaXMgbWV0aG9kIHRoZW5cbiAgLy8ganVzdCByZXR1cm5zIGFsbCBrZXkvdmFsdWUgcGFpcnMgd2hpY2ggaGF2ZSBub3QgYmVlbiB1c2VkLCBpbiBhIG5ld1xuICAvLyBoYXNoIGxpdGVyYWwuXG4gIC8vXG4gIC8vIEBwYXJhbSBnaXZlbl9hcmdzIFtIYXNoXSBhbGwga3dhcmdzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gdXNlZF9hcmdzIFtPYmplY3Q8U3RyaW5nOiB0cnVlPl0gYWxsIGtleXMgdXNlZCBhcyBuYW1lZCBrd2FyZ3NcbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5rd3Jlc3RhcmdzID0gZnVuY3Rpb24oZ2l2ZW5fYXJncywgdXNlZF9hcmdzKSB7XG4gICAgdmFyIGtleXMgICAgICA9IFtdLFxuICAgICAgICBtYXAgICAgICAgPSB7fSxcbiAgICAgICAga2V5ICAgICAgICAgICAsXG4gICAgICAgIGdpdmVuX21hcCA9IGdpdmVuX2FyZ3MuJCRzbWFwO1xuXG4gICAgZm9yIChrZXkgaW4gZ2l2ZW5fbWFwKSB7XG4gICAgICBpZiAoIXVzZWRfYXJnc1trZXldKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBtYXBba2V5XSA9IGdpdmVuX21hcFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmhhc2gyKGtleXMsIG1hcCk7XG4gIH07XG5cbiAgLy8gQ2FsbHMgcGFzc2VkIG1ldGhvZCBvbiBhIHJ1Ynkgb2JqZWN0IHdpdGggYXJndW1lbnRzIGFuZCBibG9jazpcbiAgLy9cbiAgLy8gQ2FuIHRha2UgYSBtZXRob2Qgb3IgYSBtZXRob2QgbmFtZS5cbiAgLy9cbiAgLy8gMS4gV2hlbiBtZXRob2QgbmFtZSBnZXRzIHBhc3NlZCBpdCBpbnZva2VzIGl0IGJ5IGl0cyBuYW1lXG4gIC8vICAgIGFuZCBjYWxscyAnbWV0aG9kX21pc3NpbmcnIHdoZW4gb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZC5cbiAgLy8gICAgVXNlZCBpbnRlcm5hbGx5IGJ5IE9wYWwgdG8gaW52b2tlIG1ldGhvZCB0aGF0IHRha2VzIGEgYmxvY2sgb3IgYSBzcGxhdC5cbiAgLy8gMi4gV2hlbiBtZXRob2QgKGkuZS4gbWV0aG9kIGJvZHkpIGdldHMgcGFzc2VkLCBpdCBkb2Vzbid0IHRyaWdnZXIgJ21ldGhvZF9taXNzaW5nJ1xuICAvLyAgICBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB0aGUgbmFtZSBvZiB0aGUgYWN0dWFsIG1ldGhvZC5cbiAgLy8gICAgVXNlZCBpbnRlcm5hbGx5IGJ5IE9wYWwgdG8gaW52b2tlICdzdXBlcicuXG4gIC8vXG4gIC8vIEBleGFtcGxlXG4gIC8vICAgdmFyIG15X2FycmF5ID0gWzEsIDIsIDMsIDRdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAnbGVuZ3RoJykgICAgICAgICAgICAgICAgICAgICMgPT4gNFxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXkuJGxlbmd0aCkgICAgICAgICAgICAjID0+IDRcbiAgLy9cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdyZXZlcnNlIScpICAgICAgICAgICAgICAgICAgIyA9PiBbNCwgMywgMiwgMV1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5WyckcmV2ZXJzZSEnXScpICAgICAgIyA9PiBbNCwgMywgMiwgMV1cbiAgLy9cbiAgLy8gQHBhcmFtIHJlY3YgW09iamVjdF0gcnVieSBvYmplY3RcbiAgLy8gQHBhcmFtIG1ldGhvZCBbRnVuY3Rpb24sIFN0cmluZ10gbWV0aG9kIGJvZHkgb3IgbmFtZSBvZiB0aGUgbWV0aG9kXG4gIC8vIEBwYXJhbSBhcmdzIFtBcnJheV0gYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gIC8vIEBwYXJhbSBibG9jayBbRnVuY3Rpb25dIHJ1YnkgYmxvY2tcbiAgLy8gQHJldHVybiBbT2JqZWN0XSByZXR1cm5pbmcgdmFsdWUgb2YgdGhlIG1ldGhvZCBjYWxsXG4gIE9wYWwuc2VuZCA9IGZ1bmN0aW9uKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICB2YXIgYm9keSA9ICh0eXBlb2YobWV0aG9kKSA9PT0gJ3N0cmluZycpID8gcmVjdlsnJCcrbWV0aG9kXSA6IG1ldGhvZDtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZWN2LiRtZXRob2RfbWlzc2luZy5hcHBseShyZWN2LCBbbWV0aG9kXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIE9wYWwubGFtYmRhID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gZGVmaW5lIG1ldGhvZHMgb24gYW4gb2JqZWN0LiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCwgdXNlZCBieSB0aGVcbiAgLy8gY29tcGlsZWQgc291cmNlIHRvIGRlZmluZSBtZXRob2RzIG9uIHNwZWNpYWwgY2FzZSBvYmplY3RzIHdoZW4gdGhlIGNvbXBpbGVyXG4gIC8vIGNhbiBub3QgZGV0ZXJtaW5lIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QsIG9yIHRoZSBvYmplY3QgaXMgYSBNb2R1bGVcbiAgLy8gaW5zdGFuY2UuIFRoaXMgY2FuIGdldCBjYWxsZWQgYnkgYE1vZHVsZSNkZWZpbmVfbWV0aG9kYCBhcyB3ZWxsLlxuICAvL1xuICAvLyAjIyBNb2R1bGVzXG4gIC8vXG4gIC8vIEFueSBtZXRob2QgZGVmaW5lZCBvbiBhIG1vZHVsZSB3aWxsIGNvbWUgdGhyb3VnaCB0aGlzIHJ1bnRpbWUgaGVscGVyLlxuICAvLyBUaGUgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBtb2R1bGUgYm9keSwgYW5kIHRoZSBvd25lciBvZiB0aGUgbWV0aG9kIGlzXG4gIC8vIHNldCB0byBiZSB0aGUgbW9kdWxlIGl0c2VsZi4gVGhpcyBpcyB1c2VkIGxhdGVyIHdoZW4gY2hvb3Npbmcgd2hpY2hcbiAgLy8gbWV0aG9kIHNob3VsZCBzaG93IG9uIGEgY2xhc3MgaWYgbW9yZSB0aGFuIDEgaW5jbHVkZWQgbW9kdWxlcyBkZWZpbmVcbiAgLy8gdGhlIHNhbWUgbWV0aG9kLiBGaW5hbGx5LCBpZiB0aGUgbW9kdWxlIGlzIGluIGBtb2R1bGVfZnVuY3Rpb25gIG1vZGUsXG4gIC8vIHRoZW4gdGhlIG1ldGhvZCBpcyBhbHNvIGRlZmluZWQgb250byB0aGUgbW9kdWxlIGl0c2VsZi5cbiAgLy9cbiAgLy8gIyMgQ2xhc3Nlc1xuICAvL1xuICAvLyBUaGlzIGhlbHBlciB3aWxsIG9ubHkgYmUgY2FsbGVkIGZvciBjbGFzc2VzIHdoZW4gYSBtZXRob2QgaXMgYmVpbmdcbiAgLy8gZGVmaW5lZCBpbmRpcmVjdGx5OyBlaXRoZXIgdGhyb3VnaCBgTW9kdWxlI2RlZmluZV9tZXRob2RgLCBvciBieSBhXG4gIC8vIGxpdGVyYWwgYGRlZmAgbWV0aG9kIGluc2lkZSBhbiBgaW5zdGFuY2VfZXZhbGAgb3IgYGNsYXNzX2V2YWxgIGJvZHkuIEluXG4gIC8vIGVpdGhlciBjYXNlLCB0aGUgbWV0aG9kIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgY2xhc3MnIHByb3RvdHlwZS4gQSBzcGVjaWFsXG4gIC8vIGV4Y2VwdGlvbiBleGlzdHMgZm9yIGBCYXNpY09iamVjdGAgYW5kIGBPYmplY3RgLiBUaGVzZSB0d28gY2xhc3NlcyBhcmVcbiAgLy8gc3BlY2lhbCBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgaW4gdG9sbC1mcmVlIGJyaWRnZWQgY2xhc3Nlcy4gSW4gZWFjaCBvZlxuICAvLyB0aGVzZSB0d28gY2FzZXMsIGV4dHJhIHdvcmsgaXMgcmVxdWlyZWQgdG8gZGVmaW5lIHRoZSBtZXRob2RzIG9uIHRvbGwtZnJlZVxuICAvLyBicmlkZ2VkIGNsYXNzJyBwcm90b3R5cGVzIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE9iamVjdHNcbiAgLy9cbiAgLy8gSWYgYSBzaW1wbGUgcnVieSBvYmplY3QgaXMgdGhlIG9iamVjdCwgdGhlbiB0aGUgbWV0aG9kIGlzIHNpbXBseSBqdXN0XG4gIC8vIGRlZmluZWQgb24gdGhlIG9iamVjdCBhcyBhIHNpbmdsZXRvbiBtZXRob2QuIFRoaXMgd291bGQgYmUgdGhlIGNhc2Ugd2hlblxuICAvLyBhIG1ldGhvZCBpcyBkZWZpbmVkIGluc2lkZSBhbiBgaW5zdGFuY2VfZXZhbGAgYmxvY2suXG4gIC8vXG4gIC8vIEBwYXJhbSBvYmogIFtPYmplY3QsIENsYXNzXSB0aGUgYWN0dWFsIG9iaiB0byBkZWZpbmUgbWV0aG9kIGZvclxuICAvLyBAcGFyYW0ganNpZCBbU3RyaW5nXSB0aGUgSmF2YVNjcmlwdCBmcmllbmRseSBtZXRob2QgbmFtZSAoZS5nLiAnJGZvbycpXG4gIC8vIEBwYXJhbSBib2R5IFtKUy5GdW5jdGlvbl0gdGhlIGxpdGVyYWwgSmF2YVNjcmlwdCBmdW5jdGlvbiB1c2VkIGFzIG1ldGhvZFxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBtZXRob2QgZGVmaW5pdGlvbiBpbiB0aGVcbiAgICAvLyB0b3AtbGV2ZWwgbmFtZXNwYWNlXG4gICAgaWYgKG9iaiA9PT0gT3BhbC50b3ApIHtcbiAgICAgIE9wYWwuZGVmbihPcGFsLk9iamVjdCwganNpZCwgYm9keSlcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgT3BhbC5kZWZuKG9iaiwganNpZCwgYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgT3BhbC5kZWZzKG9iaiwganNpZCwgYm9keSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERlZmluZSBtZXRob2Qgb24gYSBtb2R1bGUgb3IgY2xhc3MgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmbiA9IGZ1bmN0aW9uKG1vZHVsZSwganNpZCwgYm9keSkge1xuICAgIGJvZHkuZGlzcGxheU5hbWUgPSBqc2lkO1xuICAgIGJvZHkuJCRvd25lciA9IG1vZHVsZTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkZGVmaW5lUHJvcGVydHkocHJvdG8sIGpzaWQsIGJvZHkpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgaWYgKG1vZHVsZS4kJG1vZHVsZV9mdW5jdGlvbikge1xuICAgICAgICBPcGFsLmRlZnMobW9kdWxlLCBqc2lkLCBib2R5KVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWNsYXNzZXMgPSBtb2R1bGUuJCRpY2xhc3NlcywgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljbGFzcyA9IGljbGFzc2VzW2ldO1xuICAgICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCBqc2lkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2luZ2xldG9uX29mID0gbW9kdWxlLiQkc2luZ2xldG9uX29mO1xuICAgIGlmIChtb2R1bGUuJG1ldGhvZF9hZGRlZCAmJiAhbW9kdWxlLiRtZXRob2RfYWRkZWQuJCRzdHViICYmICFzaW5nbGV0b25fb2YpIHtcbiAgICAgIG1vZHVsZS4kbWV0aG9kX2FkZGVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIGEgc2luZ2xldG9uIG1ldGhvZCBvbiB0aGUgZ2l2ZW4gb2JqZWN0IChzZWUgT3BhbC5kZWYpLlxuICBPcGFsLmRlZnMgPSBmdW5jdGlvbihvYmosIGpzaWQsIGJvZHkpIHtcbiAgICBpZiAob2JqLiQkaXNfc3RyaW5nIHx8IG9iai4kJGlzX251bWJlcikge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcImNhbid0IGRlZmluZSBzaW5nbGV0b25cIik7XG4gICAgfVxuICAgIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSlcbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSAjcmVtb3ZlX21ldGhvZC5cbiAgT3BhbC5yZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCEkaGFzT3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHkgICA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdLFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdnJld3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG4gICAgYWxpYXMubGVuZ3RoICAgICAgICAgICAgPSBib2R5Lmxlbmd0aDtcbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgaGFzaC4kJGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgaGFzaC4kJHNtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDtcbiAgICBrZXlfaGFzaCA9IGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJ1Y2tldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9nZXQgPSBmdW5jdGlvbihoYXNoLCBrZXkpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoJGhhc093bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc093bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZGVsZXRlID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIGksIGtleXMgPSBoYXNoLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHZhbHVlO1xuXG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdLCBsYXN0X2J1Y2tldDtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIHZhbHVlID0gYnVja2V0LnZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBidWNrZXQpIHtcbiAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9yZWhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhc2guJCRrZXlzLmxlbmd0aCwga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoaGFzaC4kJGtleXNbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleV9oYXNoID0gaGFzaC4kJGtleXNbaV0ua2V5LiRoYXNoKCk7XG5cbiAgICAgIGlmIChrZXlfaGFzaCA9PT0gaGFzaC4kJGtleXNbaV0ua2V5X2hhc2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaGFzaC4kJGtleXNbaV0ua2V5X2hhc2ggPSBrZXlfaGFzaDtcblxuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gaGFzaC4kJGtleXNbaV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJndW1lbnRzX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MsIGhhc2gsIGksIGxlbmd0aCwga2V5LCB2YWx1ZTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcbiAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInZhbHVlIG5vdCBvZiBsZW5ndGggMjogXCIgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gYXJnc1tpXVswXTtcbiAgICAgICAgdmFsdWUgPSBhcmdzW2ldWzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICBpZiAoJGhhc093bi5jYWxsKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBpdmFyIG5hbWUgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgLy8gTW9zdGx5IGFkZHMgYSB0cmFpbGluZyAkIHRvIHJlc2VydmVkIG5hbWVzLlxuICAvL1xuICBPcGFsLml2YXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIG5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBuYW1lID09PSBcImRpc3BsYXlOYW1lXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX2NvdW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fbm9TdWNoTWV0aG9kX19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcGFyZW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBuYW1lID09PSBcImhhc093blByb3BlcnR5XCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJ2YWx1ZU9mXCJcbiAgICAgICApXG4gICAge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLiQkZ20gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJlcXVpcmUgc3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgT3BhbC5tb2R1bGVzICAgICAgICAgPSB7fTtcbiAgT3BhbC5sb2FkZWRfZmVhdHVyZXMgPSBbJ2NvcmVsaWIvcnVudGltZSddO1xuICBPcGFsLmN1cnJlbnRfZGlyICAgICA9ICcuJztcbiAgT3BhbC5yZXF1aXJlX3RhYmxlICAgPSB7J2NvcmVsaWIvcnVudGltZSc6IHRydWV9O1xuXG4gIE9wYWwubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBwYXJ0cywgcGFydCwgbmV3X3BhcnRzID0gW10sIFNFUEFSQVRPUiA9ICcvJztcblxuICAgIGlmIChPcGFsLmN1cnJlbnRfZGlyICE9PSAnLicpIHtcbiAgICAgIHBhdGggPSBPcGFsLmN1cnJlbnRfZGlyLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLlxcLy8sICcnKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC4ocmJ8b3BhbHxqcykkLywgJycpO1xuICAgIHBhcnRzID0gcGF0aC5zcGxpdChTRVBBUkFUT1IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSBjb250aW51ZTtcbiAgICAgIChwYXJ0ID09PSAnLi4nKSA/IG5ld19wYXJ0cy5wb3AoKSA6IG5ld19wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld19wYXJ0cy5qb2luKFNFUEFSQVRPUik7XG4gIH07XG5cbiAgT3BhbC5sb2FkZWQgPSBmdW5jdGlvbihwYXRocykge1xuICAgIHZhciBpLCBsLCBwYXRoO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGhzW2ldKTtcblxuICAgICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5sb2FkZWRfZmVhdHVyZXMucHVzaChwYXRoKTtcbiAgICAgIE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICBPcGFsLmxvYWRlZChbcGF0aF0pO1xuXG4gICAgdmFyIG1vZHVsZSA9IE9wYWwubW9kdWxlc1twYXRoXTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIG1vZHVsZShPcGFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2V2ZXJpdHkgPSBPcGFsLmNvbmZpZy5taXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk7XG4gICAgICB2YXIgbWVzc2FnZSAgPSAnY2Fubm90IGxvYWQgc3VjaCBmaWxlIC0tICcgKyBwYXRoO1xuXG4gICAgICBpZiAoc2V2ZXJpdHkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBpZiAoT3BhbC5Mb2FkRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkxvYWRFcnJvci4kbmV3KG1lc3NhZ2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbWVzc2FnZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZXZlcml0eSA9PT0gXCJ3YXJuaW5nXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBMb2FkRXJyb3I6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBPcGFsLnJlcXVpcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmxvYWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBJbml0aWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiAkQmFzaWNPYmplY3QoKSB7fVxuICBmdW5jdGlvbiAkT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE1vZHVsZSgpIHt9XG4gIGZ1bmN0aW9uICRDbGFzcygpIHt9XG5cbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsLCAkQmFzaWNPYmplY3QpO1xuICBPcGFsLk9iamVjdCAgICAgID0gX09iamVjdCAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0LCAkT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnTW9kdWxlJywgT3BhbC5PYmplY3QsICRNb2R1bGUpO1xuICBPcGFsLkNsYXNzICAgICAgID0gQ2xhc3MgICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlLCAkQ2xhc3MpO1xuXG4gICRzZXRQcm90b3R5cGUoT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRQcm90b3R5cGUoT3BhbC5PYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0UHJvdG90eXBlKE9wYWwuTW9kdWxlLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldFByb3RvdHlwZShPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAvLyBCYXNpY09iamVjdCBjYW4gcmVhY2ggaXRzZWxmLCBhdm9pZCBjb25zdF9zZXQgdG8gc2tpcCB0aGUgJCRiYXNlX21vZHVsZSBsb2dpY1xuICBCYXNpY09iamVjdC4kJGNvbnN0W1wiQmFzaWNPYmplY3RcIl0gPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcblxuICAvLyBGaXggYm9vdGVkIGNsYXNzZXMgdG8gaGF2ZSBjb3JyZWN0IC5jbGFzcyB2YWx1ZVxuICBCYXNpY09iamVjdC4kJGNsYXNzID0gQ2xhc3M7XG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcbiAgTW9kdWxlLiQkY2xhc3MgICAgICA9IENsYXNzO1xuICBDbGFzcy4kJGNsYXNzICAgICAgID0gQ2xhc3M7XG5cbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAvLyBAZXhhbXBsZVxuICAvLyAgIE9wYWwuJCQuUmVnZXhwLiQkLklHTk9SRUNBU0VcbiAgT3BhbC4kJCA9IF9PYmplY3QuJCQ7XG5cbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XG4gIE9wYWwudG9wID0gbmV3IF9PYmplY3QoKTtcbiAgT3BhbC50b3AuJHRvX3MgPSBPcGFsLnRvcC4kaW5zcGVjdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ21haW4nIH07XG5cblxuICAvLyBOaWxcbiAgZnVuY3Rpb24gJE5pbENsYXNzKCkge31cbiAgT3BhbC5OaWxDbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QsICROaWxDbGFzcyk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG5cbiAgLy8gRXJyb3JzXG4gIE9wYWwuYnJlYWtlciAgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsgKG9sZCknKTtcbiAgT3BhbC5yZXR1cm5lciA9IG5ldyBFcnJvcigndW5leHBlY3RlZCByZXR1cm4nKTtcbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNIO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QgPSBuaWwsIGNvZXJjZWQgPSBuaWwpXG4gICAgaWYgbWV0aG9kICYmIGNvZXJjZWRcbiAgICAgIFR5cGVFcnJvci5uZXcgXCJjYW4ndCBjb252ZXJ0ICN7b2JqZWN0LmNsYXNzfSBpbnRvICN7dHlwZX0gKCN7b2JqZWN0LmNsYXNzfSMje21ldGhvZH0gZ2l2ZXMgI3tjb2VyY2VkLmNsYXNzfSlcIlxuICAgIGVsc2VcbiAgICAgIFR5cGVFcnJvci5uZXcgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7b2JqZWN0LmNsYXNzfSBpbnRvICN7dHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIG9iamVjdCBpZiB0eXBlID09PSBvYmplY3RcblxuICAgIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICByYWlzZSB0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSlcbiAgICBlbmRcblxuICAgIG9iamVjdC5fX3NlbmRfXyBtZXRob2RcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZClcbiAgICBjb2VyY2VkID0gY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90bz8ob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnNwZWN0X29iaihvYmopXG4gICAgYE9wYWwuaW5zcGVjdChvYmopYFxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS51cGNhc2VcbiAgICAgIHJhaXNlIE5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIlxuICAgIGVuZFxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImJyaWRnZSIsInNlbGYiLCJ0eXBlX2Vycm9yIiwibWV0aG9kIiwiY29lcmNlZCIsIm5ldyIsIm9iamVjdCIsImNsYXNzIiwidHlwZSIsImNvZXJjZV90byIsIj09PSIsInJlc3BvbmRfdG8/IiwicmFpc2UiLCJfX3NlbmRfXyIsImNvZXJjZV90byEiLCJjb2VyY2VfdG8/IiwibmlsPyIsInRyeV9jb252ZXJ0IiwiY29tcGFyZSIsImEiLCI8PT4iLCJiIiwiZGVzdHJ1Y3R1cmUiLCJvYmoiLCJpbmNsdWRlX2FsbCIsImluc3BlY3Rfb2JqIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lISIsImNvbnN0X25hbWUiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5l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bkIsRUF5SkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXpKRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXlKaUMsTUFBQSwwQkF6SmpDO0FBQUE7QUEySkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQXBLQTtBQUFBLE1BcUtJLE9BQUEsR0FyS0o7QUF5SkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXZKQTtBQURGcEMsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tb2R1bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTW9kdWxlXG4gIGRlZiBzZWxmLmFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmlsLCBmdW5jdGlvbigpe30pO1xuICAgICAgLy8gTGluayB0aGUgcHJvdG90eXBlIG9mIE1vZHVsZSBzdWJjbGFzc2VzXG4gICAgICBpZiAoc2VsZiAhPT0gT3BhbC5Nb2R1bGUpIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2R1bGUsIHNlbGYuJCRwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBtb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICBlbmRcblxuICBkZWYgPT09KG9iamVjdClcbiAgICByZXR1cm4gZmFsc2UgaWYgYG9iamVjdCA9PSBudWxsYFxuXG4gICAgYE9wYWwuaXNfYShvYmplY3QsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgIyBjbGFzcyBjYW5ub3QgYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZlxuICAgICV4e1xuICAgICAgdmFyIHdvcmtpbmcgPSBzZWxmLFxuICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgIGlmICh3b3JraW5nID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmIDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgIG90aGVyIDwgc2VsZlxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmID4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmV0dXJuIG5pbFxuICAgIGVuZFxuXG4gICAgbHQgPSBzZWxmIDwgb3RoZXJcbiAgICByZXR1cm4gbmlsIGlmIGx0Lm5pbD9cbiAgICBsdCA/IC0xIDogMVxuICBlbmRcblxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgYWxpYXMgYXR0ciBhdHRyX2FjY2Vzc29yXG5cbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMDtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXR0cl93cml0ZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJyQnICsgbmFtZSArICc9JyxcbiAgICAgICAgICAgIGl2YXIgPSBPcGFsLml2YXIobmFtZSk7XG5cbiAgICAgICAgLy8gdGhlIGNsb3N1cmUgaGVyZSBpcyBuZWVkZWQgYmVjYXVzZSBuYW1lIHdpbGwgY2hhbmdlIGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIGN5Y2xlLCBJIHdpc2ggd2UgY291bGQgdXNlIGxldC5cbiAgICAgICAgdmFyIGJvZHkgPSAoZnVuY3Rpb24oaXZhcil7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbWydyZXEnXV07XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDE7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkKGNvbnN0LCBwYXRoKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCA9PSBudWxsKSBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcbiAgICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9ICN7cGF0aH07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlc1xuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZilbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNsYXNzIHZhcmlhYmxlICN7bmFtZX0gaW4gI3tzZWxmfVwiLCBuYW1lKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAoT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdChPcGFsLk9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCc6OicpID09PSAwICYmIG5hbWUgIT09ICc6Oicpe1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KCc6OicpLmluamVjdChzZWxmKSB7IHxvLCBjfCBvLmNvbnN0X2dldChjKSB9XG4gICAgZW5kXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiAkJChbc2VsZl0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X2xvY2FsKHNlbGYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBzZWxmLiQkYXV0b2xvYWRbbmFtZV07XG5cbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBzZWxmLiRyZXF1aXJlKGZpbGUpO1xuXG4gICAgICAgICAgcmV0dXJuICN7Y29uc3RfZ2V0IG5hbWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSBPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxuICBlbmRcblxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICBpZiBuYW1lICF+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGBPcGFsLmNvbnN0X3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgcHVibGljX2NvbnN0YW50KGNvbnN0X25hbWUpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIFByb2NcbiAgICAgICAgICAgICAgICBtZXRob2RcblxuICAgICAgICAgICAgICB3aGVuIE1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiBVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Jsb2NrLmNsYXNzfSAoZXhwZWN0ZWQgUHJvYy9NZXRob2QpXCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBpZCA9ICckJyArIG5hbWU7XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBibG9jayk7XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwucmRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaWYgKG1vZDIgPT09IG1vZCAmJiBtb2QyICE9PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgje09wYWwudHJ1dGh5PyhpbmNsdWRlX3N1cGVyKX0pIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZF9vYmplY3Qob2JqZWN0KVxuICBlbmRcblxuICBkZWYgbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIEtlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gT3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gS2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcbiAgTk9URTpJZiB5b3Ugd2FudCB0byBlbmFibGUgcGFzc2luZyBhIFN0cmluZyBhcmd1bWVudCBwbGVhc2UgYWRkIFxcXCJyZXF1aXJlICdvcGFsLXBhcnNlcidcXFwiIHRvIHlvdXIgc2NyaXB0XFxuXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xhc3NfZXZhbCBtb2R1bGVfZXZhbFxuXG4gIGRlZiBtb2R1bGVfZXhlYygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcblxuICBkZWYgbWV0aG9kX2RlZmluZWQ/KG1ldGhvZClcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBtZXRob2RdO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAnJCcgKyBtZXRoLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gT3BhbC5PYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7c2VsZi5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhzZWxmLCBwcmVwZW5kZXIpXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY29uc3QobmFtZSlcbiAgICBgT3BhbC5jb25zdF9yZW1vdmUoc2VsZiwgbmFtZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC51ZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIGNvbnN0cyA9IGNvbnN0YW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHN1cGVyXG4gICAgY29weS5jb3B5X2NsYXNzX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9jb25zdGFudHMoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xuICAgICAgICBzZWxmLiQkY3ZhcnNbbmFtZV0gPSBvdGhlci4kJGN2YXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIG5hbWUsIG90aGVyX2NvbnN0YW50cyA9IG90aGVyLiQkY29uc3Q7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvdGhlcl9jb25zdGFudHMpIHtcbiAgICAgICAgT3BhbC5jb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJhbGxvY2F0ZSIsInNlbGYiLCJpbml0aWFsaXplIiwiYmxvY2tfZ2l2ZW4/IiwibW9kdWxlX2V2YWwiLCJibG9jayIsIj09PSIsIjwiLCJvdGhlciIsInJhaXNlIiwiPD0iLCJlcXVhbD8iLCI+IiwiPj0iLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJhbGlhc19uYXRpdmUiLCJtaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJuYW1lcyIsImF0dHJfd3JpdGVyIiwiYXV0b2xvYWQiLCJjb25zdCQiLCJwYXRoIiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfc2V0IiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJyZW1vdmVfY2xhc3NfdmFyaWFibGUiLCJjb25zdGFudHMiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiY29uc3RfZ2V0IiwiaW5qZWN0Iiwic3BsaXQiLCJvIiwiYyIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCI9PSIsImNvbnN0X3NldCIsIiF+Iiwic3RhcnRfd2l0aD8iLCJ2YWx1ZSIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCJ0b19wcm9jIiwiYm91bmQiLCJiaW5kIiwiY2FsbCIsImFyZ3MiLCJyZW1vdmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzPyIsImluY2x1ZGUiLCJpbmNsdWRlZCIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsImluc3RhbmNlX21ldGhvZCIsImluc3RhbmNlX21ldGhvZHMiLCJ0cnV0aHk/IiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsIm1vZHVsZV9leGVjIiwibWV0aG9kX2RlZmluZWQ/IiwibW9kdWxlX2Z1bmN0aW9uIiwicHJlcGVuZCIsInByZXBlbmRfZmVhdHVyZXMiLCJwcmVwZW5kZWQiLCJyZW1vdmVfY29uc3QiLCJ0b19zIiwiX19pZF9fIiwiMTYiLCJ1bmRlZl9tZXRob2QiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJjb25zdHMiLCJkdXAiLCJjb3B5IiwiY29weV9jbGFzc192YXJpYWJsZXMiLCJjb3B5X2NvbnN0YW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsZUFBQUEscUJBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBO0FBQUE7QUFTQUUsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBWEY7QUFXaUIsTUFBQSwyQ0FYakI7QUFBQSxNQVlJLElB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LHdDQUFBQSxrQ0FBQUEsZ0NBQXlCLEtBQXpCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUxFQSxJQUFBQSxDQUFBQSw2Q0FBQUEsQ0E1b0JBO0FBQUEsSUFvcEJBLE9BQUFDLENBQUFBLGtDQUFBQSw0QkFBQUEsMEJBQW1CLEtBQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVBFQSxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEsMEJBcHBCQTtBQURGOUcsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL21vZHVsZSdcblxuY2xhc3MgQ2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgKHNpbmdsZXRvbl9vZi4kJGlzX2FfbW9kdWxlKSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsIm5ldyIsInNlbGYiLCJibG9ja19naXZlbj8iLCJjbGFzc19ldmFsIiwiYmxvY2siLCJhbGxvY2F0ZSIsImluaGVyaXRlZCIsImluaXRpYWxpemVfZHVwIiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3JpZ2luYWwiLCJzdXBlcmNsYXNzIiwidG9fcyIsIm5hbWUiLCIxNiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELFVBQUFBLGVBQUFBLFNBQWEsVUFBYkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBSkY7QUFJb0MsTUFBQSxtQ0FKcEM7QUFBQTtBQUllLE1BQUE7QUFBQSxNQUFBLGVBQWEsc0JBQWI7QUFBQSxNQUFBLENBSmY7QUFBQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBUSxhQUFBLElBQThCRSxlQUE5QjtBQUFBLFFBQUEsT0FBQUMsTUFBQSxDQUFDLEtBQUQsQ0FBQUEsY0FBQUEsRUFBQUEsRUFBQUEsRUFBb0JDLGdCQUFwQkQ7QUFBQSxNQUFBO0FBQUE7QUFBQSxNQUFBLENBQUE7QUFDUjtBQUNBLElBZEE7QUFJRUgsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUE7QUFBQTtBQWFBSyxJQUFBQSw0QkFBQUEsb0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUxFQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0FiQTtBQUFBO0FBcUJBQyxJQUFBQSw2QkFBQUEscUJBQUFBLHFCQUFjLEdBQWRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQXpCRixPQUFBO0FBeUJFQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FyQkE7QUFBQTtBQXdCQUMsSUFBQUEsa0NBQUFBLDBCQUFBQSwwQkFBbUIsUUFBbkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLFVBQUFDLGlCQUFBQSxDQUFnQkMsUUFBaEJELENBQUE7QUFBQTtBQUVKO0FBQ0E7QUFDQSxJQUpJO0FBREZELElBQUFBLENBQUFBLHFDQUFBQSxDQXhCQTtBQUFBO0FBZ0NBUCxJQUFBQSx1QkFBQUEsZUFBQUEsU0FwQ0YsRUFvQ0VBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXBDRjtBQW9DaUIsTUFBQSxtQ0FwQ2pCO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFvQ1UsTUFBQSxrQkFwQ1Y7QUFBQTtBQXNDQSx1QkFBcUJLLFVBQUFBLENBQUFBLENBQVM7QUFDOUI7QUFDQTtBQUNBLElBekNBO0FBb0NFTCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FoQ0E7QUFBQTtBQXdDQVUsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxtQkFBRDtBQURGQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F4Q0E7QUFBQSxJQTRDQSxPQUFBQyxDQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFFRjs7QUFFQTtBQUNBLGVBQWlCLEVBQUEsR0FBQSxVQUFBLEdBQUEsQ0FBVyxDQUFDLFlBQUQsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBWCxDQUFBLEdBQUEsR0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBaUIsRUFBQSxHQUFBLFlBQUEsR0FBQSxDQUFhLENBQUMsb0JBQUQsQ0FBQUEsTUFBQUEsQ0FBQUEsQ0FBYixDQUFBLEdBQUEsS0FBQSxHQUFBLENBQThDLENBQUMscUJBQUQsQ0FBQUQsTUFBQUEsQ0FBNkJFLEVBQTdCRixDQUE5QyxDQUFBLEdBQUEsSUFBbUY7QUFDcEc7QUFDQSxhQUFlLFVBQUEsRUFBQSw4REFBQSxFQUFBLEVBQUEsTUFBQSxDQUFRO0FBQ3ZCO0FBWkVBLElBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkE1Q0E7QUFERlosRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2MzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCYXNpY09iamVjdFxuICBkZWYgaW5pdGlhbGl6ZSgqKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuXG4gIGRlZiBfX2lkX19cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgICAgfVxuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xuICAgICAgcmV0dXJuIHNlbGYuJCRpZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBfX3NlbmRfXyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgZnVuYyA9IHNlbGZbJyQnICsgc3ltYm9sXVxuXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGZ1bmMuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kbWV0aG9kX21pc3NpbmcuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRtZXRob2RfbWlzc2luZy5hcHBseShzZWxmLCBbc3ltYm9sXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICFcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIT0ob3RoZXIpXG4gICAgIShzZWxmID09IG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gOjpPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWwoY29tcGlsZWQpO1xuICAgICAgICAgIH0pKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIG1lc3NhZ2UgPSBpZiBgc2VsZi4kaW5zcGVjdCAmJiAhc2VsZi4kaW5zcGVjdC4kJHN0dWJgXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9OiN7YHNlbGYuJCRjbGFzc2B9XCJcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkIG1ldGhvZCBgI3tzeW1ib2x9JyBmb3IgI3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbmRcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcobWVzc2FnZSwgc3ltYm9sKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5pdGlhbGl6ZSIsIj09IiwiZXFsPyIsInNlbGYiLCJvdGhlciIsIl9faWRfXyIsIl9fc2VuZF9fIiwiISIsIiE9IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwibmlsPyIsIjEiLCIzIiwiY292ZXI/IiwiYXJncyIsInNpemUiLCJyYWlzZSIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImFueT8iLCJpbnN0YW5jZV9leGVjIiwic2luZ2xldG9uX21ldGhvZF9hZGRlZCIsInNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCIsInNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkIiwibWV0aG9kX21pc3NpbmciLCJtZXNzYWdlIiwic3ltYm9sIiwiaW5zcGVjdCIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsOEJBQUFBLDRCQUFBQSxzQkFGRixFQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFGRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUFFRUEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBQUE7QUFBQTtBQUdBQyxJQUFBQSxzQkFBQUEsd0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxjQUFEO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQUhBO0FBQUE7QUFPQUMsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLElBQUFGLE9BQUFBLENBQVFHLEtBQVJIO0FBREZDLElBQUFBLENBQUFBLHFDQUFBQSxDQVBBO0FBQUEsSUFXQSxpQkFBTSxRQUFOLEVBQWEsSUFBYixDQVhBO0FBQUE7QUFhQUcsSUFBQUEsMEJBQUFBLHdCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEVBLElBQUFBLENBQUFBLG1DQUFBQSxDQWJBO0FBQUE7QUF1QkFDLElBQUFBLDRCQUFBQSwwQkFBQUEsb0JBQWEsTUFBRCxFQXpCZCxFQXlCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBekJGO0FBeUI4QixNQUFBLDhDQXpC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QUFBO0FBNkk2QixNQUFBLGtCQTdJN0I7QUFBQSxNQThJSUMsVUFBVSxhQUFBLElBQUEsUUFBSSxzQ0FBSixDQUFBO0FBQUEsUUFDRSxPQUFBLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCQyxNQUFyQixDQUFBLEdBQUEsUUFBQSxHQUFBLEtBQW9DQyxTQUFBQSxDQUFBQSxDQUFwQyxDQUFBLEdBQUEsR0FBQSxHQUFBLENBQWdELFlBQWhEO0FBREYsTUFBQTtBQUFBLFFBR0UsT0FBQSxFQUFBLEdBQUEsb0JBQUEsR0FBQSxDQUFxQkQsTUFBckIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFxQyxZQUFyQztBQUhGLE1BQUEsQ0FBQSxrQkE5SWQ7QUFBQSxNQW9KSSxPQUFBLElBQUEsSUFBQSxXQUFBbEIsT0FBQUEsQ0FBZSxJQUFBLElBQUEsa0JBQUFvQixLQUFBQSxDQUFvQkgsU0FBU0MsTUFBN0JFLENBQWZwQixDQXBKSjtBQTZJRWdCLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSwwQkEzSUE7QUFERmxDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBLZXJuZWxcbiAgZGVmIG1ldGhvZF9taXNzaW5nKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH1cIiwgc3ltYm9sLCBhcmdzKVxuICBlbmRcblxuICBkZWYgPX4ob2JqKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhfihvYmopXG4gICAgIShzZWxmID1+IG9iailcbiAgZW5kXG5cbiAgZGVmID09PShvdGhlcilcbiAgICBvYmplY3RfaWQgPT0gb3RoZXIub2JqZWN0X2lkIHx8IHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIC8vIHNldCBndWFyZCBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBzZWxmLiQkY29tcGFyYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciB4ID0gI3tzZWxmID09IG90aGVyfTtcblxuICAgICAgaWYgKHggJiYgeCAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYuY2xhc3N9J1wiLCBuYW1lKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje01ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGYuY2xhc3N9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGFsbCl9KSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25fbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGFsbCl9KSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gIGVuZFxuXG4gICMgT3BhbCBkb2VzIG5vdCBzdXBwb3J0ICNjYWxsZXIsIGJ1dCB3ZSBzdHViIGl0IGFzIGFuIGVtcHR5IGFycmF5IHRvIG5vdFxuICAjIGJyZWFrIGRlcGVuZGFudCBsaWJzXG4gIGRlZiBjYWxsZXIoKmFyZ3MpXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdGhlciksIGksIGlpLCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBpLCBuYW1lLCBuYW1lcywgbGVuZ3RoO1xuXG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2Nsb25lKG90aGVyKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICBFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIGBzZWxmID09PSBvdGhlcmBcbiAgZW5kXG5cbiAgZGVmIGV4aXQoc3RhdHVzID0gdHJ1ZSlcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG5cbiAgICB1bnRpbCAkX19hdF9leGl0X18uZW1wdHk/XG4gICAgICBibG9jayA9ICRfX2F0X2V4aXRfXy5wb3BcbiAgICAgIGJsb2NrLmNhbGxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHN0YXR1cy4kJGlzX2Jvb2xlYW4pIHtcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzID8gMCA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAje09wYWwuY29lcmNlX3RvKHN0YXR1cywgSW50ZWdlciwgOnRvX2ludCl9XG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIGBzaW5nbGV0b25gfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRfb2JqZWN0IHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgJXh7XG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MgJiYgIWtsYXNzLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwgbmFtZS5zdWJzdHIoMSkpYFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGl2YXIgPSBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldO1xuXG4gICAgICByZXR1cm4gaXZhciA9PSBudWxsID8gbmlsIDogaXZhcjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIga2V5ID0gT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKSxcbiAgICAgICAgICB2YWw7XG4gICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhbCA9IHNlbGZba2V5XTtcbiAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBOYW1lRXJyb3IsIFwiaW5zdGFuY2UgdmFyaWFibGUgI3tuYW1lfSBub3QgZGVmaW5lZFwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaXZhcjtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcpIHtcbiAgICAgICAgICBpZiAobmFtZS5zdWJzdHIoLTEpID09PSAnJCcpIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBpdmFyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEludGVnZXIodmFsdWUsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcblxuICAgICAgaWYgKCF2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgI3tyYWlzZSBGbG9hdERvbWFpbkVycm9yLCB2YWx1ZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/KDp0b19pbnQpfSkge1xuICAgICAgICAgIGkgPSAje3ZhbHVlLnRvX2ludH07XG4gICAgICAgICAgaWYgKGkgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgSW50ZWdlciwgOnRvX2kpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSBcIjBcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2UgPSAje09wYWwuY29lcmNlX3RvKGBiYXNlYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoYmFzZSA9PT0gMSB8fCBiYXNlIDwgMCB8fCBiYXNlID4gMzYpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pLywgZnVuY3Rpb24gKF8sIGhlYWQsIGZsYWcpIHtcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDEwKSB7XG4gICAgICAgICAgICBiYXNlID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxNikge1xuICAgICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH0pO1xuXG4gICAgICBiYXNlID0gKGJhc2UgPT09IDAgPyAxMCA6IGJhc2UpO1xuXG4gICAgICBiYXNlX2RpZ2l0cyA9ICcwLScgKyAoYmFzZSA8PSAxMCA/IGJhc2UgLSAxIDogJzlhLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGJhc2UgLSAxMSkpKTtcblxuICAgICAgaWYgKCEobmV3IFJlZ0V4cCgnXlxcXFxzKlsrLV0/WycgKyBiYXNlX2RpZ2l0cyArICddK1xcXFxzKiQnKSkudGVzdChzdHIpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XG5cbiAgICAgIGlmIChpc05hTihpKSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBGbG9hdFwifVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3IgaGV4IHN0cmluZ3Mgb25seTpcbiAgICAgICAgaWYgKC9eXFxzKlstK10/MFt4WF1bMC05YS1mQS1GXStcXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuICN7SW50ZWdlcihgc3RyYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXlxccypbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT9cXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEZsb2F0KCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgRmxvYXQsIDp0b19mKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgSGFzaChhcmcpXG4gICAgcmV0dXJuIHt9IGlmIGFyZy5uaWw/IHx8IGFyZyA9PSBbXVxuICAgIHJldHVybiBhcmcgaWYgSGFzaCA9PT0gYXJnXG4gICAgT3BhbC5jb2VyY2VfdG8hKGFyZywgSGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdjbGFzcyBvciBtb2R1bGUgcmVxdWlyZWQnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9wYWwuaXNfYShzZWxmLCBrbGFzcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaXRzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBsYW1iZGEoJmJsb2NrKVxuICAgIGBPcGFsLmxhbWJkYShibG9jaylgXG4gIGVuZFxuXG4gIGRlZiBsb2FkKGZpbGUpXG4gICAgZmlsZSA9IE9wYWwuY29lcmNlX3RvIShmaWxlLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgRmxvYXQ6OklORklOSVRZIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgdHJ1ZVxuICAgICAgYmVnaW5cbiAgICAgICAgeWllbGRcbiAgICAgIHJlc2N1ZSBTdG9wSXRlcmF0aW9uID0+IGVcbiAgICAgICAgcmV0dXJuIGUucmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGBibG9jay4kJGlzX2xhbWJkYSA9IGZhbHNlYFxuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBwdXRzKCpzdHJzKVxuICAgICRzdGRvdXQucHV0cygqc3RycylcbiAgZW5kXG5cbiAgZGVmIHAoKmFyZ3MpXG4gICAgYXJncy5lYWNoIHsgfG9ianwgJHN0ZG91dC5wdXRzIG9iai5pbnNwZWN0IH1cblxuICAgIGFyZ3MubGVuZ3RoIDw9IDEgPyBhcmdzWzBdIDogYXJnc1xuICBlbmRcblxuICBkZWYgcHJpbnQoKnN0cnMpXG4gICAgJHN0ZG91dC5wcmludCgqc3RycylcbiAgZW5kXG5cbiAgZGVmIHdhcm4oKnN0cnMpXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIF9iYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyBleGNlcHRpb259O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgI3tleGNlcHRpb24ucmVzcG9uZF90bz8oOmV4Y2VwdGlvbil9KSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tleGNlcHRpb24uaXNfYT8oRXhjZXB0aW9uKX0pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tSYW5kb206OkRFRkFVTFQucmFuZH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcbiAgICAgICAgICBtYXggPSBtYXguJHRvX2koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgUmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICByZXR1cm4gdHJ1ZSBpZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKVxuXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbmQgICAgICAgIF9fc2VuZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gc2Vjb25kcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIFJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICBPcGFsLmNvZXJjZV90bz8oc3RyLCBTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICBPcGFsLmNvZXJjZV90byEoc3RyLCBTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2goc3ltKVxuICAgIHlpZWxkXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLmFyZyBpZiBlLnN5bSA9PSBzeW1cbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3coKmFyZ3MpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLCBhcmdzXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgRmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgaW5jbHVkZSBLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1ldGhvZF9taXNzaW5nIiwicmFpc2UiLCJuZXciLCJzeW1ib2wiLCJpbnNwZWN0IiwiYXJncyIsIj1+IiwiIX4iLCJzZWxmIiwib2JqIiwiISIsIj09PSIsIm9iamVjdF9pZCIsIj09Iiwib3RoZXIiLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiY2xhc3MiLCJtZXRob2RzIiwidHJ1dGh5PyIsImFsbCIsInB1YmxpY19tZXRob2RzIiwiQXJyYXkiLCJjb2VyY2VfdG8/Iiwib2JqZWN0IiwiYXRfZXhpdCIsIiRfX2F0X2V4aXRfXyIsIjw8IiwiYmxvY2siLCJjYWxsZXIiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiZXF1YWw/IiwiZXhpdCIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJjb2VyY2VfdG8iLCJzdGF0dXMiLCJleHRlbmQiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJoYXNoIiwiX19pZF9fIiwidG9fcyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJJbnRlZ2VyIiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJiYXNlIiwiRmxvYXQiLCJIYXNoIiwiYXJnIiwibmlsPyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiZWFjaCIsIjw9IiwibGVuZ3RoIiwiMSIsIltdIiwiMCIsIndhcm4iLCIkVkVSQk9TRSIsIiRzdGRlcnIiLCIkISIsImV4Y2VwdGlvbiIsInN0cmluZyIsInJhbmQiLCJtYXgiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiaW5jbHVkZV9hbGwiLCJyZXF1aXJlIiwicmVxdWlyZV9yZWxhdGl2ZSIsInRyeV9jb252ZXJ0ISIsImV4cGFuZF9wYXRoIiwiam9pbiIsInJlcXVpcmVfdHJlZSIsInBhdGgiLCJzdGFydF93aXRoPyIsInNsZWVwIiwic2Vjb25kcyIsInNyYW5kIiwibmV3X3NlZWQiLCJzZWVkIiwiU3RyaW5nIiwic3RyIiwidGFwIiwidG9fcHJvYyIsIjE2IiwiY2F0Y2giLCJzeW0iLCJ0aHJvdyIsIm9wZW4iLCJ5aWVsZF9zZWxmIiwiaW5jbHVkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFDLElBQUFBLGtDQUFBQSwyQkFBQUEsMEJBQW1CLE1BQUQsRUFGcEIsRUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBRkY7QUFFb0MsTUFBQSwrQ0FGcEM7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUU2QixNQUFBLGtCQUY3QjtBQUFBLE1BR0ksV0FBQUMsT0FBQUEsQ0FBTSw2QkFBQUMsS0FBQUEsQ0FBa0IsRUFBQSxHQUFBLG9CQUFBLEdBQUEsQ0FBcUJDLE1BQXJCLENBQUEsR0FBQSxRQUFBLEdBQUEsS0FBb0NDLFNBQUFBLENBQUFBLENBQXBDLEdBQStDRCxRQUFRRSxJQUF6RUgsQ0FBTkQsQ0FISjtBQUVFRCxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQTtBQUFBO0FBSUFNLElBQUFBLHNCQUFBQSxzQkFBQUEsU0FBTyxHQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQUpBO0FBQUE7QUFRQUMsSUFBQUEsc0JBQUFBLHdCQUFBQSxTQUFPLEdBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUVDLElBQUFGLE9BQUFBLENBQVFHLEdBQVJILENBQUZJLE1BQUFBLENBQUFBO0FBREZILElBQUFBLENBQUFBLG1DQUFBQSxDQVJBO0FBQUE7QUFZQUksSUFBQUEsdUJBQUFBLHNCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsa0JBQUFDLFdBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWFDLEtBQUFGLFdBQUFBLENBQUFBLENB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QUEsRUFBQTs7QUFBQSxRQXdxQm1DLE9BQUFzRCxDQXhxQm5DLG1CQUFBLGtCQUFBLE1Bd3FCV3REO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFDQSxPQUFBLG9CQUFNbkMsSUFBTixDQUFBLENBREE7QUFERjRILElBQUFBLENBQUFBLG1DQUFBQSxDQXJxQkE7QUFERnJJLEVBQUFBLEdBQUFBLFdBQUFBLFdBQUE7QUFBQSxFQTRxQkEsT0FBQW1CO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxXQUFBbUgsU0FBQUEsQ0FBUSxzQkFBUkE7QUFERm5ILEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBNXFCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5MDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgIyBgdmFyIEtlcm5lbCRyYWlzZSA9ICN7S2VybmVsfS4kcmFpc2VgXG4gIGB2YXIgc3RhY2tfdHJhY2VfbGltaXRgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcbiAgZGVmIG1lc3NhZ2VcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9IGJhY2t0cmFjZS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyBTY3JpcHRFcnJvciAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTeW50YXhFcnJvciAgICAgICAgIDwgU2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgTG9hZEVycm9yICAgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgPCBTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIFN5c3RlbUV4aXQgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIE5vTWVtb3J5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNpZ25hbEV4Y2VwdGlvbiAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEludGVycnVwdCAgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNlY3VyaXR5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgU3RhbmRhcmRFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgRW5jb2RpbmdFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgWmVyb0RpdmlzaW9uRXJyb3IgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTmFtZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTm9NZXRob2RFcnJvciAgICAgICAgIDwgTmFtZUVycm9yOyBlbmRcbmNsYXNzIFJ1bnRpbWVFcnJvciAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZyb3plbkVycm9yICAgICAgICAgICA8IFJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyBMb2NhbEp1bXBFcnJvciAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBUeXBlRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBBcmd1bWVudEVycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBJbmRleEVycm9yICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTdG9wSXRlcmF0aW9uICAgICAgICAgPCBJbmRleEVycm9yOyBlbmRcbmNsYXNzIEtleUVycm9yICAgICAgICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgUmFuZ2VFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmxvYXREb21haW5FcnJvciAgICAgIDwgUmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyBJT0Vycm9yICAgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTeXN0ZW1DYWxsRXJyb3IgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbm1vZHVsZSBFcnJub1xuICBjbGFzcyBFSU5WQUwgICAgICAgICAgICAgIDwgU3lzdGVtQ2FsbEVycm9yXG4gICAgZGVmIHNlbGYubmV3KG5hbWUgPSBuaWwpXG4gICAgICBtZXNzYWdlID0gJ0ludmFsaWQgYXJndW1lbnQnXG4gICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuY2F1Z2h0VGhyb3dFcnJvciA8IEFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnN5bSwgOmFyZ1xuXG4gIGRlZiBpbml0aWFsaXplKGFyZ3MpXG4gICAgQHN5bSA9IGFyZ3NbMF1cbiAgICBAYXJnID0gYXJnc1sxXSBpZiBhcmdzLmxlbmd0aCA+IDFcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAc3ltLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOb01ldGhvZEVycm9yXG4gIGF0dHJfcmVhZGVyIDphcmdzXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxuICAgIHN1cGVyIG1lc3NhZ2UsIG5hbWVcbiAgICBAYXJncyA9IGFyZ3NcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgS2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxuICBlbmRcblxuICBkZWYga2V5XG4gICAgQGtleSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImluc3BlY3QiLCJhc19zdHIiLCJlbXB0eT8iLCJzZXRfYmFja3RyYWNlIiwicmFpc2UiLCJAbWVzc2FnZSIsIm1vZHVsZSIsIm5hbWUiLCIrIiwiYXR0cl9yZWFkZXIiLCJAc3ltIiwiW10iLCIwIiwiPiIsImxlbmd0aCIsIjEiLCJAYXJnIiwiQG5hbWUiLCJAYXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUVFLElBQUMscUJBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFK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LE9BQUFnQjtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VoQjtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBREZnQixFQUFBQSxHQUFBQSxXQUFBQSxXQS9NQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG5SVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG5SVUJZX1ZFUlNJT04gICAgICAgID0gJzIuNS43J1xuUlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjAuMydcblJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMC0wMi0wMSdcblJVQllfUEFUQ0hMRVZFTCAgICAgPSAwXG5SVUJZX1JFVklTSU9OICAgICAgID0gMFxuUlVCWV9DT1BZUklHSFQgICAgICA9ICdvcGFsIC0gQ29weXJpZ2h0IChDKSAyMDEzLTIwMjAgQWRhbSBCZXlub24gYW5kIHRoZSBPcGFsIGNvbnRyaWJ1dG9ycydcblJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3tSVUJZX0VOR0lORV9WRVJTSU9OfSAoI3tSVUJZX1JFTEVBU0VfREFURX0gcmV2aXNpb24gI3tSVUJZX1JFVklTSU9OfSlcIlxuIl0sIm5hbWVzIjpbIjAiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsRUFBQSw2Q0FBc0IsTUFBdEIsQ0FBQTtBQUFBLEVBQ0EsMkNBQXNCLE1BQXRCLENBREE7QUFBQSxFQUVBLDRDQUFzQixPQUF0QixDQUZBO0FBQUEsRUFHQSxtREFBc0IsT0FBdEIsQ0FIQTtBQUFBLEVBSUEsaURBQXNCLFlBQXRCLENBSkE7QUFBQSxFQUtBLCtDQUFzQkEsQ0FBdEIsQ0FMQTtBQUFBLEVBTUEsNkNBQXNCQSxDQUF0QixDQU5BO0FBQUEsRUFPQSw4Q0FBc0Isc0VBQXRCLENBUEE7QUFBQSxFQVFBLE9BQUEsZ0RBQXNCLEVBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBUSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDLGlDQUFoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLENBQThELDZCQUE5RCxDQUFBLEdBQUEsR0FBdEIsQ0FSQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsc0JBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQU5BO0FBQUEsRUFRQSxXQUFBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTQ0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsIiEiLCImIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsMEJBQTRCQyxJQUE3QjtBQUFBLElBRUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJBSkE7QUFERixJQUFBLDRCQUFTRCxJQUFULFlBRkE7QUFBQTtBQVVBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBVkE7QUFBQTtBQWNBQyxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFB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Q0EzRUo7QUFBQSxNQTRFSSxXQUFBd0IsVUFBQUEsQ0FBU1QsR0FBR1EsQ0FBWkMsQ0E1RUo7QUEwRUVMLElBQUFBLENBQUFBLHVDQUFBQSxDQXhFQTtBQUFBO0FBNkVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBRCxVQUFBQSxDQUFTVCxHQUFHUSxDQUFaQztBQURGQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3RUE7QUFBQSxJQWlGQSxPQUFBQyxDQUFBQSxzQ0FBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSw4QkFqRkE7QUFERjdCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXVGQSxPQUFBLG1DQUFNLEdBQU4sQ0F2RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NjA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9ib29sZWFuLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJvb2xlYW4gPCBgQm9vbGVhbmBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRtZXRhJywgI3tzZWxmfSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgIVxuICAgIGBzZWxmICE9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbCkgOiBmYWxzZWBcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gdHJ1ZSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID09PSBvdGhlci52YWx1ZU9mKClgXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIEJvb2xlYW5cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuVHJ1ZUNsYXNzICA9IEJvb2xlYW5cbkZhbHNlQ2xhc3MgPSBCb29sZWFuXG5cblRSVUUgID0gdHJ1ZVxuRkFMU0UgPSBmYWxzZVxuIl0sIm5hbWVzIjpbImNsYXNzIiwic2VsZiIsImFsbG9jYXRlIiwicmFpc2UiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQywyREFB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ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIENvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIEludGVnZXIsIEZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuICB9XG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIGlmIChzZWxmLiQkY29tcGFyYWJsZSkge1xuICAgICAgICBkZWxldGUgc2VsZi4kJGNvbXBhcmFibGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuICAgICAgYGZhaWxfY29tcGFyaXNvbihzZWxmLCBvdGhlcilgXG4gICAgZW5kXG5cbiAgICBgbm9ybWFsaXplKGNtcCkgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcbiAgICAgIGBmYWlsX2NvbXBhcmlzb24oc2VsZiwgb3RoZXIpYFxuICAgIGVuZFxuXG4gICAgYG5vcm1hbGl6ZShjbXApID49IDBgXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIHVubGVzcyBjbXAgPSAoc2VsZiA8PT4gb3RoZXIpXG4gICAgICBgZmFpbF9jb21wYXJpc29uKHNlbGYsIG90aGVyKWBcbiAgICBlbmRcblxuICAgIGBub3JtYWxpemUoY21wKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuICAgICAgYGZhaWxfY29tcGFyaXNvbihzZWxmLCBvdGhlcilgXG4gICAgZW5kXG5cbiAgICBgbm9ybWFsaXplKGNtcCkgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heClcbiAgICBjbXAgPSBtaW4gPD0+IG1heFxuXG4gICAgdW5sZXNzIGNtcFxuICAgICAgYGZhaWxfY29tcGFyaXNvbihtaW4sIG1heClgXG4gICAgZW5kXG5cbiAgICBpZiBgbm9ybWFsaXplKGNtcCkgPiAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gbWluIGlmIGBub3JtYWxpemUoI3tzZWxmIDw9PiBtaW59KSA8IDBgXG4gICAgcmV0dXJuIG1heCBpZiBgbm9ybWFsaXplKCN7c2VsZiA8PT4gbWF4fSkgPiAwYFxuICAgIHNlbGZcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI+IiwiMCIsIjwiLCJyYWlzZSIsImNsYXNzIiwiPT0iLCJlcXVhbD8iLCJvdGhlciIsImNtcCIsInNlbGYiLCI8PT4iLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFDRjtBQUNBOztBQUVBLFVBQVlDLE9BQUMsSUFBREEsRUFBU0MsQ0FBVEQsQ0FBVztBQUN2QixVQUFZRSxPQUFDLElBQURBLEVBQVNELENBQVRDLENBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFDUSxhQUFBLFFBQU0sR0FBTjtBQUFBLElBQ0EsSUFBSyxrQkFBTCxJQUFVLG1CQUFWLElBQWdCLG9CQUFoQixJQUF1QixzQ0FBdkIsSUFBZ0Msb0NBQWhDLEdBQ0UsT0FBQywyQkFBRCxDQURGO0FBREEsSUFBQSxNQUlFLE9BQUMsd0JBQUQsQ0FKRixDQUFBO0FBT1IsVUFBUUMsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQixDQUFDLEdBQUQsQ0FBQUMsT0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFzQyxVQUF0QyxDQUFBLEdBQUEsU0FBckJEO0FBQ1I7QUFDQSxFQXJCRTtBQUFBO0FBdUJBRSxJQUFBQSxz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UUFBZSxVQUFZTSxJQUFBQyxRQUFBQSxDQUFTSSxHQUFUSixDQUFhLEtBQXhDLENBQUE7QUFBQSxRQUFBLE9BQU9JLEdBQVAsQ0FWQTtBQUFBLE1BV0EsSUFBQSxRQUFlLFVBQVlMLElBQUFDLFFBQUFBLENBQVNLLEdBQVRMLENBQWEsS0FBeEMsQ0FBQTtBQUFBLFFBQUEsT0FBT0ssR0FBUCxDQVhBO0FBQUEsTUFZQSxPQUFBTixJQVpBO0FBREZPLElBQUFBLENBQUFBLGlDQUFBQSxDQWpGQTtBQURGakIsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1ODUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yZWdleHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUmVnZXhwRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcblxuY2xhc3MgUmVnZXhwIDwgYFJlZ0V4cGBcbiAgSUdOT1JFQ0FTRSA9IDFcbiAgRVhURU5ERUQgPSAyXG4gIE1VTFRJTElORSA9IDRcblxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19yZWdleHAnLCB0cnVlKWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICBhbGxvY2F0ZWQgPSBzdXBlclxuICAgICAgYCN7YWxsb2NhdGVkfS51bmluaXRpYWxpemVkID0gdHJ1ZWBcbiAgICAgIGFsbG9jYXRlZFxuICAgIGVuZFxuXG4gICAgZGVmIGVzY2FwZShzdHJpbmcpXG4gICAgICBgT3BhbC5lc2NhcGVfcmVnZXhwKHN0cmluZylgXG4gICAgZW5kXG5cbiAgICBkZWYgbGFzdF9tYXRjaChuID0gbmlsKVxuICAgICAgaWYgbi5uaWw/XG4gICAgICAgICR+XG4gICAgICBlbHNlXG4gICAgICAgICR+W25dXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHF1b3RlIGVzY2FwZVxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIEFycmF5IGludG8gU3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggc3BsYXQgaXNzdWVzIChyZWxhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzg1OClcbiAgICAgICAgaWYgKGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHF1b3RlZF92YWxpZGF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGApfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQuJCRpc19yZWdleHApIHtcbiAgICAgICAgICAgIGVhY2hfcGFydF9vcHRpb25zID0gI3tgcGFydGAub3B0aW9uc307XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucyAhPSBlYWNoX3BhcnRfb3B0aW9ucykge1xuICAgICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0FsbCBleHByZXNzaW9ucyBtdXN0IHVzZSB0aGUgc2FtZSBvcHRpb25zJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgnKCcrcGFydC5zb3VyY2UrJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgLnRvX3N0cil9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICMgVGFrZSBhZHZhbnRhZ2Ugb2YgbG9naWMgdGhhdCBjYW4gcGFyc2Ugb3B0aW9ucyBmcm9tIEpTIFJlZ2V4XG4gICAgICBuZXcoYHF1b3RlZF92YWxpZGF0ZWRgLmpvaW4oJ3wnKSwgYG9wdGlvbnNgKVxuICAgIGVuZFxuXG4gICAgZGVmIG5ldyhyZWdleHAsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKHJlZ2V4cC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdleHAgPSAje09wYWwuY29lcmNlX3RvIShyZWdleHAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIGlmIChyZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAxKSA9PT0gJ1xcXFwnICYmIHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDIpICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAje3JhaXNlIFJlZ2V4cEVycm9yLCBcInRvbyBzaG9ydCBlc2NhcGUgc2VxdWVuY2U6IC8je3JlZ2V4cH0vXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKE9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIFN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPX4oc3RyaW5nKVxuICAgIG1hdGNoKHN0cmluZykgJiYgJH4uYmVnaW4oMClcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCN7T3BhbC5jb2VyY2VfdG8oc3RyaW5nLCBTdHJpbmcsIDp0b19zdHIpfSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICN7T3BhbC5jb2VyY2VfdG8ocG9zLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICN7T3BhbC5jb2VyY2VfdG8oc3RyaW5nLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZC5pbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoI3tPcGFsLmNvZXJjZV90byhzdHJpbmcsIFN0cmluZywgOnRvX3N0cil9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gI3tPcGFsLmNvZXJjZV90byhwb3MsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gI3tPcGFsLmNvZXJjZV90byhzdHJpbmcsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBzZWxmID1+ICRfXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VcbiAgICBgc2VsZi5zb3VyY2VgXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3VwcylcbiAgICAkfiAgICAgICAgICA9IHNlbGZcbiAgICBAcmVnZXhwICAgICA9IHJlZ2V4cFxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcbiAgICBAc3RyaW5nICAgICA9IGBtYXRjaF9ncm91cHMuaW5wdXRgXG4gICAgQHByZV9tYXRjaCAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKDAsIG1hdGNoX2dyb3Vwcy5pbmRleClgXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxuICAgIEBtYXRjaGVzICAgID0gW11cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1hdGNoX2dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXRjaF9ncm91cHNbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKG5pbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICBAbWF0Y2hlc1sqYXJnc11cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9ICN7QG1hdGNoZXN9Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuaWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJjb2VyY2VfdG8hIiwicmVnZXhwIiwiISIsInNlbGYiLCI9PSIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsInN0cmluZyIsIj1+IiwiYmVnaW4iLCIwIiwiaW5zcGVjdCIsImNvZXJjZV90byIsInBvcyIsIm1hdGNoPyIsIn4iLCIkXyIsInNvdXJjZSIsImNhc2Vmb2xkPyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJhcmdzIiwib2Zmc2V0Iiwib3RoZXIiLCJlbmQiLCJjYXB0dXJlcyIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQW9CLDZCQUFwQkEsV0FBQTtBQUFBLEVBRUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLDBDQUFhQyxDQUFiLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHlDQUFZQyxDQUFaLENBRkE7QUFBQSxJQUlDLDBEQUpEO0FBQUEsSUFNQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFlBQVksVUFBQSxFQUFBLGdFQUFBLFFBQUEsT0FBQSxDQUFaO0FBQUEsUUFDR0EsU0FBVSxxQkFEYjtBQUFBLFFBRUEsT0FBQUEsU0FGQTtBQURGRCxNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBO0FBTUFFLE1BQUFBLDBCQUFBQSxZQUFBQSxrQkFBVyxNQUFYQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLDBCQUFEO0FBREZB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QSxPQUFBQyxDQUFBQSw2QkFBQUEsMEJBQUFBLHFCQXZYRixFQXVYRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdlhGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBdVhnQixNQUFBLGtCQXZYaEI7QUFBQTtBQXlYQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWdCLENBQUMsT0FBRCxDQUFBRixNQUFBQSxDQUFBQSxDQUFlO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxnQkFBa0Isb0JBQUFsQyxlQUFBQSxDQUFpQixTQUFVLHlCQUFTLFFBQXBDQSxDQUE2Qzs7QUFFL0Q7QUFDQSxtQkFBcUIyQixZQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQXNCQSxZQUFTO0FBQy9COztBQUVBO0FBQ0EsSUFqWkE7QUF1WEVTLElBQUFBLENBQUFBLHNDQUFBQSxDQUFBQSxxQkFsR0E7QUFERnRELEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBblJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NjM2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RyaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuXG5jbGFzcyBTdHJpbmcgPCBgU3RyaW5nYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xuXG4gICAgT3BhbC5kZWZpbmVQcm9wZXJ0eSgje3NlbGZ9LiQkcHJvdG90eXBlLCAnJCRjYXN0JywgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIga2xhc3MgPSB0aGlzLiQkY2xhc3M7XG4gICAgICBpZiAoa2xhc3MuJCRjb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IGtsYXNzLiQkY29uc3RydWN0b3Ioc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICBPcGFsLmNvZXJjZV90bz8od2hhdCwgU3RyaW5nLCA6dG9fc3RyKVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXcoc3RyID0gJycpXG4gICAgc3RyID0gT3BhbC5jb2VyY2VfdG8oc3RyLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc3RyID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnTXV0YWJsZSBzdHJpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGluIE9wYWwuJ1xuICBlbmRcblxuICBkZWYgJShkYXRhKVxuICAgIGlmIEFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAje09wYWwuY29lcmNlX3RvKGBjb3VudGAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcmd1bWVudCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QoJycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICAvLyBBbGwgY3JlZGl0IGZvciB0aGUgYml0LXR3aWRkbGluZyBtYWdpYyBjb2RlIGJlbG93IGdvZXMgdG8gTW96aWxsYVxuICAgICAgLy8gcG9seWZpbGwgaW1wbGVtZW50YXRpb24gb2YgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoKSBwb3N0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuICAgICAgaWYgKHN0cmluZy5sZW5ndGggKiBjb3VudCA+PSAxIDw8IDI4KSB7XG4gICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ211bHRpcGx5IGNvdW50IG11c3Qgbm90IG92ZXJmbG93IG1heGltdW0gc3RyaW5nIHNpemUnfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPj4+PSAxO1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8gb3RoZXIsIFN0cmluZywgOnRvX3N0clxuXG4gICAgYHNlbGYgKyAje290aGVyLnRvX3N9YFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fc3RyLnRvX3NcblxuICAgICAgYHNlbGYgPiBvdGhlciA/IDEgOiAoc2VsZiA8IG90aGVyID8gLTEgOiAwKWBcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgdmFyIGNtcCA9ICN7b3RoZXIgPD0+IHNlbGZ9O1xuXG4gICAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNtcCA+IDAgPyAtMSA6IChjbXAgPCAwID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgb3RoZXJgLCA6dG9fc3RyfSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgbGVuZ3RoICA9ICN7T3BhbC5jb2VyY2VfdG8oYGluZGV4LmVuZGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaW5kZXggICA9ICN7T3BhbC5jb2VyY2VfdG8oYGluZGV4LmJlZ2luYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpbmRleCkgIT09IC0xID8gc2VsZi4kJGNhc3QoaW5kZXgpIDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byhgbGVuZ3RoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAje09wYWwuY29lcmNlX3RvKGBpbmRleGAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIDEpKTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byhgbGVuZ3RoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgYnl0ZXNsaWNlIFtdXG5cbiAgZGVmIGJcbiAgICBmb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8ob3RoZXIsIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgICV4e1xuICAgICAgdmFyIGFzY2lpX29ubHkgPSAvXltcXHgwMC1cXHg3Rl0qJC87XG4gICAgICBpZiAoYXNjaWlfb25seS50ZXN0KHNlbGYpICYmIGFzY2lpX29ubHkudGVzdChvdGhlcikpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgb3RoZXIgPSBvdGhlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmIDw9PiBvdGhlclxuICBlbmRcblxuICBkZWYgY2FzZWNtcD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgY21wID0gI3tjYXNlY21wKG90aGVyKX07XG4gICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbXAgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VudGVyKHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gT3BhbC5jb2VyY2VfdG8od2lkdGgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcGFkc3RyID0gT3BhbC5jb2VyY2VfdG8ocGFkc3RyLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGNob21wKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIHNlcGFyYXRvciA9IE9wYWwuY29lcmNlX3RvIShzZXBhcmF0b3IsIFN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvXFxyP1xcbj8kLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmLmxlbmd0aCA+PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YWlsID0gc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoLCBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGFpbCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hvcFxuICAgICV4e1xuICAgICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCByZXN1bHQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gXCJcXG5cIiAmJiBzZWxmLmNoYXJBdChsZW5ndGggLSAyKSA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHJcbiAgICBgc2VsZi5jaGFyQXQoMClgXG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgIGNvcHkgPSBgc2VsZi5zbGljZSgpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgc2VsZi5zbGljZSgpYFxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3VudCgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfcHJlZml4KHByZWZpeClcbiAgICAleHtcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cHJlZml4ID0gT3BhbC5jb2VyY2VfdG8ocHJlZml4LCBTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZSgwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9zdWZmaXgoc3VmZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tzdWZmaXggPSBPcGFsLmNvZXJjZV90byhzdWZmaXgsIFN0cmluZywgOnRvX3N0cil9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9Mb3dlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jaGFyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9saW5lKHNlcGFyYXRvciA9ICQvLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUsIHNlcGFyYXRvciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IG5pbCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZik7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHNlcGFyYXRvciA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlcGFyYXRvcmAsIFN0cmluZywgOnRvX3N0cil9XG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZDtcblxuICAgICAgaWYgKHNlcGFyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChhID0gc2VsZi5zcGxpdCgvKFxcbnsyLH0pLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gKGFbaV0gfHwgXCJcIikgKyAoYVtpICsgMV0gfHwgXCJcIik7XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3QodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgY2hvbXBlZCAgPSAje2Nob21wKHNlcGFyYXRvcil9O1xuICAgICAgdHJhaWxpbmcgPSBzZWxmLmxlbmd0aCAhPSBjaG9tcGVkLmxlbmd0aDtcbiAgICAgIHNwbGl0dGVkID0gY2hvbXBlZC5zcGxpdChzZXBhcmF0b3IpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzcGxpdHRlZC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEgfHwgdHJhaWxpbmcpIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0gKyBzZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICN7T3BhbC5jb2VyY2VfdG8oYHN1ZmZpeGVzW2ldYCwgU3RyaW5nLCA6dG9fc3RyKS50b19zfTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAje09wYWwuY29lcmNlX3RvKGBwYXR0ZXJuYCwgU3RyaW5nLCA6dG9fc3RyKX07XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SW5kZXg7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJlc3VsdCArPSBzZWxmLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IGJsb2NrKG1hdGNoWzBdKTtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDsgLy8gc2F2ZSBhbmQgcmVzdG9yZSBsYXN0SW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFyZXBsYWNlbWVudC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAje09wYWwuY29lcmNlX3RvKGByZXBsYWNlbWVudGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChfcmVwbGFjZW1lbnQgKyBzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCArIDEpKVxuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgaGV4XG4gICAgdG9faSAxNlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7b3RoZXIgPSBPcGFsLmNvZXJjZV90byhvdGhlciwgU3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAje09wYWwuY29lcmNlX3RvKGBvZmZzZXRgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHJlZ2V4ID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICN7JH4gPSBuaWx9O1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX1cbiAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAje09wYWwuY29lcmNlX3RvKGBzZWFyY2hgLCBTdHJpbmcsIDp0b19zdHIpfTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxcdTAwN0YtXFx1MDA5RlxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICdcXHUwMDA3JzogJ1xcXFxhJyxcbiAgICAgICAgICAgICdcXHUwMDFiJzogJ1xcXFxlJyxcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXNjYXBlZCA9IHNlbGYucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhW2Nocl0gfHwgJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpO1xuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1xcI1tcXCRcXEBcXHtdL2csICdcXFxcJCYnKSArICdcIic7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJuXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCAmYmxvY2spXG4gICAgZSA9IGVhY2hfbGluZShzZXBhcmF0b3IsICZibG9jaylcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gT3BhbC5jb2VyY2VfdG8od2lkdGgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcGFkc3RyID0gT3BhbC5jb2VyY2VfdG8ocGFkc3RyLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCAgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuXG4gICAgICB3aWR0aCAtPSBzZWxmLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCB3aWR0aCkge1xuICAgICAgICByZXN1bHQgKz0gcGFkc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZiArIHJlc3VsdC5zbGljZSgwLCB3aWR0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgIyBOT1RFOiBFbmNvZGluZzo6VVRGXzE2TEUgaXMgYWxzbyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyxcbiAgICAjIGJ1dCBzaW5jZSB0aGUgZGVmYXVsdCBlbmNvZGluZyBpbiBKYXZhU2NyaXB0IGlzIFVURl8xNkxFLFxuICAgICMgd2UgY2Fubm90IHJldHVybiBmYWxzZSBvdGhlcndpc2UgdGhlIGZvbGxvd2luZyB3aWxsIChpbmNvcnJlY3RseSkgcmV0dXJuIGZhbHNlOiBcImhlbGxvXCIuYXNjaWlfb25seT9cbiAgICAjIEluIG90aGVyIHdvcmRzLCB3ZSBjYW5ub3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuICAgICMgLSBcImhlbGxvXCIuZm9yY2VfZW5jb2RpbmcoXCJVVEYtMTZMRVwiKVxuICAgICMgLSBcImhlbGxvXCJcbiAgICAjIFRoZSBwcm9ibGVtIGlzIHRoYXQgXCJhc2NpaV9vbmx5XCIgc2hvdWxkIHJldHVybiBmYWxzZSBpbiB0aGUgZmlyc3QgY2FzZSBhbmQgdHJ1ZSBpbiB0aGUgc2Vjb25kIGNhc2UuXG4gICAgaWYgZW5jb2RpbmcgPT0gRW5jb2Rpbmc6OlVURl8xNkJFXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBlbmRcbiAgICBgL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBgc2VsZi5jaGFyQ29kZUF0KDApYFxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlcGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBpID0gc2VsZi5pbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW3NlbGYsICcnLCAnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKWBcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gI3tPcGFsLmNvZXJjZV90byhgb2Zmc2V0YCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwgfHwgX20uaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlYXJjaGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBPcGFsLmNvZXJjZV90byh3aWR0aCwgSW50ZWdlciwgOnRvX2ludClcbiAgICBwYWRzdHIgPSBPcGFsLmNvZXJjZV90byhwYWRzdHIsIFN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGNoYXJzICAgICA9IE1hdGguZmxvb3Iod2lkdGggLSBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgcGF0dGVybnMgID0gTWF0aC5mbG9vcihjaGFycyAvIHBhZHN0ci5sZW5ndGgpLFxuICAgICAgICAgIHJlc3VsdCAgICA9IEFycmF5KHBhdHRlcm5zICsgMSkuam9pbihwYWRzdHIpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IGNoYXJzIC0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCArIHBhZHN0ci5zbGljZSgwLCByZW1haW5pbmcpICsgc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlcCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAje09wYWwuY29lcmNlX3RvKGBzZXBgLCBTdHJpbmcsIDp0b19zdHIpfTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gI3tPcGFsLmNvZXJjZV90byhgcGF0dGVybmAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IHJlc3VsdC5wdXNoKG1hdGNoWzBdKSA6IHJlc3VsdC5wdXNoKCN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyBibG9jayhtYXRjaFswXSkgOiBibG9jay5jYWxsKHNlbGYsICN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAje09wYWwuY29lcmNlX3RvKHBhdHRlcm4sIFN0cmluZywgOnRvX3N0cikudG9fc307XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnICcpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gL1xccysvZ207XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL15cXHMrLywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiByZXN1bHRbMF0gPT09IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW3NlbGYuJCRjYXN0KHJlc3VsdFswXSldO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKGkgPSByZXN1bHQuaW5kZXhPZih1bmRlZmluZWQpKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FzdFJlc3VsdCgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuJCRjYXN0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5sZW5ndGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG5cbiAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJyAmJiBwYXR0ZXJuLnNvdXJjZS5pbmRleE9mKCcoPz0nKSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG1hdGNoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICBpZiAoaSArIDEgPT09IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgc3RyaW5nLnNsaWNlKGluZGV4KSk7XG4gICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZSgvKC4pXFwxKy9nLCAnJDEnKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBjaGFyX2NsYXNzICsgJylcXFxcMSsnLCAnZycpLCAnJDEnKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSAje09wYWwuY29lcmNlX3RvKGBwcmVmaXhlc1tpXWAsIFN0cmluZywgOnRvX3N0cikudG9fc307XG5cbiAgICAgICAgaWYgKHNlbGYuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gI3tPcGFsLmNvZXJjZV90byhgcGF0dGVybmAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0LCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgIHJlc3VsdCA9IHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAyKSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgYmxvY2sobWF0Y2hbMF0pICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gI3tPcGFsLmNvZXJjZV90byhgcmVwbGFjZW1lbnRgLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gI3tPcGFsLmNvZXJjZV90byhgbmAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICYgKE1hdGgucG93KDIsIG4pIC0gMSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3dhcGNhc2VcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnJlcGxhY2UoLyhbYS16XSspfChbQS1aXSspL2csIGZ1bmN0aW9uKCQwLCQxLCQyKSB7XG4gICAgICAgIHJldHVybiAkMSA/ICQwLnRvVXBwZXJDYXNlKCkgOiAkMC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxmLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c2VsZi5jbGFzcy5uZXcgYHN0cmB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGbG9hdChzZWxmLnJlcGxhY2UoL18vZywgJycpKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkgfHwgcmVzdWx0ID09IEluZmluaXR5IHx8IHJlc3VsdCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19pKGJhc2UgPSAxMClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJhZGl4ID0gI3tPcGFsLmNvZXJjZV90byhgYmFzZWAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKHJhZGl4ID09PSAxIHx8IHJhZGl4IDwgMCB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC8sIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcgJiYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDIpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSA4KSB7XG4gICAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxMCkge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSB7XG4gICAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBtZXRob2RfbmFtZSA9ICckJyArIGBzZWxmLnZhbHVlT2YoKWBcblxuICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdi4kbWV0aG9kX21pc3NpbmcuYXBwbHkocmVjdiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBib2R5LmNhbGwocmVjdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyB0b19zdHIgdG9fc1xuXG4gIGFsaWFzIHRvX3N5bSBpbnRlcm5cblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgZnJvbSA9IE9wYWwuY29lcmNlX3RvKGZyb20sIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgIHRvID0gT3BhbC5jb2VyY2VfdG8odG8sIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgICV4e1xuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF90byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF90by5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF07XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViID09IG51bGwgPyBnbG9iYWxfc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiAhPSBudWxsID8gc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJfcyhmcm9tLCB0bylcbiAgICBmcm9tID0gT3BhbC5jb2VyY2VfdG8oZnJvbSwgU3RyaW5nLCA6dG9fc3RyKS50b19zXG4gICAgdG8gPSBPcGFsLmNvZXJjZV90byh0bywgU3RyaW5nLCA6dG9fc3RyKS50b19zXG4gICAgJXh7XG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9VcHBlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgc3RvcCA9IE9wYWwuY29lcmNlX3RvKHN0b3AsIFN0cmluZywgOnRvX3N0cilcbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgY2hhcl9jb2RlX2Zyb21gfS0je2BjaGFyX2NvZGVfdXB0b2B9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNoYXJfY29kZSA9IGNoYXJfY29kZV9mcm9tICsgMTsgY2hhcl9jb2RlIDwgY2hhcl9jb2RlX3VwdG8gKyAxOyBjaGFyX2NvZGUrKykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyX2NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IChjdXJyX2NoYXIgPT09ICdcXFxcJyk7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3Vycl9jaGFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICAgICAgICBpZiAoc2V0QS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2V0QjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXRBLmxlbmd0aCxcbiAgICAgICAgICAgIGNocjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gc2V0QS5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKHNldEIuaW5kZXhPZihjaHIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGxlbiwgc2V0LCBuZWcsIGNociwgdG1wLFxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSAnJyxcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2V0ID0gI3tPcGFsLmNvZXJjZV90byhgc2V0c1tpXWAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3tSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3tSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IHVuZGVmaW5lZClcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemVkPyhmb3JtID0gdW5kZWZpbmVkKVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5lbmRcblxuU3ltYm9sID0gU3RyaW5nXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsInNlbGYiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsImNvZXJjZV90bz8iLCJ3aGF0IiwibmV3Iiwic3RyIiwiY29lcmNlX3RvIiwiaW5pdGlhbGl6ZSIsInJhaXNlIiwiJSIsIj09PSIsImRhdGEiLCJmb3JtYXQiLCIqIiwiKyIsIm90aGVyIiwidG9fcyIsIjw9PiIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwiPT0iLCI9fiIsIltdIiwiJH4iLCJiIiwiZm9yY2VfZW5jb2RpbmciLCJjYXBpdGFsaXplIiwiY2FzZWNtcCIsImNhc2VjbXA/IiwiY2VudGVyIiwid2lkdGgiLCJwYWRzdHIiLCJlbXB0eT8iLCJsanVzdCIsIi8iLCIyIiwiY2VpbCIsInJqdXN0IiwiZmxvb3IiLCJjaGFycyIsImJsb2NrIiwiZWFjaF9jaGFyIiwidG9fYSIsImNob21wIiwiJC8iLCJzZXBhcmF0b3IiLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3VudCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJwcmVmaXgiLCJkZWxldGVfc3VmZml4Iiwic3VmZml4IiwiZG93bmNhc2UiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInNpemUiLCJlYWNoX2xpbmUiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsImluZGV4IiwiaW5zcGVjdCIsImludGVybiIsImxpbmVzIiwiZSIsImxlbmd0aCIsImxzdHJpcCIsImFzY2lpX29ubHk/IiwiZW5jb2RpbmciLCJtYXRjaCIsInBvcyIsIm1hdGNoPyIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwic3dhcGNhc2UiLCJ0b19mIiwiMTAiLCJ0b19wcm9jIiwibWV0aG9kX25hbWUiLCJwcm9jIiwidHIiLCJmcm9tIiwidG8iLCJ0cl9zIiwidXBjYXNlIiwidXB0byIsInN0b3AiLCJleGNsIiwic3VjYyIsImVzY2FwZSIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIl9sb2FkIiwiYXJncyIsInVuaWNvZGVfbm9ybWFsaXplIiwidW5pY29kZV9ub3JtYWxpemVkPyIsInVucGFjayIsInVucGFjazEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQURBO0FBQUEsRUFHQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQTtBQUdGLHdCQUEwQkMsSUFBSzs7QUFFL0Isd0JBQTBCQSxJQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFiRTtBQUFBO0FBZUFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsZUFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FmQTtBQUFBLElBbUJBLGlCQUFNLFdBQU4sRUFBZ0IsUUFBaEIsQ0FuQkE7QUFBQSxJQXFCQUMsVUFBSUYsSUFBSkUsa0JBQUFBLHdCQUFBQSx1QkFBcUIsSUFBckJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsb0JBQUFDLGVBQUFBLENBQWdCQyxNQUFNLHdCQUFRLFFBQTlCRDtBQURGRCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FyQkE7QUFBQSxJQXlCQUcsVUFB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TkE7QUFERnNILElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxtQkF0eURBO0FBREZqSSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixNQUFoQkEsV0FIQTtBQUFBLEVBK3lEQSxPQUFBLHNDQUFTLHNCQUFULENBL3lEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjg0OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2xpY2Vfd2hlbiB7IHxiZWZvcmUsIGFmdGVyfCAhKHlpZWxkIGJlZm9yZSwgYWZ0ZXIpIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAgeyB8aXRlbXwgeWllbGQgaXRlbSB9LmZsYXR0ZW4oMSlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IDBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGJsb2NrID0gcHJvYyBkbyB8KmFyZ3N8XG4gICAgICAgIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IHByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpYFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgcmVzcG9uZF90bz8oOnNpemUpID8gRmxvYXQ6OklORklOSVRZIDogbmlsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRldGVjdChpZm5vbmUgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRldGVjdCwgaWZub25lIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICBpZiB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGlmbm9uZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaWZub25lKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpZm5vbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICBudW1iZXIgPSBPcGFsLmNvZXJjZV90byBudW1iZXIsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKClcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRyb3Bfd2hpbGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICAgPSBbXSxcbiAgICAgICAgICBkcm9wcGluZyA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGlmIChkcm9wcGluZykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmZhbHN5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICAgIGRyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29ucyhuLCAmYmxvY2spXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gT3BhbC50cnlfY29udmVydCBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXSwgcmVzdWx0ID0gbmlsO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBidWZmZXIuc2xpY2UoMCwgbikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2VudHJ5KCpkYXRhLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIHRvX2VudW0oOmVhY2hfZW50cnksICpkYXRhKSB7IGVudW1lcmF0b3Jfc2l6ZSB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3NsaWNlKG4sICZibG9jaylcbiAgICBuID0gT3BhbC5jb2VyY2VfdG8gbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNsaWNlIHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfc2xpY2UsIG4pIHsgcmVzcG9uZF90bz8oOnNpemUpID8gKHNpemUgLyBuKS5jZWlsIDogbmlsIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHNsaWNlID0gW11cblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9vYmplY3Qob2JqZWN0LCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfb2JqZWN0LCBvYmplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBPcGFsLmNvZXJjZV90byBudW1iZXIsIEludGVnZXIsIDp0b19pbnRcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEje1N5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIEVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbiA9IE9wYWwuY29lcmNlX3RvKG4sIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5cbiAgZGVmIG1pbigmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPCAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4KCZibG9jaylcbiAgICBibG9jayB8fD0gcHJvYyB7IHxhLCBifCBhIDw9PiBiIH1cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IG5pbCwgbWF4ID0gbmlsLCBmaXJzdF90aW1lID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgaWYgKGZpcnN0X3RpbWUpIHtcbiAgICAgICAgICBtaW4gPSBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIGZpcnN0X3RpbWUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluX2NtcCA9ICN7YmxvY2suY2FsbChgbWluYCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWluX2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xuICAgICAgICAgICAgbWluID0gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4X2NtcCA9ICN7YmxvY2suY2FsbChgbWF4YCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXhfY21wIDwgMCkge1xuICAgICAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXhfYnkoJmJsb2NrKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpdGVtID0gT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBvbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBjb3VudCA9IDBcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCN7T3BhbC5mYWxzeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuXG4gIGRlZiBzbGljZV9iZWZvcmUocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIEVudW1lcmF0b3IubmV3IGRvIHxlfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0gJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX2FmdGVyKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgYmxvY2sgPSBwcm9jIHsgfGV8IHBhdHRlcm4gPT09IGUgfVxuICAgIGVuZFxuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBlbmRfY2h1bmsgPSBPcGFsLnlpZWxkMShibG9jaywgZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGBlbmRfY2h1bmtgKX0pIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2Vfd2hlbigmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEpJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgYmVmb3JlID0gcGFyYW1zWzBdLFxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBPcGFsLnlpZWxkWChibG9jaywgW2JlZm9yZSwgYWZ0ZXJdKTtcblxuICAgICAgICAgIGxhc3RfYWZ0ZXIgPSBhZnRlcjtcblxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgbWF0Y2hgKX0pIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gT3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBhbGlhcyB0b19hIGVudHJpZXNcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICB0b19hLnppcCgqb3RoZXJzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImFsbD8iLCJlYWNoIiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwicGF0dGVybiIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJyYWlzZSIsInNsaWNlX3doZW4iLCJiZWZvcmUiLCJhZnRlciIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJjb2xsZWN0X2NvbmNhdCIsIm1hcCIsIml0ZW0iLCJmbGF0dGVuIiwiMSIsImNvdW50IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJhcmdzIiwiPT0iLCJvYmplY3QiLCJuaWw/IiwiY3ljbGUiLCJuIiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJkcm9wIiwibnVtYmVyIiwiY29lcmNlX3RvIiwiZHJvcF93aGlsZSIsImZhbHN5PyIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiZW51bV9zaXplIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4Iiwic2VsZiIsImVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmluZF9hbGwiLCJ0cnV0aHk/IiwiZmluZF9pbmRleCIsImluZGV4IiwiZmlyc3QiLCJjdXJyZW50IiwiZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJncm91cF9ieSIsImhhc2giLCIkd3JpdGVyIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImluamVjdCIsIj09PSIsImluc3BlY3QiLCJzeW0iLCJsYXp5IiwiZW51bSQiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsIm1pbiIsImNvbXBhcmUiLCJtaW5fYnkiLCJtaW5tYXgiLCJhIiwiYiIsImNhbGwiLCJtaW5tYXhfYnkiLCJub25lPyIsIm9uZT8iLCJwYXJ0aXRpb24iLCJyZWplY3QiLCJyZXZlcnNlX2VhY2giLCJzbGljZV9iZWZvcmUiLCJlIiwiZHVwIiwic2xpY2VfYWZ0ZXIiLCJhcnkiLCJ0b19hIiwic29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsInN1bSIsImluaXRpYWwiLCJ0YWtlIiwibnVtIiwidGFrZV93aGlsZSIsInVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQVpFO0FBQUE7QUFjQUMsSUFBQUEsd0JBQUFBLHlCQUFBQSxTQUFTLE9BQVRBLEdBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFB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ImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBFbnVtZXJhdG9yXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfZW51bWVyYXRvciA9IHRydWVgXG5cbiAgZGVmIHNlbGYuZm9yKG9iamVjdCwgbWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gI3thbGxvY2F0ZX07XG5cbiAgICAgIG9iai5vYmplY3QgPSBvYmplY3Q7XG4gICAgICBvYmouc2l6ZSAgID0gYmxvY2s7XG4gICAgICBvYmoubWV0aG9kID0gbWV0aG9kO1xuICAgICAgb2JqLmFyZ3MgICA9IGFyZ3M7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIEBvYmplY3QgPSBHZW5lcmF0b3IubmV3KCZibG9jaylcbiAgICAgIEBtZXRob2QgPSA6ZWFjaFxuICAgICAgQGFyZ3MgICA9IFtdXG4gICAgICBAc2l6ZSAgID0gYGFyZ3VtZW50c1swXSB8fCBuaWxgXG5cbiAgICAgIGlmIEBzaXplXG4gICAgICAgIEBzaXplID0gT3BhbC5jb2VyY2VfdG8gQHNpemUsIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgUHJvYyA9PT0gQHNpemUgPyBAc2l6ZS5jYWxsKCpAYXJncykgOiBAc2l6ZVxuICBlbmRcblxuICBkZWYgd2l0aF9pbmRleChvZmZzZXQgPSAwLCAmYmxvY2spXG4gICAgb2Zmc2V0ID0gaWYgb2Zmc2V0XG4gICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byBvZmZzZXQsIEludGVnZXIsIDp0b19pbnRcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOndpdGhfaW5kZXgsIG9mZnNldCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsIGluZGV4ID0gb2Zmc2V0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGVhY2goKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHdpdGhfb2JqZWN0IGVhY2hfd2l0aF9vYmplY3RcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0W1JhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgICAgcmV0dXJuICRicmVha2VyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgIHRocm93ICRicmVha2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KCp2YWx1ZXMpXG4gICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgTGF6eSA8IHNlbGZcbiAgICBjbGFzcyBTdG9wTGF6eUVycm9yIDwgRXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG5ldyB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgQGVudW1lcmF0b3IgPSBvYmplY3RcblxuICAgICAgc3VwZXIgc2l6ZSBkbyB8eWllbGRlciwgKmVhY2hfYXJnc3xcbiAgICAgICAgb2JqZWN0LmVhY2goKmVhY2hfYXJncykgZG8gfCphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBFeGNlcHRpb25cbiAgICAgICAgbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZvcmNlIHRvX2FcblxuICAgIGRlZiBsYXp5XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAje09wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgQXJyYXksIDp0b19hcnl9O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT09IG5pbCkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcChuKVxuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIG4sIEludGVnZXIsIDp0b19pbnRcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGRyb3BwZWQgPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBkcm9wcGVkIDwgblxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLmZhbHN5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgc2VsZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSlgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgcGFyYW1gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gICAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHJlamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje09wYWwuZmFsc3k/KGB2YWx1ZWApfSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlKG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8gbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdGFrZW4gPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiB0YWtlbiA8IG5cbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICAgIHRha2VuICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFN0b3BMYXp5RXJyb3JcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAje3JhaXNlIFN0b3BMYXp5RXJyb3J9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QGVudW1lcmF0b3IuaW5zcGVjdH0+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiZm9yIiwic2VsZiIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiY29lcmNlX3RvIiwiZWFjaCIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsIl9fc2VuZF9fIiwic2l6ZSIsIj09PSIsImNhbGwiLCJ3aXRoX2luZGV4IiwiMCIsIm9mZnNldCIsImVudW1fZm9yIiwiZGVzdHJ1Y3R1cmUiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiMSIsIi0yIiwicmFpc2UiLCJAYmxvY2siLCJ5aWVsZGVyIiwieWllbGQiLCI8PCIsInZhbHVlcyIsImJsb2NrX2dpdmVuPyIsIkBlbnVtZXJhdG9yIiwib2JqZWN0IiwiZWFjaF9hcmdzIiwibGF6eSIsImNvbGxlY3QiLCJlbnVtZXJhdG9yX3NpemUiLCJlbnVtJCIsImNvbGxlY3RfY29uY2F0IiwicmVzcG9uZF90bz8iLCJ2IiwidHJ5X2NvbnZlcnQiLCJkcm9wIiwibiIsIjwiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsImRyb3BwZWQiLCJkcm9wX3doaWxlIiwic3VjY2VlZGluZyIsImZhbHN5PyIsIm1ldGhvZCIsImZpbmRfYWxsIiwidHJ1dGh5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aUJBQU0sU0FBTixFQUFjLFVBQWQsQ0FyT0E7QUFBQSxNQXVPQSxPQUFBekMsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQSxFQUFBLEdBQUEsSUFBQSxHQUFBLENBQUt4QixJQUFBSCxPQUFBQSxDQUFBQSxDQUFMLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBb0J3QyxlQUFBYixTQUFBQSxDQUFBQSxDQUFwQixDQUFBLEdBQUE7QUFERkEsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQXZPQTtBQURGM0IsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYUcsSUFBYkgsV0E5SUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMDU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgTnVtZXJpY1xuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgW0Zsb2F0KG90aGVyKSwgRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IE1hdGg6OlBJIDogMFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIENvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgT3BhbC5jb2VyY2VfdG8hKHNlbGYsIFJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsInNlbGYiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwibWV0aG9kIiwicmFpc2UiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJjZWlsIiwidG9fZiIsIm5kaWdpdHMiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiPT0iLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJjb2VyY2VfdG8hIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJuZWdhdGl2ZT8iLCJkdXAiLCJjbG9uZSIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxD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QUEsTUFpTEksT0FBQXpELElBakxKO0FBZ0xFeUQsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBNUtBO0FBQUE7QUFnTEFDLElBQUFBLDJCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FoTEE7QUFBQSxJQW9MQSxPQUFBQyxDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLHFCQXBMQTtBQURGaEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMzc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIEFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FycmF5JywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gdG9BcnJheVN1YmNsYXNzKG9iaiwga2xhc3MpIHtcbiAgICAgIGlmIChrbGFzcy4kJG5hbWUgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrbGFzcy4kYWxsb2NhdGUoKS4kcmVwbGFjZSgje2BvYmpgLnRvX2F9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3tJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gI3tPcGFsLmNvZXJjZV90byBzaXplLCBJbnRlZ2VyLCA6dG9faW50fVxuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgdmFsdWU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGkpO1xuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8gb2JqLCBBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIE9wYWwuY29lcmNlX3RvKG90aGVyLCBBcnJheSwgOnRvX2FyeSkudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaC4ka2V5cygpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgcmV0dXJuIGpvaW4ob3RoZXIudG9fc3RyKSBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG5cbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIG90aGVyLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhyZXN1bHQsICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhvdGhlciwgQXJyYXksIDp0b19hcnkpLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhvdGhlciwgQXJyYXksIDp0b19hcnkpLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw8KG9iamVjdClcbiAgICBgc2VsZi5wdXNoKG9iamVjdClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgb3RoZXJgLCA6dG9fYXJ5fSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9IE9wYWwuT3BhbC4kY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSBPcGFsLk9wYWwuJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiB0b0FycmF5U3ViY2xhc3MocmVzdWx0LCBzZWxmLiRjbGFzcygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSBPcGFsLk9wYWwuJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSBPcGFsLk9wYWwuJGNvZXJjZV90byhsZW5ndGgsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IGluZGV4ID4gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhyZXN1bHQsIHNlbGYuJGNsYXNzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgZGF0YSA9IGlmIEFycmF5ID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgIHZhbHVlLnRvX2FyeS50b19hXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9ICN7T3BhbC5jb2VyY2VfdG8gYGluZGV4LmJlZ2luYCwgSW50ZWdlciwgOnRvX2ludH0sXG4gICAgICAgICAgICB0byAgICAgID0gI3tPcGFsLmNvZXJjZV90byBgaW5kZXguZW5kYCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiBBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hcnkudG9fYVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAje09wYWwuY29lcmNlX3RvIGluZGV4LCBJbnRlZ2VyLCA6dG9faW50fTtcbiAgICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byBsZW5ndGgsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwibmVnYXRpdmUgbGVuZ3RoICgje2xlbmd0aH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgIGluZGV4ID0gT3BhbC5jb2VyY2VfdG8gaW5kZXgsIEludGVnZXIsIDp0b19pbnRcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoX2luZGV4IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IDAsXG4gICAgICAgICAgbWF4ID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgbWlkLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlLFxuICAgICAgICAgIHNhdGlzZmllZCA9IG5pbDtcblxuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gMik7XG4gICAgICAgIHZhbCA9IHNlbGZbbWlkXTtcbiAgICAgICAgcmV0ID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbCk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNhdGlzZmllZCA9IG1pZDtcbiAgICAgICAgICBzbWFsbGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChyZXQgPT09IDApIHsgcmV0dXJuIG1pZDsgfVxuICAgICAgICAgIHNtYWxsZXIgPSAocmV0IDwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaW5kZXggPSBic2VhcmNoX2luZGV4KCZibG9jaylcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICBGbG9hdDo6SU5GSU5JVFlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IG5pbCwgJmJsb2NrKVxuICAgIGlmIG9iamVjdCB8fCBibG9ja1xuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzaXplXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgcmVwbGFjZSBvdGhlclxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICByZXR1cm4gI3t5aWVsZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2F0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAje09wYWwuY29lcmNlX3RvIGBpbmRleGAsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmW2luZGV4XTtcblxuICAgICAgc2VsZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkaWcoaWR4LCAqaWR4cylcbiAgICBpdGVtID0gc2VsZltpZHhdXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwgaWR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmlkeHMpXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICAleHtcbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UobnVtYmVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkgJiZcbiAgICAgICAgICBzZWxmLiQkY2xhc3MuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byBgaW5kZXhgLCBJbnRlZ2VyLCA6dG9faW50fTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IC0je2BzZWxmLmxlbmd0aGB9Li4uI3tgc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiBibG9ja1xuICAgICAgaWYgYGFyZ3MubGVuZ3RoID4gMmBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMC4uMilcIlxuICAgICAgZW5kXG5cbiAgICAgIG9uZSwgdHdvID0gYXJnc1xuICAgIGVsc2VcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA9PSAwYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAxLi4zKVwiXG4gICAgICBlbmRcblxuICAgICAgb2JqLCBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbmRcblxuICAgIGlmIFJhbmdlID09PSBvbmVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBPcGFsLmNvZXJjZV90byBvbmUuYmVnaW4sIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcIiN7b25lLmluc3BlY3R9IG91dCBvZiByYW5nZVwiIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgcmlnaHQgPSBPcGFsLmNvZXJjZV90byBvbmUuZW5kLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBgcmlnaHQgKz0gdGhpcy5sZW5ndGhgIGlmIGByaWdodCA8IDBgXG4gICAgICBgcmlnaHQgKz0gMWAgdW5sZXNzIG9uZS5leGNsdWRlX2VuZD9cblxuICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0IDw9IGxlZnRgXG4gICAgZWxzaWYgb25lXG4gICAgICBsZWZ0ICAgPSBPcGFsLmNvZXJjZV90byBvbmUsIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICBsZWZ0ICAgPSAwIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgaWYgdHdvXG4gICAgICAgIHJpZ2h0ID0gT3BhbC5jb2VyY2VfdG8gdHdvLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAje09wYWwuY29lcmNlX3RvIGBjb3VudGAsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEje09wYWwucmVzcG9uZF90bz8gYGl0ZW1gLCA6dG9fYXJ5LCB0cnVlfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAje09wYWwuY29lcmNlX3RvKGBsZXZlbGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhfZmxhdHRlbihzZWxmLCBsZXZlbCksICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4hKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGZsYXR0ZW5lZCA9ICN7ZmxhdHRlbiBsZXZlbH07XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PSBmbGF0dGVuZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGZbaV0gIT09IGZsYXR0ZW5lZFtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAje3JlcGxhY2UgYGZsYXR0ZW5lZGB9O1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoT3BhbC5oYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0EnXSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgaXRlbSwgaSwga2V5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgZm9yIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGlmIChPcGFsLmhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIE9wYWwuaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gT3BhbC5oYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1lbWJlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBtZW1iZXJ9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6aW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICN7T3BhbC5jb2VyY2VfdG8gYGluZGV4YCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IHJhaXNlIEluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBpZCAgICAgPSAje19faWRfX307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgIGlmICgje2BpdGVtYC5fX2lkX199ID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdbLi4uXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YGl0ZW1gLmluc3BlY3R9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgam9pbihzZXAgPSBuaWwpXG4gICAgcmV0dXJuICcnIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBzZXAgPT09IG5pbGBcbiAgICAgIHNlcCA9ICQsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBsZW5ndGgsIGl0ZW0sIHRtcDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoI3tPcGFsLnJlc3BvbmRfdG8/IGBpdGVtYCwgOnRvX3N0cn0pIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zdHJ9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLnRvX3N9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgaXRlbWAsIDp0b19hcnl9KSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLmpvaW4oc2VwKX0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tPcGFsLnJlc3BvbmRfdG8/IGBpdGVtYCwgOnRvX3N9KSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7cmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCIje2BPcGFsLmluc3BlY3QoaXRlbSlgfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3tPcGFsLmNvZXJjZV90byEoc2VwLCBTdHJpbmcsIDp0b19zdHIpLnRvX3N9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICN7T3BhbC5jb2VyY2VfdG8gYGNvdW50YCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICN7IE9wYWwuY29lcmNlX3RvIG51bSwgSW50ZWdlciwgOnRvX2ludCB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9wYWwueWllbGQxKGJsaywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICAvLyBvZmZlbnNpdmUgKGJvdGggZGVmaW5pdGlvbnMpIGNvcHkuXG4gICAgICAgICAgb2ZmZW5zaXZlID0gc2VsZi5zbGljZSgpO1xuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX3Blcm11dGF0aW9uKG4pXG4gICAgbnVtID0gT3BhbC5jb2VyY2VfdG8hIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKG51bSwgW10sIHNlbGYuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9wKGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5wb3AoKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gT3BhbC5jb2VyY2VfdG8gY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPiBzZWxmLmxlbmd0aGBcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG4gICAgZWxzZVxuICAgICAgYHNlbGYuc3BsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAje2Jsb2NrX2dpdmVuP30gPyBudWxsIDogW10sXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBsZW5ndGhzICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBpLCBtLCBzdWJhcnJheSwgbGVuLCByZXN1bHRsZW4gPSAxO1xuXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJheXNbaV0gPSAje09wYWwuY29lcmNlX3RvKGBhcmdzW2kgLSAxXWAsIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRsZW4gKj0gbGVuO1xuICAgICAgICBpZiAocmVzdWx0bGVuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ3RvbyBiaWcgdG8gcHJvZHVjdCd9XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3Roc1tpXSA9IGxlbjtcbiAgICAgICAgY291bnRlcnNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBvdXRlcl9sb29wOiBmb3IgKDs7KSB7XG4gICAgICAgIHN1YmFycmF5ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzdWJhcnJheS5wdXNoKGFycmF5c1tpXVtjb3VudGVyc1tpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzdWJhcnJheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3t5aWVsZCBgc3ViYXJyYXlgfVxuICAgICAgICB9XG4gICAgICAgIG0gPSBuIC0gMTtcbiAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgd2hpbGUgKGNvdW50ZXJzW21dID09PSBsZW5ndGhzW21dKSB7XG4gICAgICAgICAgY291bnRlcnNbbV0gPSAwO1xuICAgICAgICAgIGlmICgtLW0gPCAwKSBicmVhayBvdXRlcl9sb29wO1xuICAgICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1c2goKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gob2JqZWN0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICYmIGl0ZW1bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBvcmlnaW5hbCA9IGxlbmd0aFxuICAgIGRlbGV0ZV9pZigmYmxvY2spXG5cbiAgICB1bmxlc3MgbGVuZ3RoID09IG9yaWdpbmFsXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgc2VsZi5wdXNoLmFwcGx5KHNlbGYsIG90aGVyKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc2xpY2UoMCkucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZSFcbiAgICBgc2VsZi5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZXZlcnNlLmVhY2goJmJsb2NrKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IGBvYmplY3RgfSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6cmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUobiA9IDEpXG4gICAgbiA9IE9wYWwuY29lcmNlX3RvIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gICAgY250ID0gT3BhbC5jb2VyY2VfdG8gY250LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gT3BhbC5jb2VyY2VfdG8gQHJuZy5yYW5kKHNpemUpLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgPj0gMCcgaWYgYHJhbmRvbSA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IEtlcm5lbC5yYW5kKGBzZWxmLmxlbmd0aGApIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuXG4gICAgaWYgYG9wdGlvbnMgPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIChvID0gT3BhbC5jb2VyY2VfdG8/IGNvdW50LCBIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBvcHRpb25zID0gT3BhbC5jb2VyY2VfdG8gb3B0aW9ucywgSGFzaCwgOnRvX2hhc2hcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnY291bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCdcbiAgICBlbmRcblxuICAgIHJuZyA9IG9wdGlvbnNbOnJhbmRvbV0gaWYgb3B0aW9uc1xuICAgIHJuZyA9IGlmIHJuZyAmJiBybmcucmVzcG9uZF90bz8oOnJhbmQpXG4gICAgICAgICAgICBTYW1wbGVSYW5kb20ubmV3IHJuZ1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEtlcm5lbFxuICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGBzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XWAgdW5sZXNzIGNvdW50XG5cbiAgICAleHtcblxuICAgICAgdmFyIGFiYW5kb24sIHNwaW4sIHJlc3VsdCwgaSwgaiwgaywgdGFyZ2V0SW5kZXgsIG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gW3NlbGZbI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX1dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGkgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICBqID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGogPSBpID09PSAwID8gaSArIDEgOiBpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtzZWxmW2ldLCBzZWxmW2pdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoc2VsZi5sZW5ndGggLyBjb3VudCA+IDMpIHtcbiAgICAgICAgICAgIGFiYW5kb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNwaW4gPSAwO1xuXG4gICAgICAgICAgICByZXN1bHQgPSAjeyBBcnJheS5uZXcoY291bnQpIH07XG4gICAgICAgICAgICBpID0gMTtcblxuICAgICAgICAgICAgcmVzdWx0WzBdID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGogPCBpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPT09IHJlc3VsdFtqXSkge1xuICAgICAgICAgICAgICAgICAgc3BpbisrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwaW4gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWJhbmRvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWJhbmRvbikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICByZXN1bHRbaV0gPSBrO1xuXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhYmFuZG9uKSB7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZltyZXN1bHRbaV1dO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgb2xkVmFsdWUgPSByZXN1bHRbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W3RhcmdldEluZGV4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gc2VsZi5sZW5ndGggPyByZXN1bHQgOiAje2ByZXN1bHRgWzAsIGNvdW50XX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoT3BhbC50cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG4gICAgICAjeyBrZWVwX2lmKCZibG9jaykgfTtcbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNoaWZ0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5zaGlmdCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBjb3VudClgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxuICAgIGR1cC50b19hLnNodWZmbGUhKHJuZylcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUhKHJuZyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByYW5kZ2VuLCBpID0gc2VsZi5sZW5ndGgsIGosIHRtcDtcblxuICAgICAgaWYgKHJuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJuZyA9ICN7T3BhbC5jb2VyY2VfdG8/KHJuZywgSGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcbiAgICAgICAgICBybmcgPSAje3JuZ1s6cmFuZG9tXX07XG5cbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xuICAgICAgICAgICAgcmFuZGdlbiA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaWYgKHJhbmRnZW4pIHtcbiAgICAgICAgICBqID0gcmFuZGdlbi4kcmFuZChpKS4kdG9faW50KCk7XG5cbiAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gYmlnICN7YGpgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBqID0gI3tyYW5kKGBpYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gc2VsZlstLWldO1xuICAgICAgICBzZWxmW2ldID0gc2VsZltqXTtcbiAgICAgICAgc2VsZltqXSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzbGljZSBbXVxuXG4gIGRlZiBzbGljZSEoaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICByZXN1bHQgPSBuaWxcblxuICAgIGlmIGBsZW5ndGggPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgICByYW5nZSA9IGluZGV4XG4gICAgICAgIHJlc3VsdCA9IHNlbGZbcmFuZ2VdXG5cbiAgICAgICAgcmFuZ2Vfc3RhcnQgPSBPcGFsLmNvZXJjZV90byhyYW5nZS5iZWdpbiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgcmFuZ2VfZW5kID0gT3BhbC5jb2VyY2VfdG8ocmFuZ2UuZW5kLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gT3BhbC5jb2VyY2VfdG8oaW5kZXgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZltzdGFydF07XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3RhcnQgPSBPcGFsLmNvZXJjZV90byhpbmRleCwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgIGxlbmd0aCA9IE9wYWwuY29lcmNlX3RvKGxlbmd0aCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiB0b19oXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuID0gc2VsZi5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyeSA9ICN7T3BhbC5jb2VyY2VfdG8/KGBzZWxmW2ldYCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSBhdCAje2BpYH0gKGV4cGVjdGVkIGFycmF5KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcnkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0cmFuc3Bvc2VcbiAgICByZXR1cm4gW10gaWYgZW1wdHk/XG5cbiAgICByZXN1bHQgPSBbXVxuICAgIG1heCAgICA9IG5pbFxuXG4gICAgZWFjaCBkbyB8cm93fFxuICAgICAgcm93ID0gaWYgQXJyYXkgPT09IHJvd1xuICAgICAgICAgICAgICByb3cudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhyb3csIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICAgbWF4IHx8PSBgcm93Lmxlbmd0aGBcblxuICAgICAgaWYgYHJvdy5sZW5ndGhgICE9IG1heFxuICAgICAgICByYWlzZSBJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdW5pcSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcygje2BoYXNoYC52YWx1ZXN9LCAje3NlbGYuY2xhc3N9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxISgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsX2xlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBrZXkgPSAoYmxvY2sgPT09IG5pbCA/IGl0ZW0gOiBPcGFsLnlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsX2xlbmd0aCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5zaGlmdCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHNlbGYudW5zaGlmdChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gUmFuZ2VcbiAgICAgICAgZmluaXNoID0gT3BhbC5jb2VyY2VfdG8gZWxlbS5sYXN0LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICAgIHN0YXJ0ID0gT3BhbC5jb2VyY2VfdG8gZWxlbS5maXJzdCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30pIHtcbiAgICAgICAgICAgIGZpbmlzaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluaXNoIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQudXB0byhmaW5pc2gpIHsgfGl8IG91dCA8PCBhdChpKSB9XG4gICAgICBlbHNlXG4gICAgICAgIGkgPSBPcGFsLmNvZXJjZV90byBlbGVtLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICAgIG91dCA8PCBhdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSBzZWxmLmxlbmd0aCwgcGFydCwgbywgaSwgaiwgamo7XG5cbiAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgbyA9IG90aGVyc1tqXTtcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLiQkaXNfZW51bWVyYXRvcikge1xuICAgICAgICAgIGlmIChvLiRzaXplKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0YWtlKHNpemUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0b19hKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyc1tqXSA9ICN7KFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvPyhgb2AsIEFycmF5LCA6dG9fYXJ5KSB8fFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvIShgb2AsIEVudW1lcmF0b3IsIDplYWNoKVxuICAgICAgICApLnRvX2F9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSBbc2VsZltpXV07XG5cbiAgICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIG8gPSBvdGhlcnNbal1baV07XG5cbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRbaiArIDFdID0gbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICAleHtcbiAgICAgIGtsYXNzLiQkcHJvdG90eXBlLiR0b19hID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBzdXBlci5yZWplY3QgeyB8aXZhcnwgYC9eQFxcZCskLy50ZXN0KCN7aXZhcn0pYCB8fCBpdmFyID09ICdAbGVuZ3RoJyB9XG4gIGVuZFxuXG4gIE9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgT3BhbC5wcmlzdGluZSBzZWxmLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuXG4gIGRlZiBwYWNrKCphcmdzKVxuICAgIHJhaXNlIFwiVG8gdXNlIEFycmF5I3BhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvYXJyYXkvcGFjaycuXCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwidG9fYSIsIltdIiwic2VsZiIsImluaXRpYWxpemUiLCJ3YXJuIiwicmFpc2UiLCJyZXBsYWNlIiwic2l6ZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwiY29lcmNlX3RvIiwidHJ5X2NvbnZlcnQiLCJjb2VyY2VfdG8/Iiwib2JqIiwiJiIsIm90aGVyIiwiPT09IiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIjw9PiIsImhhc2giLCI9PSIsIm9iamVjdF9pZCIsIltdPSIsImluZGV4IiwiZGF0YSIsInZhbHVlIiwiaW5zcGVjdCIsImxlbmd0aCIsIjEiLCJleHRyYSIsImFueT8iLCJhc3NvYyIsIm9iamVjdCIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYnNlYXJjaCIsImJsb2NrIiwiY3ljbGUiLCJuIiwibmlsPyIsImNvZXJjZV90byEiLCI+IiwiMCIsImVudW1lcmF0b3Jfc2l6ZSIsImVtcHR5PyIsImNsZWFyIiwiY291bnQiLCJpbml0aWFsaXplX2NvcHkiLCJjb2xsZWN0IiwiY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiZXF1YWw/IiwiZHVwIiwiZWFjaCIsImRlbGV0ZSIsImRlbGV0ZV9hdCIsImRlbGV0ZV9pZiIsImRpZyIsIml0ZW0iLCJpZHgiLCJpZHhzIiwiZHJvcCIsImVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsImxlZnQiLCJiZWdpbiIsInJpZ2h0IiwiZW5kIiwiZXhjbHVkZV9lbmQ/IiwiZmlyc3QiLCJmbGF0dGVuIiwiZmxhdHRlbiEiLCJsZXZlbCIsImluY2x1ZGU/IiwibWVtYmVyIiwiaW5zZXJ0IiwiX19pZF9fIiwic2VwIiwiJCwiLCJ0b19zIiwibmV3Iiwia2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwiISIsInJlcGVhdGVkX3Blcm11dGF0aW9uIiwiPj0iLCIqKiIsInBvcCIsInByb2R1Y3QiLCJwdXNoIiwicmFzc29jIiwicmVqZWN0IiwicmVqZWN0ISIsIm9yaWdpbmFsIiwicmV2ZXJzZSIsInJldmVyc2UhIiwicmV2ZXJzZV9lYWNoIiwicmluZGV4Iiwicm90YXRlIiwicm90YXRlISIsImNudCIsImFyeSIsIkBybmciLCJybmciLCJyYW5kIiwicmFuZG9tIiwic2FtcGxlIiwibyIsIm9wdGlvbnMiLCJzZWxlY3QiLCJzZWxlY3QhIiwic2hpZnQiLCJzaHVmZmxlIiwic2h1ZmZsZSEiLCJzbGljZSEiLCJyZXN1bHQiLCJyYW5nZSIsInJhbmdlX3N0YXJ0IiwicmFuZ2VfZW5kIiwic3RhcnQiLCJzb3J0IiwiPCIsInNvcnQhIiwic29ydF9ieSEiLCJzb3J0X2J5IiwidGFrZSIsInRha2Vfd2hpbGUiLCJ0b19oIiwidHJhbnNwb3NlIiwicm93IiwiIT0iLCJ0aW1lcyIsImVudHJ5IiwiaSIsIiR3cml0ZXIiLCJ1bmlxIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiZWxlbSIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsInppcCIsImluaGVyaXRlZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIml2YXIiLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyIsInBhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsRUFHQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBR0MseURBSEQ7QUFBQTtBQU1GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTRDLENBQUMsR0FBRCxDQUFB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d3lFMEIsT0FBQSxjQUFDLGNBQWdCeUQsSUFBSyxDQUF0QixTQUE0QkEsSUFBQW5KLE9BQUFBLENBQVEsU0FBUkEsQ0FBNUIsQ0F4eUUxQixDQUFBLG9CQUFBLG1CQUFBLE9Bd3lFSTBGO0FBREZ3RCxJQUFBQSxDQUFBQSwyQ0FBQUEsQ0FseUVBO0FBQUEsSUFzeUVBLG9CQUFBRSxVQUFBQSxLQUFjQyxpQkFBQUEsQ0FBQUEsR0FBaUIsVUFBL0JELENBdHlFQTtBQUFBLElBdXlFQSxvQkFBQUEsVUFBQUEsQ0FBYzVLLE1BQU0sMkJBQTBCLGdCQUE5QzRLLENBdnlFQTtBQUFBLElBeXlFQSxPQUFBRSxDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQTl5RUYsRUE4eUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5eUVGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBOHlFVyxNQUFBLGtCQTl5RVg7QUFBQSxNQSt5RUksV0FBQTNLLE9BQUFBLENBQU0saUVBQU5BLENBL3lFSjtBQTh5RUUySyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsZ0JBenlFQTtBQURGbEwsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZSxLQUFmQSxXQUhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTQyNzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyBIYXNoXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3tPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8ob2JqLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IE9wYWwuaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICBPcGFsLmhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3tPcGFsLmNvZXJjZV90byEoYHByb2NgLCBQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlYWNoX3BhaXIgZWFjaFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IE9wYWwuY29lcmNlX3RvIShsZXZlbCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluZGljZXMgaW5kZXhlc1xuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LiRpbnNwZWN0KCkgKyAnPT4nICsgdmFsdWUuJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBrZXkgaW5kZXhcblxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIG1lcmdlKG90aGVyLCAmYmxvY2spXG4gICAgZHVwLm1lcmdlIShvdGhlciwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBibG9jayhrZXksIHZhbHVlLCBvdGhlcl92YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWhhc2hcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9yZWhhc2goc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9pbml0KHNlbGYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICAgIHNlbGYuZGVmYXVsdF9wcm9jID0gb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgZWxzZVxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmlsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5IYXNoKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2hhc2hcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgcHJvYyBkbyB8a2V5ID0gdW5kZWZpbmVkfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGtleSBnaXZlbid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZltrZXldXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPcGFsLnNsaWNlLmNhbGwoc2VsZi4kJGtleXMpLFxuICAgICAgICAgIGksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBuZXdfa2V5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdfa2V5ID0gT3BhbC55aWVsZDEoYmxvY2ssIGtleSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIG5ld19rZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB1cGRhdGUgbWVyZ2UhXG5cbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cblxuICBhbGlhcyB2YWx1ZXNfYXQgaW5kZXhlc1xuXG4gIGRlZiB2YWx1ZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuJCRzbWFwW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsIltdIiwic2VsZiIsImNvZXJjZV90bz8iLCJhcmd2IiwiMCIsImFsbG9jYXRlIiwibWVyZ2UhIiwicmFpc2UiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCI9PSIsIj49Iiwib3RoZXIiLCJjb2VyY2VfdG8hIiwicmVzdWx0IiwiZWFjaCIsInZhbCIsImZldGNoIiwib3RoZXJfa2V5IiwiPiIsIjwiLCI8PSIsIltdPSIsImFzc29jIiwib2JqZWN0IiwiY2xlYXIiLCJjbG9uZSIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbXBhcmVfYnlfaWRlbnRpdHkiLCJjb21wYXJlX2J5X2lkZW50aXR5PyIsImRlZmF1bHQiLCJkZWZhdWx0PSIsImRlZmF1bHRfcHJvYyIsImRlZmF1bHRfcHJvYz0iLCJsYW1iZGE/IiwiYXJpdHkiLCJhYnMiLCJkZWxldGUiLCJrZXkiLCJkZWxldGVfaWYiLCJibG9jayIsImVudW1fZm9yIiwic2l6ZSIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyIsImtleXMiLCJlYWNoX2tleSIsImVhY2hfdmFsdWUiLCJlbXB0eT8iLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiZmxhdHRlbiIsIjEiLCJsZXZlbCIsImhhc19rZXk/IiwiaGFzX3ZhbHVlPyIsInZhbHVlIiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwibGVuZ3RoIiwibWVyZ2UiLCJkdXAiLCJyYXNzb2MiLCJyZWhhc2giLCJyZWplY3QiLCJyZWplY3QhIiwicmVwbGFjZSIsIiR3cml0ZXIiLCItIiwic2VsZWN0Iiwic2VsZWN0ISIsInNoaWZ0Iiwic2xpY2UiLCJ0b19hIiwidG9faCIsInRvX2hhc2giLCJ0b19wcm9jIiwicHJvYyIsInRyYW5zZm9ybV9rZXlzIiwidHJhbnNmb3JtX2tleXMhIiwidHJhbnNmb3JtX3ZhbHVlcyIsInRyYW5zZm9ybV92YWx1ZXMhIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFVQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBR0MsaUNB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aUJBQU0sV0FBTixFQUFnQixTQUFoQixDQXRwQ0E7QUFBQSxJQXdwQ0EsT0FBQUMsQ0FBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWZFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsa0JBeHBDQTtBQURGN0YsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FWQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1NzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBOdW1iZXIgPCBOdW1lcmljXG4gIE9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3tGbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBGbG9hdCwgOnRvX2YpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gW290aGVyLCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYChzZWxmICogMikgKyAxYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmRpdiAvXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIDwgMCB8fCBzZWxmIDwgMCkge1xuICAgICAgICAgIHJldHVybiAoc2VsZiAlIG90aGVyICsgb3RoZXIpICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAmIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDomLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiB8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDp8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPD0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPj0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj49LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICAjIENvbXB1dGUgdGhlIHJlc3VsdCBvZiB0aGUgc3BhY2VzaGlwIG9wZXJhdG9yIGluc2lkZSBpdHMgb3duIGZ1bmN0aW9uIHNvIGl0XG4gICMgY2FuIGJlIG9wdGltaXplZCBkZXNwaXRlIGEgdHJ5L2ZpbmFsbHkgY29uc3RydWN0LlxuICAleHtcbiAgICB2YXIgc3BhY2VzaGlwX29wZXJhdG9yID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmID4gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0+LCBgb3RoZXJgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGBzcGFjZXNoaXBfb3BlcmF0b3Ioc2VsZiwgb3RoZXIpYFxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiA+Pihjb3VudClcbiAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvISBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSBPcGFsLmNvZXJjZV90byEgYml0LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoSW50ZWdlciA9PT0gc2VsZikgfHwgb3RoZXIgPiAwXG4gICAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmIChGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyKVxuICAgICAgQ29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgYE1hdGguYWJzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIGBNYXRoLmFicyhzZWxmICogc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhbGxiaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBwaGFzZSBhbmdsZVxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHJhaXNlIE5vTWV0aG9kRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgYml0X2xlbmd0aGAgZm9yICN7c2VsZn06RmxvYXRcIiwgJ2JpdF9sZW5ndGgnKVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gMCB8fCBzZWxmID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgdmFsdWUgID0gc2VsZiA8IDAgPyB+c2VsZiA6IHNlbGY7XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdCAgICs9IDE7XG4gICAgICAgIHZhbHVlICA+Pj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyKGVuY29kaW5nID0gdW5kZWZpbmVkKVxuICAgIGBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlbGYpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIE51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgc2VsZiA9PSBvdGhlciB8fCBgaXNOYU4oc2VsZikgJiYgaXNOYU4ob3RoZXIpYFxuICBlbmRcblxuICBkZWYgZXZlbj9cbiAgICBgc2VsZiAlIDIgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmZsb29yKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZChvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkLCBsY21dXG4gIGVuZFxuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGBzZWxmICUgMSA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEZsb2F0ICYmIEZsb2F0ID09PSBzZWxmXG5cbiAgICBzdXBlclxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gRmxvYXQgJiYgRmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIEludGVnZXIgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCB8fCBvdGhlciA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhzZWxmICogb3RoZXIgLyAje2djZChvdGhlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICBhbGlhcyBtb2R1bG8gJVxuXG4gIGRlZiBuZXh0XG4gICAgYHNlbGYgKyAxYFxuICBlbmRcblxuICBkZWYgbm9iaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IDBgXG4gIGVuZFxuXG4gIGRlZiBub256ZXJvP1xuICAgIGBzZWxmID09IDAgPyBuaWwgOiBzZWxmYFxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgIHNlbGZcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgb2RkP1xuICAgIGBzZWxmICUgMiAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvdyhiLCBtID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tzZWxmKipifTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKCN7SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYSAxc3QgYXJndW1lbnQgaXMgaW50ZWdlcid9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMXN0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDJuZCBhcmd1bWVudCBzcGVjaWZpZWQnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoI3tJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhbGwgYXJndW1lbnRzIGFyZSBpbnRlZ2Vycyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7KHNlbGYqKmIpICUgbX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVkXG4gICAgYHNlbGYgLSAxYFxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgUmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzaWYgbmFuP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBgZXBzID09IG51bGxgXG4gICAgICBmLCBuICA9IE1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSBNYXRoLmxkZXhwKGYsIEZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgbiAgICAtPSBGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgUmF0aW9uYWwubmV3KDIgKiBmLCAxIDw8ICgxIC0gbikpLnJhdGlvbmFsaXplKFJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxuICAgIGVsc2VcbiAgICAgIHRvX3IucmF0aW9uYWxpemUoZXBzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVtYWluZGVyKHkpXG4gICAgc2VsZiAtIHkgKiAoc2VsZiAvIHkpLnRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiByb3VuZChuZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgRmxvYXQgPT09IG5kaWdpdHMgJiYgbmRpZ2l0cy5pbmZpbml0ZT9cbiAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ0luZmluaXR5J1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSBPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgaWYgbmRpZ2l0cyA8IEludGVnZXI6Ok1JTlxuICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoeCkgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gT3BhbC5jb2VyY2VfdG8hKGBuZGlnaXRzIHx8IDBgLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdOYU4nXG4gICAgICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBuZGlnaXRzID09IDBcbiAgICAgICAgcmV0dXJuIGBNYXRoLnJvdW5kKHNlbGYpYFxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBfLCBleHAgPSBNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKEZsb2F0OjpESUcgKyAyKSAtIChleHAgPiAwID8gZXhwIC8gNCA6IGV4cCAvIDMgLSAxKVxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5kaWdpdHMgPCAtKGV4cCA+IDAgPyBleHAgLyAzICsgMSA6IGV4cCAvIDQpXG4gICAgICAgIHJldHVybiAwXG4gICAgICBlbmRcblxuICAgICAgYE1hdGgucm91bmQoc2VsZiAqIE1hdGgucG93KDEwLCBuZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgbmRpZ2l0cylgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0ID0gdW5kZWZpbmVkLCBzdGVwID0gdW5kZWZpbmVkLCB0bzogdW5kZWZpbmVkLCBieTogdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0ZXAgaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGltaXQgPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RlcCA9IGJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCB8fCBzdGVwID09IG51bGwpIHtcbiAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gI3tzdGVwIDw9PiAwfTtcblxuICAgICAgICBpZiAoc2lnbiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIjAgY2FuJ3QgYmUgY29lcmNlZCBpbnRvICN7c3RlcC5jbGFzc31cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gbmlsIHx8IGxpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICBsaW1pdCA9IHNpZ24gPiAwID8gI3tGbG9hdDo6SU5GSU5JVFl9IDogI3stRmxvYXQ6OklORklOSVRZfTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7T3BhbC5jb21wYXJlKHNlbGYsIGxpbWl0KX1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcEZsb2F0U2l6ZSgpIHtcbiAgICAgICAgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gSW5maW5pdHkgfHwgc3RlcCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoc2VsZikgKyBhYnMobGltaXQpICsgYWJzKGxpbWl0IC0gc2VsZikpIC8gYWJzKHN0ZXApICogI3tGbG9hdDo6RVBTSUxPTn07XG5cbiAgICAgICAgICBpZiAoZXJyID09PSBJbmZpbml0eSB8fCBlcnIgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcFNpemUoKSB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXBGbG9hdFNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxuICAgICAgICAgICAgICByaHMgPSBhYnMoc3RlcCk7XG5cbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcG9zaXRpb25hbF9hcmdzID0gW11cbiAgICAgIGtleXdvcmRfYXJncyA9IHt9XG5cbiAgICAgICV4e1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvc2l0aW9uYWxfYXJncy5wdXNoKGxpbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3NpdGlvbmFsX2FyZ3MucHVzaChzdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChrZXl3b3JkX2FyZ3MsIFwidG9cIiwgdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGtleXdvcmRfYXJncywgXCJieVwiLCBieSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3trZXl3b3JkX2FyZ3MuYW55P30pIHtcbiAgICAgICAgICBwb3NpdGlvbmFsX2FyZ3MucHVzaChrZXl3b3JkX2FyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgKnBvc2l0aW9uYWxfYXJncykgeyBgc3RlcFNpemUoKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBibG9jayhzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZiAlIDEgIT09IDAgfHwgbGltaXQgJSAxICE9PSAwIHx8IHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgIHZhciBuID0gc3RlcEZsb2F0U2l6ZSgpO1xuXG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGJsb2NrKHNlbGYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGQ7XG5cbiAgICAgICAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8IGQpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IGQpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNlbGY7XG5cbiAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSArPSBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodmFsdWUgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlICs9IHN0ZXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzdWNjIG5leHRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBwYXJzZUludChzZWxmLCAxMClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2ludCB0b19pXG5cbiAgZGVmIHRvX3JcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IE1hdGguZnJleHAoc2VsZilcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIChmICogKEZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDIgfHwgYmFzZSA+IDM2XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICBgc2VsZi50b1N0cmluZyhiYXNlKWBcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50KGYgKiBmYWN0b3IsIDEwKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkaWdpdHMoYmFzZSA9IDEwKVxuICAgIGlmIHNlbGYgPCAwXG4gICAgICByYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gT3BhbC5jb2VyY2VfdG8hIGJhc2UsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgJSBiYXNlKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSAvIGJhc2UsIDEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgaWYgbmFuPyB8fCBvdGhlci5uYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcbmVuZFxuXG5GaXhudW0gPSBOdW1iZXJcblxuY2xhc3MgSW50ZWdlciA8IE51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiA9PT0ob3RoZXIpXG4gICAgICAleHtcbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAob3RoZXIgJSAxKSA9PT0gMDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgTUFYID0gYE1hdGgucG93KDIsIDMwKSAtIDFgXG4gIE1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxuZW5kXG5cbmNsYXNzIEZsb2F0IDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmID09PShvdGhlcilcbiAgICAgIGAhIW90aGVyLiQkaXNfbnVtYmVyYFxuICAgIGVuZFxuICBlbmRcblxuICBJTkZJTklUWSA9IGBJbmZpbml0eWBcbiAgTUFYICAgICAgPSBgTnVtYmVyLk1BWF9WQUxVRWBcbiAgTUlOICAgICAgPSBgTnVtYmVyLk1JTl9WQUxVRWBcbiAgTkFOICAgICAgPSBgTmFOYFxuXG4gIERJRyAgICAgID0gMTVcbiAgTUFOVF9ESUcgPSA1M1xuICBSQURJWCAgICA9IDJcblxuICBFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJicmlkZ2UiLCJzZWxmIiwiYWxsb2NhdGUiLCJyYWlzZSIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIiYiLCJ8IiwiXiIsIjwiLCI8PSIsIj4iLCI+PSIsIjw9PiIsIjw8IiwiY291bnQiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIiEiLCIwIiwibmV3IiwiMSIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJjZWlsIiwiY2hyIiwiZGVub21pbmF0b3IiLCJpbmZpbml0ZT8iLCJkb3dudG8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInN0b3AiLCJlcXVhbD8iLCJldmVuPyIsImZsb29yIiwiZ2NkIiwiZ2NkbGNtIiwibGNtIiwiaW50ZWdlcj8iLCJpc19hPyIsImtsYXNzIiwiaW5zdGFuY2Vfb2Y/IiwibmV4dCIsIm5vYml0cz8iLCJub256ZXJvPyIsIm51bWVyYXRvciIsIm9kZD8iLCJvcmQiLCJwb3ciLCJiIiwibSIsInByZWQiLCJxdW8iLCJyYXRpb25hbGl6ZSIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsInRvX2kiLCIyIiwidG9fciIsImVwcyIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwibmRpZ2l0cyIsInNpemUiLCJfIiwiZXhwIiwiNCIsIjMiLCJzdGVwIiwiY29tcGFyZSIsImxpbWl0IiwicG9zaXRpb25hbF9hcmdzIiwia2V5d29yZF9hcmdzIiwiYW55PyIsInRpbWVzIiwiYmxvY2siLCJlIiwidG9fcyIsIjEwIiwiYmFzZSIsIjM2IiwiZGlnaXRzIiwiZGl2bW9kIiwidXB0byIsInplcm8/IiwiZmluaXRlPyIsInBv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QUEsR0FBQUEsV0FBQUEsRUFBZ0IsdUJBQWhCQSxXQWwvQkE7QUFBQSxFQXNoQ0EsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsNkJBQUQ7QUFBQSxJQUVBO0FBQUEsTUFBQTs7QUFBQTtBQUNFO0FBQUFHLE1BQUFBLDRCQUFBQSxlQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsV0FBQUMsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsMEJBQUEsR0FBQSxLQUEyQkMsTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBakJEO0FBREZELE1BQUFBLENBQUFBLDBCQUFBQSxDQUFBO0FBQUE7QUFJQSxNQUFBLHNCQUFNLEtBQU4sRUFKQTtBQUFBLE1BTUEsT0FBQWdDLENBQUFBLHVCQUFBQSxlQUFBQSxTQUFRLEtBQVJBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUMsbUJBQUQ7QUFERkEsTUFBQUEsQ0FBQUEsMEJBQUFBLENBQUFBLGVBTkE7QUFERixJQUFBLDRCQUFTakMsSUFBVCxZQUZBO0FBQUEsSUFjQSx3Q0FBWSxRQUFaLENBZEE7QUFBQSxJQWVBLG1DQUFZLGdCQUFaLENBZkE7QUFBQSxJQWdCQSxtQ0FBWSxnQkFBWixDQWhCQTtBQUFBLElBaUJBLG1DQUFZLEdBQVosQ0FqQkE7QUFBQSxJQW1CQSxtQ0FBV3FILEVBQVgsQ0FuQkE7QUFBQSxJQW9CQSx3Q0FBV0MsRUFBWCxDQXBCQTtBQUFBLElBcUJBLHFDQUFXbkMsQ0FBWCxDQXJCQTtBQUFBLElBdUJBLE9BQUEsdUNBQVcsdURBQVgsQ0F2QkE7QUFERnJGLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWMsdUJBQWRBLFdBdGhDQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MTQ5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5nZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFJhbmdlXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfcmFuZ2UgPSB0cnVlYFxuXG4gIGF0dHJfcmVhZGVyIDpiZWdpbiwgOmVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcIidpbml0aWFsaXplJyBjYWxsZWQgdHdpY2VcIiBpZiBAYmVnaW5cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYmFkIHZhbHVlIGZvciByYW5nZScgdW5sZXNzIGZpcnN0IDw9PiBsYXN0XG5cbiAgICBAYmVnaW4gPSBmaXJzdFxuICAgIEBlbmQgICA9IGxhc3RcbiAgICBAZXhjbCAgPSBleGNsdWRlXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmV4Y2wgID09PSBvdGhlci5leGNsICYmXG4gICAgICAgICAgICAgc2VsZi5iZWdpbiA9PSAgb3RoZXIuYmVnaW4gJiZcbiAgICAgICAgICAgICBzZWxmLmVuZCAgID09ICBvdGhlci5lbmQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4gPD0+IHZhbHVlKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgYmVnX2NtcCAmJiBiZWdfY21wIDw9IDBcbiAgICBlbmRfY21wID0gKHZhbHVlIDw9PiBAZW5kKVxuICAgIGlmIEBleGNsXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPCAwXG4gICAgZWxzZVxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDw9IDBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsaW1pdDtcblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX251bWJlciAmJiAje0BlbmR9LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmICgje0BiZWdpbn0gJSAxICE9PSAwIHx8ICN7QGVuZH0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tIEZsb2F0XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAje0BiZWdpbn0sIGxpbWl0ID0gI3tAZW5kfSArICN7QGV4Y2wgPyAwIDogMX07IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgYmxvY2soaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7QGJlZ2luLnVwdG8oQGVuZCwgQGV4Y2wsICZibG9jayl9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQgPSBAYmVnaW5cbiAgICBsYXN0ICAgID0gQGVuZFxuXG4gICAgdW5sZXNzIGN1cnJlbnQucmVzcG9uZF90bz8oOnN1Y2MpXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tICN7Y3VycmVudC5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgd2hpbGUgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgIEBleGNsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChuID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBAYmVnaW4gaWYgYG4gPT0gbnVsbGBcbiAgICBzdXBlclxuICBlbmRcblxuICBhbGlhcyBpbmNsdWRlPyBjb3Zlcj9cblxuICBkZWYgbGFzdChuID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBAZW5kIGlmIGBuID09IG51bGxgXG4gICAgdG9fYS5sYXN0KG4pXG4gIGVuZFxuXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXG4gIGRlZiBtYXhcbiAgICBpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgQGJlZ2luID4gQGVuZFxuICAgICAgbmlsXG4gICAgZWxzaWYgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmRcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBjb3Zlcj9cblxuICBkZWYgbWluXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBzdXBlclxuICAgIGVsc2lmIEBiZWdpbiA+IEBlbmRcbiAgICAgIG5pbFxuICAgIGVsc2lmIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kXG4gICAgICBuaWxcbiAgICBlbHNlXG4gICAgICBAYmVnaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIG5pbCB1bmxlc3MgTnVtZXJpYyA9PT0gcmFuZ2VfYmVnaW4gJiYgTnVtZXJpYyA9PT0gcmFuZ2VfZW5kXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cbiAgICBpbmZpbml0eSA9IEZsb2F0OjpJTkZJTklUWVxuICAgIHJldHVybiBpbmZpbml0eSBpZiBbcmFuZ2VfYmVnaW4uYWJzLCByYW5nZV9lbmQuYWJzXS5pbmNsdWRlPyhpbmZpbml0eSlcblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSAxKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAje0Zsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAleHtcbiAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2lufSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbi5pbnNwZWN0fSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBiZWdpbiIsInJhaXNlIiwiZmlyc3QiLCI8PT4iLCJsYXN0IiwiQGVuZCIsIkBleGNsIiwiZXhjbHVkZSIsIj09IiwiPT09IiwiaW5jbHVkZT8iLCJ2YWx1ZSIsImNvdmVyPyIsImJlZ19jbXAiLCI8PSIsIjAiLCJlbmRfY21wIiwiPCIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIjEiLCJ1cHRvIiwiYmxvY2siLCJjdXJyZW50IiwicmVzcG9uZF90bz8iLCJzdWNjIiwiISIsInNlbGYiLCJlcWw/Iiwib3RoZXIiLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsInRvX2EiLCJuIiwibWF4IiwiPiIsIm1pbiIsInNpemUiLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJpbmZpbml0eSIsImFicyIsInRvX2kiLCJzdGVwIiwiY29lcmNlX3RvISIsIi8iLCJjZWlsIiwiaSIsImxvb3AiLCIrIiwiKiIsIj49IiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJ0b19zIiwiaW5zcGVjdCIsIm1hcnNoYWxfbG9hZCIsImFyZ3MiLCJbXSIsImhhc2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFB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QSxDQUFLLE9BQUxBLENBQVQ7QUFBQSxNQUNBMUQsV0FBT3lELElBQUFDLE9BQUFBLENBQUssS0FBTEEsQ0FEUDtBQUFBLE1BRUEsT0FBQXpELENBQUFBLFlBQVF3RCxJQUFBQyxPQUFBQSxDQUFLLE1BQUxBLENBQVJ6RCxDQUZBO0FBREZ1RCxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0E1UEE7QUFBQSxJQWtRQSxPQUFBRyxDQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLENBQUNoRSxVQUFELEVBQVNLLFFBQVQsRUFBZUMsU0FBZixDQUFBMEQsTUFBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBQUFBLGdCQWxRQTtBQURGcEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3NTY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrIiwicmFpc2UiLCJjYWxsIiwidG9fcHJvYyIsImxhbWJkYT8iLCJhcml0eSIsInNvdXJjZV9sb2NhdGlvbiIsImJpbmRpbmciLCJw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QUFTLFFBQWhDSyxDQUF5QztBQUMzRDtBQUNBLGNBQVlULE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsS0FBL0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUE4QyxXQUE5QyxDQUFBLEdBQUEsR0FBckJBO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsTUFBL0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUErQyxLQUEvQyxDQUFBLEdBQUEsR0FBckJBO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBeEpBO0FBa0hFUSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FoSEE7QUFBQTtBQXlKQUUsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWRFQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0F6SkE7QUFBQSxJQTBLQSxPQUFBLGlCQUFNLE9BQU4sRUFBWSxLQUFaLENBMUtBO0FBREZkLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWMsUUFBZEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzc4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWV0aG9kLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE1ldGhvZFxuICBhdHRyX3JlYWRlciA6b3duZXIsIDpyZWNlaXZlciwgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShyZWNlaXZlciwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBvd25lciAgICA9IG93bmVyXG4gICAgQG5hbWUgICAgID0gbmFtZVxuICAgIEBtZXRob2QgICA9IG1ldGhvZFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICBAbWV0aG9kLmFyaXR5XG4gIGVuZFxuXG4gIGRlZiBwYXJhbWV0ZXJzXG4gICAgYCN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzYFxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYCN7QG1ldGhvZH0uJCRzb3VyY2VfbG9jYXRpb25gIHx8IFsnKGV2YWwpJywgMF1cbiAgZW5kXG5cbiAgZGVmIGNvbW1lbnRzXG4gICAgYCN7QG1ldGhvZH0uJCRjb21tZW50c2AgfHwgW11cbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgICN7QG1ldGhvZH0uJCRwID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiAje0BtZXRob2R9LmFwcGx5KCN7QHJlY2VpdmVyfSwgYXJncyk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBbXSBjYWxsXG5cbiAgZGVmIHVuYmluZFxuICAgIFVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7TWV0aG9kLm5ldyhvYmplY3QsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJAb3duZXIiLCJvd25lciIsIkBuYW1lIiwibmFtZSIsIkBtZXRob2QiLCJtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIwIiwiY29tbWVudHMiLCJjYWxsIiwidW5iaW5kIiwibmV3IiwidG9fcHJvYyIsImluc3BlY3QiLCJzZWxmIiwiam9pbiIsIkBzb3VyY2UiLCJzb3VyY2UiLCJiaW5kIiwib2JqZWN0IiwicmFpc2UiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxhQUFBQSxDQUFZLFNBQVEsWUFBVyxNQUEvQkEsQ0FBQTtBQUFBO0FBRUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWUsUUFBRCxFQUFXLEtBQVgsRUFBa0IsTUFBbEIsRUFBMEIsSUFBeENBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLGdCQUFZQyxRQUFaO0FBQUEsTUFDQUMsYUFBWUMsS0FEWjtBQUFBLE1BRUFDLFlBQVlDLElBRlo7QUFBQSxNQUdBLE9BQUFDLENBQUFBLGNBQVlDLE1BQVpELENBSEE7QUFERlAsSUFBQUEsQ0FBQUEsa0NBQUFBLENBRkE7QUFBQTtBQVNBUyxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBRixXQUFBRSxPQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FUQTtBQUFBO0FBYUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUdILFdBQVE7QUFEYkcsSUFBQUEsQ0FBQUEsa0NBQUFB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R0FBQSxLQUFpRVEsaUJBQUFBLENBQUFBLENBQUFTLE1BQUFBLENBQXFCLEdBQXJCQSxDQUFqRSxDQUFBLEdBQUE7QUFERkYsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLG1CQXBDQTtBQURGcEIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0F4REE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzkzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgcmVnZXhwIG1hdGNoZXNcbiV4eyRndmFyc1snJiddID0gJGd2YXJzWyd+J10gPSAkZ3ZhcnNbJ2AnXSA9ICRndmFyc1tcIidcIl0gPSBuaWx9XG5cbiMgcmVxdWlyZXNcbiRMT0FERURfRkVBVFVSRVMgPSAkXCIgPSBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgXG4kTE9BRF9QQVRIICAgICAgID0gJDogPSBbXVxuXG4jIHNwbGl0IGxpbmVzXG4kLyA9IFwiXFxuXCJcbiQsID0gbmlsXG5cbkFSR1YgPSBbXVxuQVJHRiA9IE9iamVjdC5uZXdcbkVOViAgPSB7fVxuXG4kVkVSQk9TRSA9IGZhbHNlXG4kREVCVUcgICA9IGZhbHNlXG4kU0FGRSAgICA9IDBcbiJdLCJuYW1lcyI6WyIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxFQUFHLDJEQUFIO0FBQUEsRUFHQUEseUJBQW1CQyxDQUFBQSxlQUFNLG9CQUFOQSxDQUhuQjtBQUFBLEVBSUFDLG1CQUFtQkMsQ0FBQUEsY0FBSyxFQUFMQSxDQUpuQjtBQUFBLEVBT0FDLGNBQUssSUFQTDtBQUFBLEVBUUFDLGNBQUssR0FSTDtBQUFBLEVBVUEsb0NBQU8sRUFBUCxDQVZBO0FBQUEsRUFXQSxvQ0FBTyxzQkFBQUMsS0FBQUEsQ0FBQUEsQ0FBUCxDQVhBO0FBQUEsRUFZQSxtQ0FBTyxZQUFBLEVBQVAsQ0FaQTtBQUFBLEVBY0FDLGlCQUFXLEtBZFg7QUFBQSxFQWVBQyxlQUFXLEtBZlg7QUFBQSxFQWdCQSxPQUFBQyxDQUFBQSxjQUFXQyxDQUFYRCxDQWhCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3OTU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIElOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIENPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje1JFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI9PSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSw0Q0FBZSxhQUFBLElBQUEsMkJBQUFDLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBZixDQUFBO0FBQUEsSUFDQSwwQ0FBYSxhQUFBLElBQUEsMkJBQUFBLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBYixDQURBO0FBQUEsSUFVQSxtRUFBc0MscUVBQXRDLENBVkE7QUFBQSxJQXNCQSxpRUFBc0MsMkZBQXRDLENBdEJBO0FBQUEsSUF1QkEsd0RBQTJCLHNCQUFBQyxLQUFBQSxDQUFXLEVBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBSyxtREFBTCxDQUFBLEdBQUEsTUFBQSxHQUFBLENBQStDLGlEQUEvQyxDQUFBLEdBQUEsR0FBWEEsQ0FBM0IsQ0F2QkE7QUFBQSxJQTJCQSwwREFBNkIsMkZBQTdCLENBM0JBO0FBQUEsSUE0QkEsaURBQW9CLHNCQUFBQSxLQUFBQSxDQUFXLEVBQUEsR0FBQSxDQUFHLDRCQUFILENBQUEsR0FBQSxjQUFBLEdBQUEsQ0FBOEIsMENBQTlCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBNkQsMEJBQTdELENBQVhBLENBQXBCLENBNUJBO0FBREZGLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTc5ODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmkucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbC9iYXNlJ1xuXG5yZXF1aXJlICdjb3JlbGliL25pbCdcbnJlcXVpcmUgJ2NvcmVsaWIvYm9vbGVhbidcbnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhdG9yJ1xucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcbnJlcXVpcmUgJ2NvcmVsaWIvaGFzaCdcbnJlcXVpcmUgJ2NvcmVsaWIvbnVtYmVyJ1xucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcHJvYydcbnJlcXVpcmUgJ2NvcmVsaWIvbWV0aG9kJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdmFyaWFibGVzJ1xucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLGFBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsb0JBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLG9CQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGVBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGNBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWJBO0FBQUEsTUFjQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FkQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQWhCQTtBQUFBLEVBaUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBakJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTgwMTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEtlcm5lbFxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnc1swXS5yZXNwb25kX3RvPyg6dG9fYXJ5KVxuICAgICAgYXJ5ID0gT3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIEFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHdpZHRoJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTlRIX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSBhcmdzLmxlbmd0aCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn1cbiAgICAgICAgY2FzZSAtMjogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gc2VxX2FyZ19udW0rKztcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xuICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGluZGV4IC0gI3tgbnVtYH0kXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSAtMTtcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKG51bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfQVJHKCkge1xuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcbiAgICAgICAgdmFyIG51bSwgc3RyID0gJyc7XG4gICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXRfc2VxdWVuY2U6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTSEFSUDtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGUExVUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlpFUk87XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgIHRtcF9udW0gPSBSRUFEX05VTSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3tJbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAje0Zsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAje3JhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdgQWAgYW5kIGBhYCBmb3JtYXQgZmllbGQgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiBPcGFsIHlldCd9XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCN7T3BhbC5jb2VyY2VfdG8oYGFyZ2AsIEludGVnZXIsIDp0b19pbnQpfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICclYyByZXF1aXJlcyBhIGNoYXJhY3Rlcid9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLmluc3BlY3R9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAudG9fc307XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcbiAgICAgICAgYmVnaW5fc2xpY2UgPSBpICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JERFQlVHfSAmJiBwb3NfYXJnX251bSA+PSAwICYmIHNlcV9hcmdfbnVtIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgYXJndW1lbnRzIGZvciBmb3JtYXQgc3RyaW5nJ31cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3ByaW50ZiBmb3JtYXRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImZvcm1hdCIsImFyZ3MiLCJsZW5ndGgiLCI9PSIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsImNvZXJjZV90bz8iLCJuaWw/IiwidG9fYSIsInJhaXNlIiwidG9faW50IiwiZmV0Y2giLCJJbnRlZ2VyIiwiRmxvYXQiLCJ0b19hcnkiLCJ0b19zdHIiLCJjb2VyY2VfdG8iLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBVyxhQUFELEVBRlosRUFFRUE7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBRkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFFNEIsTUFBQSxrQkFGNUI7QUFBQSxNQUdJLElBQUEsUUFBRyxPQUFBQyxJQUFBQyxRQUFBQSxDQUFBQSxD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QTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JHLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JBLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFvQkMsT0FBQUEsQ0FBTyxTQUFQQSxDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFjSixPQUFBQSxDQUFNLHFDQUFxQixnRUFBM0JBOztBQUVkO0FBQ0E7QUFDQSxnQkFBa0IsQ0FBQyxHQUFELENBQUFMLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkIsVUFBWSxDQUFDLEdBQUQsQ0FBQVUsUUFBQUEsQ0FBQUEsQ0FBYTtBQUN0RSxnQkFBa0IsQ0FBQyxHQUFELENBQUFWLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkI7QUFDN0Msb0JBQXNCLENBQUMsR0FBRCxDQUFBVyxRQUFBQSxDQUFBQSxDQUFhO0FBQ25DO0FBQ0Esd0NBQTBDLG9CQUFBQyxXQUFBQSxDQUFnQixLQUFNLHlCQUFTLFFBQS9CQSxDQUF3QztBQUNsRjtBQUNBO0FBQ0Esa0JBQWdCUCxPQUFBQSxDQUFNLCtCQUFlLHlCQUFyQkE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBb0IsQ0FBQyxTQUFELENBQUFRLFNBQUFBLENBQUFBLENBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQW9CLENBQUMsU0FBRCxDQUFBQyxNQUFBQSxDQUFBQSxDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFjVCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCLHVCQUEvQixDQUFyQkE7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSw2QkFBckJBO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVlVLFlBQU87QUFDbkIsWUFBVVYsT0FBQUEsQ0FBTSwrQkFBZSxzQ0FBckJBO0FBQ1Y7O0FBRUE7QUFDQSxJQTVoQkE7QUFFRVosSUFBQUEsQ0FBQUEsK0JBQUFBLENBQUE7QUFBQSxJQTZoQkEsaUJBQU0sU0FBTixFQUFjLFFBQWQsQ0E3aEJBO0FBREZELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg1NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3N0cmluZydcblxuY2xhc3MgRW5jb2RpbmdcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZiwgJyQkcmVnaXN0ZXInLCB7fSlgXG5cbiAgZGVmIHNlbGYucmVnaXN0ZXIobmFtZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgbmFtZXMgICAgPSBbbmFtZV0gKyAob3B0aW9uc1s6YWxpYXNlc10gfHwgW10pXG4gICAgZW5jb2RpbmcgPSBDbGFzcy5uZXcoc2VsZiwgJmJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAubmV3KG5hbWUsIG5hbWVzLCBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2UsIG9wdGlvbnNbOmR1bW15XSB8fCBmYWxzZSlcblxuICAgIHJlZ2lzdGVyID0gc2VsZi5KU1snJCRyZWdpc3RlciddXG4gICAgbmFtZXMuZWFjaCBkbyB8ZW5jb2RpbmdfbmFtZXxcbiAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnN1YignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tcIiQkI3tlbmNvZGluZ19uYW1lfVwiXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgcmVnaXN0ZXIgPSBzZWxmLkpTWyckJHJlZ2lzdGVyJ11cbiAgICBlbmNvZGluZyA9IHJlZ2lzdGVyLkpTW1wiJCQje25hbWV9XCJdIHx8IHJlZ2lzdGVyLkpTW1wiJCQje25hbWUudXBjYXNlfVwiXVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gI3tuYW1lfVwiIHVubGVzcyBlbmNvZGluZ1xuICAgIGVuY29kaW5nXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6bmFtZXNcblxuICBkZWYgaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIEBuYW1lICA9IG5hbWVcbiAgICBAbmFtZXMgPSBuYW1lc1xuICAgIEBhc2NpaSA9IGFzY2lpXG4gICAgQGR1bW15ID0gZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX2NvbXBhdGlibGU/XG4gICAgQGFzY2lpXG4gIGVuZFxuXG4gIGRlZiBkdW1teT9cbiAgICBAZHVtbXlcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBAbmFtZVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXG4gIGVuZFxuXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXG4gIGRlZiBlYWNoX2J5dGUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNvZGUgPD0gMHg3Zikge1xuICAgICAgICAgICN7eWllbGQgYGNvZGVgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBlbmNvZGVkX2xlbmd0aCA9IGVuY29kZWQubGVuZ3RoOyBqIDwgZW5jb2RlZF9sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgI3t5aWVsZCBgcGFyc2VJbnQoZW5jb2RlZFtqXSwgMTYpYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBzdHJpbmcuYnl0ZXMubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyTEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ0FTQ0lJLThCSVQnLCBhbGlhc2VzOiBbJ0JJTkFSWScsICdVUy1BU0NJSScsICdBU0NJSSddLCBhc2NpaTogdHJ1ZSwgZHVtbXk6IHRydWUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGF0dHJfcmVhZGVyIDplbmNvZGluZ1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfMTZMRX0pYFxuXG4gIGRlZiBieXRlc1xuICAgIGVhY2hfYnl0ZS50b19hXG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZVxuICAgIEBlbmNvZGluZy5ieXRlc2l6ZShzZWxmKVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfYnl0ZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGR1cC5mb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgZW5kXG5cbiAgZGVmIGZvcmNlX2VuY29kaW5nKGVuY29kaW5nKVxuICAgICV4e1xuICAgICAgaWYgKGVuY29kaW5nID09PSBzZWxmLmVuY29kaW5nKSB7IHJldHVybiBzZWxmOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3tPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIFN0cmluZywgOnRvX3MpfTtcbiAgICAgIGVuY29kaW5nID0gI3tFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc2VsZi5lbmNvZGluZykgeyByZXR1cm4gc2VsZjsgfVxuXG4gICAgICBzZWxmLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKGlkeClcbiAgICBAZW5jb2RpbmcuZ2V0Ynl0ZShzZWxmLCBpZHgpXG4gIGVuZFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsInJlZ2lzdGVyIiwic2VsZiIsIm5hbWVzIiwiKyIsIm5hbWUiLCJvcHRpb25zIiwiW10iLCJlbmNvZGluZyIsIm5ldyIsImJsb2NrIiwiZWFjaCIsImNvbnN0X3NldCIsImVuY29kaW5nX25hbWUiLCJzdWIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwidXBjYXNlIiwicmFpc2UiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJhc2NpaSIsIkBkdW1teSIsImR1bW15IiwiYXNjaWlfY29tcGF0aWJsZT8iLCJkdW1teT8iLCJ0b19zIiwiaW5zcGVjdCIsImVhY2hfYnl0ZSIsImdldGJ5dGUiLCJieXRlc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwibGVuZ3RoIiwidG9fYSIsIkBlbmNvZGluZyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZWFjaF9jb2RlcG9pbnQiLCJjb2RlcG9pbnRzIiwiZW5jb2RlIiwiZHVwIiwiZm9yY2VfZW5jb2RpbmciLCJjb2VyY2VfdG8hIiwiaWR4IiwidmFsaWRfZW5jb2Rpbmc/Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLElBQUMsMkNBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxlQUFBQSx1QkFBQUEsb0JBQWtCLElBQUQsRUFBTyxPQUF4QkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBTkY7QUFNd0MsTUFBQSwyQ0FOeEM7QUFBQTtBQU0wQixNQUFBO0FBQUEsTUFBQSxZQUFVLFlBQUEsRUFBVjtBQUFBLE1BQUEsQ0FOMUI7QUFBQSxNQU9JRSxRQUFXQyxTQUFBLENBQUNDLElBQUQsQ0FBQUQsRUFBVSxjQUFBRSxPQUFBQyxPQUFBQSxDQUFRLFNBQVJBLENBQUEsU0FBcUIsRUFBckIsQ0FBVkgsQ0FQZjtBQUFBLE1BUUlJLFdBQVdDLE1BQUEscUJBQUFBLE9BQUFBLEVBQUFBLENBQVVQLElBQVZPLENBQUFBLEVBQWlCQyxnQkFBakJELENBQUFBLEtBQUFB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YXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBNYXRoXG4gIEUgID0gYE1hdGguRWBcbiAgUEkgPSBgTWF0aC5QSWBcblxuICBEb21haW5FcnJvciA9IENsYXNzLm5ldyhTdGFuZGFyZEVycm9yKVxuXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCAoYXJncy5sZW5ndGggPT0gMiAmJiBpc05hTihhcmdzWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgI3tyYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmxvYXQhKHZhbHVlKVxuICAgIEZsb2F0KHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcih2YWx1ZSwgRmxvYXQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIEludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSBBcmd1bWVudEVycm9yXG4gICAgcmFpc2UgT3BhbC50eXBlX2Vycm9yKHZhbHVlLCBJbnRlZ2VyKVxuICBlbmRcblxuICBtb2R1bGVfZnVuY3Rpb25cblxuICBkZWYgYWNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6YWNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFjb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguYWNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGFzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmFzaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphc2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhdGFuMih5LCB4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbjIsIE1hdGguZmxvYXQhKHkpLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYXRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5hdGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdGFuaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jYnJ0YClcbiAgICAleHtcbiAgICAgIE1hdGguY2JydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC1NYXRoLmNicnQoLXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgID0geCxcbiAgICAgICAgICAgIGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAociA8IDAuMTI1KSB7XG4gICAgICAgICAgciAqPSA4O1xuICAgICAgICAgIGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAociA+IDEuMCkge1xuICAgICAgICAgIHIgKj0gMC4xMjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoLTAuNDY5NDYxMTYgKiByICsgMS4wNzIzMDIpICogciArIDAuMzgxMjUxMztcblxuICAgICAgICB3aGlsZSAoZXggPCAwKSB7XG4gICAgICAgICAgciAqPSAwLjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChleCA+IDApIHtcbiAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNicnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNicnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBjb3MoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5jb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29zaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXG4gICAgJXh7XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmYsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZjYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmYyh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXJmYywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGV4cCh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXhwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZnJleHAoeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ICAgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHgpKSAvIE1hdGgubG9nKDIpKSArIDEsXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XG5cbiAgICAgIHJldHVybiBbZnJhYywgZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdhbW1hKG4pXG4gICAgbiA9IE1hdGguZmxvYXQhKG4pXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCB0LCB4LCB2YWx1ZSwgcmVzdWx0LCB0d29OLCB0aHJlZU4sIGZvdXJOLCBmaXZlTjtcblxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XG5cbiAgICAgIHZhciBQID0gW1xuICAgICAgICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICAgICAgIDU3LjE1NjIzNTY2NTg2MjkyMzUxNyxcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAgICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCxcbiAgICAgICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAgICAgICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAgICAgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgICAgICAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAgICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgICAgICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAgICAgLTAuMjYxOTA4Mzg0MDE1ODE0MDg2NzBlLTQsXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG4gICAgICBdO1xuXG5cbiAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAje3JhaXNlIERvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImdhbW1hXCInfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7SW50ZWdlciA9PT0gbn0pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IEluZmluaXR5IDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPiAxNzEpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAgPSBuIC0gMjtcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7TWF0aC5nYW1tYSgxIC0gbil9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPj0gMTcxLjM1KSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPiA4NS4wKSB7XG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xuICAgICAgICB0aHJlZU4gPSB0d29OICogbjtcbiAgICAgICAgZm91ck4gID0gdGhyZWVOICogbjtcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBuKSAqIE1hdGgucG93KChuIC8gTWF0aC5FKSwgbikgKlxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxuICAgICAgICAgIDU3MSAvICgyNDg4MzIwICogZm91ck4pICsgMTYzODc5IC8gKDIwOTAxODg4MCAqIGZpdmVOKSArXG4gICAgICAgICAgNTI0NjgxOSAvICg3NTI0Njc5NjgwMCAqIGZpdmVOICogbikpO1xuICAgICAgfVxuXG4gICAgICBuIC09IDE7XG4gICAgICB4ICA9IFBbMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBQLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHQgPSBuICsgRyArIDAuNTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLnBvdyh0LCBuICsgMC41KSAqIE1hdGguZXhwKC10KSAqIHg7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguaHlwb3RgKVxuICAgICV4e1xuICAgICAgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgTWF0aC5jaGVja2VkIDpoeXBvdCwgTWF0aC5mbG9hdCEoeCksIE1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBsZGV4cChtYW50aXNzYSwgZXhwb25lbnQpXG4gICAgbWFudGlzc2EgPSBNYXRoLmZsb2F0IShtYW50aXNzYSlcbiAgICBleHBvbmVudCA9IE1hdGguaW50ZWdlciEoZXhwb25lbnQpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTihleHBvbmVudCkpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZ2FtbWEobilcbiAgICAleHtcbiAgICAgIGlmIChuID09IC0xKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDFdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5sb2coTWF0aC5hYnMoI3tNYXRoLmdhbW1hKG4pfSkpLCAje01hdGguZ2FtbWEobil9IDwgMCA/IC0xIDogMV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nKHgsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBPcGFsLnR5cGVfZXJyb3IoeCwgRmxvYXQpXG4gICAgZW5kXG5cbiAgICBpZiBgYmFzZSA9PSBudWxsYFxuICAgICAgTWF0aC5jaGVja2VkIDpsb2csIE1hdGguZmxvYXQhKHgpXG4gICAgZWxzZVxuICAgICAgaWYgU3RyaW5nID09PSBiYXNlXG4gICAgICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcihiYXNlLCBGbG9hdClcbiAgICAgIGVuZFxuXG4gICAgICBNYXRoLmNoZWNrZWQoOmxvZywgTWF0aC5mbG9hdCEoeCkpIC8gTWF0aC5jaGVja2VkKDpsb2csIE1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMTBgKVxuICAgICV4e1xuICAgICAgTWF0aC5sb2cxMCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzEwKHgpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBPcGFsLnR5cGVfZXJyb3IoeCwgRmxvYXQpXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzEwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMmApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzIgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcih4LCBGbG9hdClcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDpzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgc3FydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c3FydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiBGbG9hdDo6TkFOXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOnRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC50YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRhbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOnRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwibmV3IiwiY2hlY2tlZCIsInNlbGYiLCJyYWlzZSIsIm1ldGhvZCIsImZsb2F0ISIsIkZsb2F0IiwidmFsdWUiLCJ0eXBlX2Vycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiYWNvcyIsIngiLCJhY29zaCIsImFzaW4iLCJhc2luaCIsImF0YW4iLCJhdGFuMiIsInkiLCJhdGFuaCIsImNicnQiLCJjb3MiLCJjb3NoIiwiZXJmIiwiZXJmYyIsImV4cCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJoeXBvdCIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsImxnYW1tYSIsImxvZyIsImJhc2UiLCIvIiwibG9nMTAiLCJsb2cyIiwic2luIiwic2luaCIsInNxcnQiLCJ0YW4iLCJpbmZpbml0ZT8iLCJ0YW5oIl0s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LENBQUFBLDBCQUFBQSxDQW5iQTtBQUFBLElBNmJBLElBQUEsUUFBTyxRQUFVLFNBQVYsa0JBQVAsQ0FBQTtBQUFBLElBQUE7QUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJFLElBQUEsQ0E3YkE7QUFBQTtBQTZjQUUsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBUyxDQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLG9CQUFBL0MsU0FBQUEsQ0FBYSxRQUFPLG9CQUFBSSxXQUFBQSxDQUFZUSxDQUFaUixDQUFwQko7QUFERitDLElBQUFBLENBQUFBLDJCQUFBQSxDQTdjQTtBQURGakQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTUwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIENvbXBsZXggPCBOdW1lcmljXG4gIGRlZiBzZWxmLnJlY3QocmVhbCwgaW1hZyA9IDApXG4gICAgdW5sZXNzIE51bWVyaWMgPT09IHJlYWwgJiYgcmVhbC5yZWFsPyAmJiBOdW1lcmljID09PSBpbWFnICYmIGltYWcucmVhbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcocmVhbCwgaW1hZylcbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcbiAgZW5kXG5cbiAgZGVmIHNlbGYucG9sYXIociwgdGhldGEgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByICYmIHIucmVhbD8gJiYgTnVtZXJpYyA9PT0gdGhldGEgJiYgdGhldGEucmVhbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSlcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJlYWwsIDppbWFnXG5cbiAgZGVmIGluaXRpYWxpemUocmVhbCwgaW1hZyA9IDApXG4gICAgQHJlYWwgPSByZWFsXG4gICAgQGltYWcgPSBpbWFnXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIFtvdGhlciwgc2VsZl1cbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgW0NvbXBsZXgubmV3KG90aGVyLCAwKSwgc2VsZl1cbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIEByZWFsID09IG90aGVyLnJlYWwgJiYgQGltYWcgPT0gb3RoZXIuaW1hZ1xuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBAcmVhbCA9PSBvdGhlciAmJiBAaW1hZyA9PSAwXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBDb21wbGV4KC1AcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCArIG90aGVyLnJlYWwsIEBpbWFnICsgb3RoZXIuaW1hZylcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCArIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgLSBvdGhlci5yZWFsLCBAaW1hZyAtIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgLSBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsICogb3RoZXIucmVhbCAtIEBpbWFnICogb3RoZXIuaW1hZyxcbiAgICAgICAgQHJlYWwgKiBvdGhlci5pbWFnICsgQGltYWcgKiBvdGhlci5yZWFsLFxuICAgICAgKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsICogb3RoZXIsIEBpbWFnICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBpZiAoTnVtYmVyID09PSBAcmVhbCAmJiBAcmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fFxuICAgICAgICAgKE51bWJlciA9PT0gb3RoZXIucmVhbCAmJiBvdGhlci5yZWFsLm5hbj8pIHx8IChOdW1iZXIgPT09IG90aGVyLmltYWcgJiYgb3RoZXIuaW1hZy5uYW4/KVxuICAgICAgICBDb21wbGV4Lm5ldyhGbG9hdDo6TkFOLCBGbG9hdDo6TkFOKVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmICogb3RoZXIuY29uaiAvIG90aGVyLmFiczJcbiAgICAgIGVuZFxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsLnF1byhvdGhlciksIEBpbWFnLnF1byhvdGhlcikpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBpZiBvdGhlciA9PSAwXG4gICAgICByZXR1cm4gQ29tcGxleC5uZXcoMSwgMClcbiAgICBlbmRcblxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG4gICAgICBvcmUgICAgICA9IG90aGVyLnJlYWxcbiAgICAgIG9pbSAgICAgID0gb3RoZXIuaW1hZ1xuICAgICAgbnIgICAgICAgPSBNYXRoLmV4cChvcmUgKiBNYXRoLmxvZyhyKSAtIG9pbSAqIHRoZXRhKVxuICAgICAgbnRoZXRhICAgPSB0aGV0YSAqIG9yZSArIG9pbSAqIE1hdGgubG9nKHIpXG5cbiAgICAgIENvbXBsZXgucG9sYXIobnIsIG50aGV0YSlcbiAgICBlbHNpZiBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgb3RoZXIgPiAwXG4gICAgICAgIHggPSBzZWxmXG4gICAgICAgIHogPSB4XG4gICAgICAgIG4gPSBvdGhlciAtIDFcblxuICAgICAgICB3aGlsZSBuICE9IDBcbiAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgd2hpbGUgbW9kID09IDBcbiAgICAgICAgICAgIHggPSBDb21wbGV4KHgucmVhbCAqIHgucmVhbCAtIHguaW1hZyAqIHguaW1hZywgMiAqIHgucmVhbCAqIHguaW1hZylcbiAgICAgICAgICAgIG4gPSBkaXZcbiAgICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHogKj0geFxuICAgICAgICAgIG4gLT0gMVxuICAgICAgICBlbmRcblxuICAgICAgICB6XG4gICAgICBlbHNlXG4gICAgICAgIChSYXRpb25hbC5uZXcoMSwgMSkgLyBzZWxmKSoqLW90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG5cbiAgICAgIENvbXBsZXgucG9sYXIocioqb3RoZXIsIHRoZXRhICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgTWF0aC5oeXBvdChAcmVhbCwgQGltYWcpXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgQHJlYWwgKiBAcmVhbCArIEBpbWFnICogQGltYWdcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgTWF0aC5hdGFuMihAaW1hZywgQHJlYWwpXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuXG4gIGRlZiBjb25qXG4gICAgQ29tcGxleChAcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEByZWFsLmRlbm9taW5hdG9yLmxjbShAaW1hZy5kZW5vbWluYXRvcilcbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBDb21wbGV4ID09PSBvdGhlciAmJiBAcmVhbC5jbGFzcyA9PSBAaW1hZy5jbGFzcyAmJiBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHVubGVzcyBOdW1lcmljID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcblxuICAgIHNlbGYgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIEByZWFsLmZpbml0ZT8gJiYgQGltYWcuZmluaXRlP1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiQ29tcGxleDoje0ByZWFsfToje0BpbWFnfVwiXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIEByZWFsLmluZmluaXRlPyB8fCBAaW1hZy5pbmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICB1bmRlZiBuZWdhdGl2ZT9cblxuICBkZWYgbnVtZXJhdG9yXG4gICAgZCA9IGRlbm9taW5hdG9yXG5cbiAgICBDb21wbGV4KEByZWFsLm51bWVyYXRvciAqIChkIC8gQHJlYWwuZGVub21pbmF0b3IpLFxuICAgICAgQGltYWcubnVtZXJhdG9yICogKGQgLyBAaW1hZy5kZW5vbWluYXRvciksXG4gICAgKVxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIHVuZGVmIHBvc2l0aXZlP1xuXG4gIGFsaWFzIHF1byAvXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBAaW1hZyAhPSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0JyBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICByZWFsLnJhdGlvbmFsaXplKGVwcylcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbQHJlYWwsIEBpbWFnXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHRvX2ZcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBGbG9hdFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19mXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19pXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fclxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIHJlc3VsdCA9IEByZWFsLmluc3BlY3RcblxuICAgIHJlc3VsdCArPVxuICAgICAgaWYgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHwgQGltYWcucG9zaXRpdmU/IHx8IEBpbWFnLnplcm8/XG4gICAgICAgICcrJ1xuICAgICAgZWxzZVxuICAgICAgICAnLSdcbiAgICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IEBpbWFnLmFicy5pbnNwZWN0XG5cbiAgICBpZiBOdW1iZXIgPT09IEBpbWFnICYmIChAaW1hZy5uYW4/IHx8IEBpbWFnLmluZmluaXRlPylcbiAgICAgIHJlc3VsdCArPSAnKidcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICdpJ1xuICBlbmRcblxuICBJID0gbmV3KDAsIDEpXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgQ29tcGxleChyZWFsLCBpbWFnID0gbmlsKVxuICAgIGlmIGltYWdcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIGltYWcpXG4gICAgZWxzZVxuICAgICAgQ29tcGxleC5uZXcocmVhbCwgMClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b19jXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZixcbiAgICAgICAgICByZSA9IC9bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/KGVcXGQrKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICByZWFsLCBpbWFnLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGVzIGJvdGggZmxvYXRzIGFuZCByYXRpb25hbHNcbiAgICAgIGZ1bmN0aW9uIGN1dE51bWJlcigpIHtcbiAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gI3tSYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmV2ZXJ0aW5nICcvJ1xuICAgICAgICAgICAgICBzdHIgPSAnLycgKyBzdHI7XG4gICAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHJlYWwgcGFydCwgbm8gZGVub21pbmF0b3JcbiAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWwgPSBjdXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFyZWFsKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIGkgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICctJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vIC1pID0+IENvbXBsZXgoMCwgLTEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAtMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcrJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vICtpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyA9PiBDb21wbGV4KDAsIDApXG4gICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMCl9O1xuICAgICAgfVxuXG4gICAgICBpbWFnID0gY3V0TnVtYmVyKCk7XG4gICAgICBpZiAoIWltYWcpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gM2kgPT4gQ29tcGxleCgwLCAzKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgYHJlYWxgKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMyA9PiBDb21wbGV4KDMsIDApXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIDApfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMysyaSA9PiBDb21wbGV4KDMsIDIpXG4gICAgICAgIHJldHVybiAje0NvbXBsZXgoYHJlYWxgLCBgaW1hZ2ApfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVjdCIsInNlbGYiLCIwIiwiPT09IiwicmVhbCIsInJlYWw/IiwiaW1hZyIsInJhaXNlIiwibmV3IiwicG9sYXIiLCJyIiwidGhldGEiLCIqIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImNvZXJjZSIsIm90aGVyIiwiPT0iLCItQCIsIkNvbXBsZXgiLCIrIiwiX19jb2VyY2VkX18iLCItIiwiLyIsIm5hbj8iLCJjb25qIiwiYWJzMiIsInF1byIsIioqIiwiMSIsIm9yZSIsIm9pbSIsIm5yIiwiZXhwIiwibG9nIiwibnRoZXRhIiwiPiIsIngiLCJ6IiwibiIsIiE9IiwiZGl2bW9kIiwiMiIsImRpdiIsIm1vZCIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsImZkaXYiLCJmaW5pdGU/IiwiaGFzaCIsImluZmluaXRlPyIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJ0b19mIiwidG9faSIsInRvX3IiLCJ0b19zIiwicmVzdWx0IiwicG9zaXRpdmU/IiwiemVybz8iLCJtb2R1bGUiLCJ0b19jIiwiUmF0aW9uYWwiLCItMSJdLCJtYXBwaW5ncyI6Ijs7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXVCQyxVQUFBQSxDQUFVLFdBQWEsV0FBdkJBLENBQXFDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQnBELFNBQUFBLENBQVFyQixHQUFHK0IsQ0FBWFYsQ0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBbUJBLFNBQUFBLENBQVFyQixHQUFHMEUsRUFBWHJELENBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFRckIsR0FBRytCLENBQVhWLENBQWM7QUFDakM7QUFDQTtBQUNBLG1CQUFpQkEsU0FBQUEsQ0FBUXJCLEdBQUdBLENBQVhxQixDQUFjO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFRckIsR0FBSSxJQUFacUIsQ0FBbUI7QUFDdEM7QUFDQTtBQUNBLHFCQUFtQkEsU0FBQUEsQ0FBUyxNQUFPckIsQ0FBaEJxQixDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxtQkFBaUJBLFNBQUFBLENBQVMsTUFBUSxJQUFqQkEsQ0FBd0I7QUFDekM7QUFDQTtBQTVFRW1ELElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGM0UsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0EvU0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTk5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBSYXRpb25hbCA8IE51bWVyaWNcbiAgZGVmIHNlbGYucmVkdWNlKG51bSwgZGVuKVxuICAgIG51bSA9IG51bS50b19pXG4gICAgZGVuID0gZGVuLnRvX2lcblxuICAgIGlmIGRlbiA9PSAwXG4gICAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICBlbHNpZiBkZW4gPCAwXG4gICAgICBudW0gPSAtbnVtXG4gICAgICBkZW4gPSAtZGVuXG4gICAgZWxzaWYgZGVuID09IDFcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcblxuICAgIG5ldyhudW0gLyBnY2QsIGRlbiAvIGdjZClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29udmVydChudW0sIGRlbilcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgbmlsIGludG8gUmF0aW9uYWwnXG4gICAgZW5kXG5cbiAgICBpZiBJbnRlZ2VyID09PSBudW0gJiYgSW50ZWdlciA9PT0gZGVuXG4gICAgICByZXR1cm4gcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgaWYgRmxvYXQgPT09IG51bSB8fCBTdHJpbmcgPT09IG51bSB8fCBDb21wbGV4ID09PSBudW1cbiAgICAgIG51bSA9IG51bS50b19yXG4gICAgZW5kXG5cbiAgICBpZiBGbG9hdCA9PT0gZGVuIHx8IFN0cmluZyA9PT0gZGVuIHx8IENvbXBsZXggPT09IGRlblxuICAgICAgZGVuID0gZGVuLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIGRlbi5lcXVhbD8oMSkgJiYgIShJbnRlZ2VyID09PSBudW0pXG4gICAgICBPcGFsLmNvZXJjZV90byEobnVtLCBSYXRpb25hbCwgOnRvX3IpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gbnVtICYmIE51bWVyaWMgPT09IGRlblxuICAgICAgbnVtIC8gZGVuXG4gICAgZWxzZVxuICAgICAgcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShudW0sIGRlbilcbiAgICBAbnVtID0gbnVtXG4gICAgQGRlbiA9IGRlblxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgQG51bVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAZGVuXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIFtvdGhlciwgc2VsZl1cblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgW290aGVyLnRvX3IsIHNlbGZdXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICBbb3RoZXIsIHRvX2ZdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgQG51bSA9PSBvdGhlci5udW1lcmF0b3IgJiYgQGRlbiA9PSBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBAbnVtID09IG90aGVyICYmIEBkZW4gPT0gMVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiA9PSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yIDw9PiAwXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgPD0+IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6PD0+LCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtICsgb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiArIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSAtIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgKiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5udW1lcmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgdG9fZiAvIDAuMFxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbChAbnVtLCBAZGVuICogb3RoZXIpXG4gICAgICBlbmRcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzaWYgb3RoZXIgPiAwXG4gICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcbiAgICAgIGVsc2lmIG90aGVyIDwgMFxuICAgICAgICBSYXRpb25hbChAZGVuKiotb3RoZXIsIEBudW0qKi1vdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZioqb3RoZXJcblxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcbiAgICAgICAgaWYgb3RoZXIgPCAwXG4gICAgICAgICAgUmF0aW9uYWwoQGRlbioqb3RoZXIubnVtZXJhdG9yLmFicywgQG51bSoqb3RoZXIubnVtZXJhdG9yLmFicylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLm51bWVyYXRvciwgQGRlbioqb3RoZXIubnVtZXJhdG9yKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2YqKm90aGVyXG4gICAgICBlbmRcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIFJhdGlvbmFsKEBudW0uYWJzLCBAZGVuLmFicylcbiAgZW5kXG5cbiAgZGVmIGNlaWwocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpjZWlsLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGZsb29yKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJSYXRpb25hbDoje0BudW19OiN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgYWxpYXMgcXVvIC9cblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXBzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcbiAgICAgICAgICBhID0gI3tzZWxmIC0gYGVgfSxcbiAgICAgICAgICBiID0gI3tzZWxmICsgYGVgfTtcblxuICAgICAgdmFyIHAwID0gMCxcbiAgICAgICAgICBwMSA9IDEsXG4gICAgICAgICAgcTAgPSAxLFxuICAgICAgICAgIHExID0gMCxcbiAgICAgICAgICBwMiwgcTI7XG5cbiAgICAgIHZhciBjLCBrLCB0O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjID0gI3tgYWAuY2VpbH07XG5cbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGsgID0gYyAtIDE7XG4gICAgICAgIHAyID0gayAqIHAxICsgcDA7XG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XG4gICAgICAgIHQgID0gI3sxIC8gKGBiYCAtIGBrYCl9O1xuICAgICAgICBiICA9ICN7MSAvIChgYWAgLSBga2ApfTtcbiAgICAgICAgYSAgPSB0O1xuXG4gICAgICAgIHAwID0gcDE7XG4gICAgICAgIHEwID0gcTE7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHExID0gcTI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje1JhdGlvbmFsKGBjICogcDEgKyBwMGAsIGBjICogcTEgKyBxMGApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxuICAgIHJldHVybiB3aXRoX3ByZWNpc2lvbig6cm91bmQsIHByZWNpc2lvbikgdW5sZXNzIHByZWNpc2lvbiA9PSAwXG4gICAgcmV0dXJuIDAgaWYgQG51bSA9PSAwXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXG5cbiAgICBudW0gPSBAbnVtLmFicyAqIDIgKyBAZGVuXG4gICAgZGVuID0gQGRlbiAqIDJcblxuICAgIGFwcHJveCA9IChudW0gLyBkZW4pLnRydW5jYXRlXG5cbiAgICBpZiBAbnVtIDwgMFxuICAgICAgLWFwcHJveFxuICAgIGVsc2VcbiAgICAgIGFwcHJveFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW0gLyBAZGVuXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgQG51bSA8IDAgPyBjZWlsIDogZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6dHJ1bmNhdGUsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpdGhfcHJlY2lzaW9uKG1ldGhvZCwgcHJlY2lzaW9uKVxuICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBJbnRlZ2VyJyB1bmxlc3MgSW50ZWdlciA9PT0gcHJlY2lzaW9uXG5cbiAgICBwID0gMTAqKnByZWNpc2lvblxuICAgIHMgPSBzZWxmICogcFxuXG4gICAgaWYgcHJlY2lzaW9uIDwgMVxuICAgICAgKHMuc2VuZChtZXRob2QpIC8gcCkudG9faVxuICAgIGVsc2VcbiAgICAgIFJhdGlvbmFsKHMuc2VuZChtZXRob2QpLCBwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcbiAgICBSYXRpb25hbC5jb252ZXJ0KG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdG9fclxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYudHJpbUxlZnQoKSxcbiAgICAgICAgICByZSA9IC9eWystXT9bXFxkX10rKFxcLltcXGRfXSspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAje1JhdGlvbmFsKDAsIDEpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVkdWNlIiwic2VsZiIsIm51bSIsInRvX2kiLCJkZW4iLCI9PSIsIjAiLCJyYWlzZSIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIm5pbD8iLCI9PT0iLCJ0b19yIiwiZXF1YWw/IiwiISIsImNvZXJjZV90byEiLCJpbml0aWFsaXplIiwiQG51bSIsIkBkZW4iLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImNvZXJjZSIsIm90aGVyIiwidG9fZiIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiUmF0aW9uYWwiLCIqKiIsIj4iLCJhYnMiLCJjZWlsIiwicHJlY2lzaW9uIiwid2l0aF9wcmVjaXNpb24iLCJmbG9vciIsImhhc2giLCJpbnNwZWN0IiwicmF0aW9uYWxpemUiLCJlcHMiLCI8PSIsInJvdW5kIiwiMiIsImFwcHJveCIsInRydW5jYXRlIiwidG9fcyIsInAiLCIxMCIsInMiLCJzZW5kIiwibWV0aG9kIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELGFBQUFBLHFCQUFBQSxrQkFBZ0IsR0FBRCxFQUFNLEdBQXJCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBRSxNQUFNQSxHQUFBQyxNQUFBQSxDQUFBQSxDQUFOO0FBQUEsTUFDQUMsTUFBTUEsR0FBQUQsTUFBQUEsQ0FBQUEsQ0FETjtBQUFBLE1BR0EsSUFBR0MsR0FBQUMsT0FBQUEsQ0FBT0MsQ0FBUEQsQ0FBSDtBQUFBLFlBQ0VFLE9BQUFBLENBQU0sbUNBQW1CLGNB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LFVBQUFBLENBQVM1QixHQUFHSSxDQUFad0IsQ0FBZTtBQUNoQztBQUNBO0FBckNFakIsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBO0FBREZsQixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXhXQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNDUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgVGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICB2YXIgZGF5c19vZl93ZWVrID0gI3sld1tTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheSBTdW5kYXldfSxcbiAgICAgICAgc2hvcnRfZGF5cyAgID0gI3sld1tTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRdfSxcbiAgICAgICAgc2hvcnRfbW9udGhzID0gI3sld1tKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY119LFxuICAgICAgICBsb25nX21vbnRocyAgPSAjeyV3W0phbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJdfTtcbiAgfVxuXG4gIGRlZiBzZWxmLmF0KHNlY29uZHMsIGZyYWMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tUaW1lID09PSBzZWNvbmRzfSkge1xuICAgICAgICBpZiAoZnJhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQuaXNfdXRjID0gc2Vjb25kcy5pc191dGM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICBzZWNvbmRzID0gI3tPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJhYy4kJGlzX251bWJlcikge1xuICAgICAgICBmcmFjID0gI3tPcGFsLmNvZXJjZV90byEoZnJhYywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7T3BhbC5jb2VyY2VfdG8hKGB5ZWFyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xuICAgICAgICBtb250aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFtb250aC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgIG1vbnRoID0gI3tgbW9udGhgLnRvX3N0cn07XG4gICAgICAgICAgc3dpdGNoIChtb250aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmViJzogbW9udGggPSAgMjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFyJzogbW9udGggPSAgMzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF5JzogbW9udGggPSAgNTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVuJzogbW9udGggPSAgNjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVnJzogbW9udGggPSAgODsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VwJzogbW9udGggPSAgOTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm92JzogbW9udGggPSAxMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVjJzogbW9udGggPSAxMjsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbnRoID0gI3tPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibW9udGggb3V0IG9mIHJhbmdlOiAje2Btb250aGB9XCJ9XG4gICAgICB9XG4gICAgICBtb250aCA9IG1vbnRoIC0gMTtcblxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XG4gICAgICAgIGRheSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGRheS4kJGlzX3N0cmluZykge1xuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9ICN7T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXkgPCAxIHx8IGRheSA+IDMxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XG4gICAgICAgIGhvdXIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChob3VyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3VyID0gI3tPcGFsLmNvZXJjZV90byEoYGhvdXJgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChob3VyIDwgMCB8fCBob3VyID4gMjQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1pbi4kJGlzX3N0cmluZykge1xuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPCAwIHx8IG1pbiA+IDU5KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcbiAgICAgICAgc2VjID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlYy4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgc2VjID0gcGFyc2VJbnQoc2VjLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjID0gI3tPcGFsLmNvZXJjZV90byEoYHNlY2AsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjIDwgMCB8fCBzZWMgPiA2MCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwic2VjIG91dCBvZiByYW5nZTogI3tgc2VjYH1cIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlY107XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0Y19vZmZzZXQgIT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdPcGFsIGRvZXMgbm90IHN1cHBvcnQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIFVUQyBvZmZzZXQgZm9yIFRpbWUnfVxuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIG1rdGltZSBsb2NhbFxuICAgIGFsaWFzIHV0YyBnbVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ3RpbWUgKyB0aW1lPydcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBgKHNlbGYuZ2V0VGltZSgpIC0gb3RoZXIuZ2V0VGltZSgpKSAvIDEwMDBgXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpIC0gKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHRvX2YgPD0+IG90aGVyLnRvX2ZcbiAgICBlbHNlXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcbiAgICAgIGlmIHIubmlsP1xuICAgICAgICBuaWxcbiAgICAgIGVsc2lmIHIgPiAwXG4gICAgICAgIC0xXG4gICAgICBlbHNpZiByIDwgMFxuICAgICAgICAxXG4gICAgICBlbHNlXG4gICAgICAgIDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgVGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXG4gIGVuZFxuXG4gIGRlZiBhc2N0aW1lXG4gICAgc3RyZnRpbWUgJyVhICViICVlICVIOiVNOiVTICVZJ1xuICBlbmRcblxuICBhbGlhcyBjdGltZSBhc2N0aW1lXG5cbiAgZGVmIGRheVxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDRGF0ZSgpIDogc2VsZi5nZXREYXRlKClgXG4gIGVuZFxuXG4gIGRlZiB5ZGF5XG4gICAgIyBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibGRheXllYXIuaHRtXG4gICAgIyBhbHNvIHNlZSBtb21lbnQuanMgaW1wbGVtZW50YXRpb246IGh0dHA6Ly9naXQuaW8vdkNLTkVcblxuICAgIHN0YXJ0X29mX3llYXIgPSBUaW1lLm5ldyh5ZWFyKS50b19pXG4gICAgc3RhcnRfb2ZfZGF5ICA9IFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpLnRvX2lcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXG5cbiAgICAoKHN0YXJ0X29mX2RheSAtIHN0YXJ0X29mX3llYXIpIC8gb25lX2RheSkucm91bmQgKyAxXG4gIGVuZFxuXG4gIGRlZiBpc2RzdFxuICAgICV4e1xuICAgICAgdmFyIGphbiA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAganVsID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHN0PyBpc2RzdFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKWBcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIG90aGVyLmlzX2E/KFRpbWUpICYmIChzZWxmIDw9PiBvdGhlcikuemVybz9cbiAgZW5kXG5cbiAgZGVmIGZyaWRheT9cbiAgICBgI3t3ZGF5fSA9PSA1YFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBob3VyXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENIb3VycygpIDogc2VsZi5nZXRIb3VycygpYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBtZGF5IGRheVxuXG4gIGRlZiBtaW5cbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01pbnV0ZXMoKSA6IHNlbGYuZ2V0TWludXRlcygpYFxuICBlbmRcblxuICBkZWYgbW9uXG4gICAgYChzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDTW9udGgoKSA6IHNlbGYuZ2V0TW9udGgoKSkgKyAxYFxuICBlbmRcblxuICBkZWYgbW9uZGF5P1xuICAgIGAje3dkYXl9ID09IDFgXG4gIGVuZFxuXG4gIGFsaWFzIG1vbnRoIG1vblxuXG4gIGRlZiBzYXR1cmRheT9cbiAgICBgI3t3ZGF5fSA9PSA2YFxuICBlbmRcblxuICBkZWYgc2VjXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENTZWNvbmRzKCkgOiBzZWxmLmdldFNlY29uZHMoKWBcbiAgZW5kXG5cbiAgZGVmIHN1Y2NcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIDEwMDApO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1c2VjXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxuICBlbmRcblxuICBkZWYgem9uZVxuICAgICV4e1xuICAgICAgdmFyIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignKCcpID09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvW0EtWl17Myw0fS8pWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvXFwoKC4rKVxcKSg/Olxcc3wkKS8pWzFdXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gXCJHTVRcIiAmJiAvKEdNVFxcVypcXGR7NH0pLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGdtXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZ2V0dXRjIGdldGdtXG5cbiAgZGVmIGdtdGltZVxuICAgICV4e1xuICAgICAgc2VsZi5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB1dGMgZ210aW1lXG5cbiAgZGVmIGdtdD9cbiAgICBgc2VsZi5pc191dGMgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYHNlbGYuaXNfdXRjID8gMCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpICUgNjA7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF5c19vZl93ZWVrWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9kYXlzWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3dkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzBdLnRvX3Mucmp1c3QoMiwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdWy0yLi4tMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3RvX2l9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVtLyVkLyV5Jyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWUtJV5iLSU0WScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUk6JU06JVMgJXAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTTolUycpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwY2FzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9bYS16XS8sIGZ1bmN0aW9uKGMpIHsgYy50b1VwcGVyQ2FzZSgpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhZCAmJiAoemVybyB8fCBibGFuaykpIHtcbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLnJqdXN0KGBpc05hTih3aWR0aCkgPyAyIDogd2lkdGhgLCBgYmxhbmsgPyBcIiBcIiA6IFwiMFwiYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bmRheT9cbiAgICBgI3t3ZGF5fSA9PSAwYFxuICBlbmRcblxuICBkZWYgdGh1cnNkYXk/XG4gICAgYCN7d2RheX0gPT0gNGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbc2VjLCBtaW4sIGhvdXIsIGRheSwgbW9udGgsIHllYXIsIHdkYXksIHlkYXksIGlzZHN0LCB6b25lXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYuZ2V0VGltZSgpIC8gMTAwMCwgMTApYFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHVlc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAyYFxuICBlbmRcblxuICBhbGlhcyB0dl9zZWMgdG9faVxuXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuXG4gIGFsaWFzIHV0Yz8gZ210P1xuXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gVGltZS5uZXcoeWVhciwgMSwgMSlcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxuICAgIGZpcnN0X21vbmRheSA9IDBcbiAgICB5ZWFyID0gc2VsZi55ZWFyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSAxXG4gICAgZWxzZVxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDcgLSAxXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XG4gICAgZW5kXG5cbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcblxuICAgIGlmIHdlZWsgPD0gMFxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgcmV0dXJuIFRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gVGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0Iiwic2VsZiIsIj09PSIsInNlY29uZHMiLCJyYWlzZSIsImNvZXJjZV90byEiLCJmcmFjIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwibmV3IiwibG9jYWwiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImRheSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwieWVhciIsInN0YXJ0X29mX2RheSIsIm1vbnRoIiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaG91ciIsImluc3BlY3QiLCJ1dGM/IiwibWluIiwibW9uIiwibW9uZGF5PyIsInNhdHVyZGF5PyIsInNlYyIsInN1Y2MiLCJ1c2VjIiwiem9uZSIsImdldGdtIiwiZ210aW1lIiwiZ210PyIsImdtdF9vZmZzZXQiLCJyanVzdCIsIjMiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiMiIsIi0yIiwic3VuZGF5PyIsInRodXJzZGF5PyIsInRvX2EiLCJ0dWVzZGF5PyIsIndlZG5lc2RheT8iLCJqYW4wMSIsImphbjAxX3dkYXkiLCJmaXJzdF9tb25kYXkiLCI8PSIsIjQiLCIhPSIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0YsdUJBQXlCLENBQUcsUUFBSCxFQUFVLFFBQVYsRUFBaUIsU0FBakIsRUFBeUIsV0FBekIsRUFBbUMsVUFBbkMsRUFBNEMsUUFBNUMsRUFBbUQsVUFBbkQsRUFBNEQsUUFBNUQsQ0FBb0U7QUFDN0YsdUJBQXlCLENBQUcsS0FBSCxFQUFPLEtBQVAsRUFBVyxLQUFYLEVBQWUsS0FBZixFQUFtQixLQUFuQixFQUF1QixLQUF2QixFQUEy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QUFoQixFQUFPc0UsTUFBUHRFLENBQUR1QixFQUFrQixHQUFsQkEsQ0FBRG1ELE1BQUFBLENBQUFBLENBYlA7QUFBQSxNQWVBLElBQUEsUUFBR1AsT0FBQU0sSUFBQU4sRUFBUTNELENBQVIyRCxDQUFILENBQUE7QUFBQSxRQUVFLE9BQU8sb0JBQUF2RSxLQUFBQSxDQUFTTSxVQUFBZixJQUFBK0IsTUFBQUEsQ0FBQUEsQ0FBQWhCLEVBQVlTLENBQVpULEdBQWV5RSxJQUFJQyxFQUE1QmhGLENBQUEwRCxhQUFBQSxDQUFBQTtBQUZULE1BQUEsT0FHQSxJQUFNbUIsSUFBQTdELE9BQUFBLENBQVFpRSxFQUFSakUsQ0FBTjtBQUFBO0FBRUUsUUFBQWtFLFFBQVEsb0JBQUFsRixLQUFBQSxDQUFTVCxJQUFBK0IsTUFBQUEsQ0FBQUEsR0FBV3lELElBQUlDLEVBQXhCaEYsQ0FBUjtBQUFBLFFBQ0FtRixhQUFhRCxLQUFBNUMsTUFBQUEsQ0FBQUEsQ0FEYjtBQUFBLFFBRUEsSUFBQSxRQUFHLGNBQUFpQyxPQUFBWSxVQUFBWixFQUFjZixDQUFkZSxDQUFBLElBQW1CWSxVQUFBVixPQUFBQSxDQUFjN0QsQ0FBZDZELENBQW5CLE1BQUgsQ0FBQTtBQUFBO0FBQ0UsVUFBQUksT0FBTzlELENBQVA7QUFBQSxVQUNBTyxPQXZ1QlJsQixTQXV1QlFrQixJQXZ1QlJsQixFQXV1QmdCVyxDQXZ1QmhCWCxDQXN1QlEsQ0FERixDQUZBLENBRkYsQ0FsQkE7QUFBQSxNQTRCQSxPQUFBLENBQUN5RSxJQUFELEVBQU92RCxJQUFQLENBNUJBO0FBREZvQyxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQUEsdUJBMXNCQTtBQURGdEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxJQUFkQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjEzODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFN0cnVjdFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgc2VsZi5uZXcoY29uc3RfbmFtZSwgKmFyZ3MsIGtleXdvcmRfaW5pdDogZmFsc2UsICZibG9jaylcbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBiZWdpblxuICAgICAgICBjb25zdF9uYW1lID0gT3BhbC5jb25zdF9uYW1lIShjb25zdF9uYW1lKVxuICAgICAgcmVzY3VlIFR5cGVFcnJvciwgTmFtZUVycm9yXG4gICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICBjb25zdF9uYW1lID0gbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgZW5kXG5cbiAgICBrbGFzcyA9IENsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgU3RydWN0LmNvbnN0X3NldChjb25zdF9uYW1lLCBrbGFzcylcbiAgICBlbmRcblxuICAgIGtsYXNzXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKG5hbWUpXG4gICAgaWYgc2VsZiA9PSBTdHJ1Y3RcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RoZSBTdHJ1Y3QgY2xhc3MgaGFzIG5vIG1lbWJlcnMnXG4gICAgZW5kXG5cbiAgICBAbWVtYmVycyB8fD0gW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgIG1lbWJlcnMgPSBAbWVtYmVyc1xuXG4gICAga2xhc3MuaW5zdGFuY2VfZXZhbCBkb1xuICAgICAgQG1lbWJlcnMgPSBtZW1iZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIGAje3NlbGYuY2xhc3N9LiQka2V5d29yZF9pbml0YFxuICAgICAga3dhcmdzID0gYXJncy5sYXN0IHx8IHt9XG5cbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMSB8fCBgKGFyZ3MubGVuZ3RoID09PSAxICYmICFrd2FyZ3MuJCRpc19oYXNoKWBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmtub3duIGtleXdvcmRzOiAje2V4dHJhLmpvaW4oJywgJyl9XCJcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgc2VsZltuYW1lXSA9IGt3YXJnc1tuYW1lXVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgaWYgYXJncy5sZW5ndGggPiBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdzdHJ1Y3Qgc2l6ZSBkaWZmZXJzJ1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfaW5kZXggZG8gfG5hbWUsIGluZGV4fFxuICAgICAgICBzZWxmW25hbWVdID0gYXJnc1tpbmRleF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVtYmVyc1xuICAgIHNlbGYuY2xhc3MubWVtYmVyc1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEhhc2gubmV3KGBzZWxmLiQkZGF0YWApLmhhc2hcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgICV4e1xuICAgICAgICBpZighc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiBJbnRlZ2VyID09PSBuYW1lXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIFN0cmluZyA9PT0gbmFtZVxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpIHVubGVzcyBzZWxmLmNsYXNzLm1lbWJlcnMuaW5jbHVkZT8obmFtZS50b19zeW0pXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IE9wYWwuY29lcmNlX3RvIShuYW1lLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3tTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBzZWxmW25hbWVdIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfcGFpcikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgW25hbWUsIHNlbGZbbmFtZV1dIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcblxuICAgIGlmIFN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgIHJlc3VsdCArPSBcIiN7c2VsZi5jbGFzc30gXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICBlbmQuam9pbiAnLCAnXG5cbiAgICByZXN1bHQgKz0gJz4nXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRvX2hcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgYXJnc1tpXWAuY2xhc3N9IGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBpZiBga2V5LiQkaXNfc3RyaW5nICYmIHNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KGtleSlgXG4gICAgICAgICAgICAgYHNlbGYuJCRkYXRhW2tleV0gfHwgbmlsYFxuICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwibmV3Iiwic2VsZiIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsImFyZ3MiLCJ1bnNoaWZ0IiwibWFwIiwiY29lcmNlX3RvISIsImFyZyIsImtsYXNzIiwiZWFjaCIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwiY29uc3Rfc2V0IiwiPT0iLCJyYWlzZSIsIm1lbWJlcnMiLCI8PCIsIm5hbWUiLCJkZWZpbmVfbWV0aG9kIiwiQG1lbWJlcnMiLCJpbmhlcml0ZWQiLCJpbnN0YW5jZV9ldmFsIiwia3dhcmdzIiwibGFzdCIsIj4iLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCItIiwia2V5cyIsImFueT8iLCJqb2luIiwiJHdyaXRlciIsIltdIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJoYXNoIiwiPT09IiwiPCIsInNpemUiLCItQCIsIj49IiwiaW5jbHVkZT8iLCJ0b19zeW0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVhY2hfcGFpciIsInRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiKyIsInZhbHVlIiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJoIiwidmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxnQkFBQUEsU0FBYSxVQUFELEVBTmQs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Q0E7QUFDQSxJQW5TQTtBQUFBLE1BcVNJLElBQUEsUUFBT0EsSUFBQUMsZ0JBQUFBLENBQWlCLEtBQWpCQSxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRWxELE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLENBQUdpRCxJQUFBdkUsT0FBQUEsQ0FBQUEsQ0FBSCxDQUFBLEdBQUEsNEJBQWpCc0I7QUFERixNQUFBLENBclNKO0FBQUEsTUF5U0ksT0FBQWdELE1BQUFDLElBQUFELE9BQUFBLEVBQVMsVUFBQ2pDLElBQUQsQ0FBVGlDLENBelNKO0FBMFJFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsZUF0UkE7QUFERnRFLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTg5MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgSU9cbiAgU0VFS19TRVQgPSAwXG4gIFNFRUtfQ1VSID0gMVxuICBTRUVLX0VORCA9IDJcblxuICBkZWYgdHR5P1xuICAgIEB0dHlcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOndyaXRlX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIG1vZHVsZSBXcml0YWJsZVxuICAgIGRlZiA8PChzdHJpbmcpXG4gICAgICB3cml0ZShzdHJpbmcpXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgcHJpbnQoKmFyZ3MpXG4gICAgICB3cml0ZSBhcmdzLm1hcCB7IHxhcmd8IFN0cmluZyhhcmcpIH0uam9pbigkLClcbiAgICAgIG5pbFxuICAgIGVuZFxuXG4gICAgZGVmIHB1dHMoKmFyZ3MpXG4gICAgICBuZXdsaW5lID0gJC9cbiAgICAgIGlmIGFyZ3MuZW1wdHk/XG4gICAgICAgIHdyaXRlICQvXG4gICAgICBlbHNlXG4gICAgICAgIHdyaXRlIGFyZ3MubWFwIHsgfGFyZ3wgU3RyaW5nKGFyZykuY2hvbXAgfS5jb25jYXQoW25pbF0pLmpvaW4obmV3bGluZSlcbiAgICAgIGVuZFxuICAgICAgbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBSZWFkYWJsZVxuICAgIGRlZiByZWFkYnl0ZVxuICAgICAgZ2V0Ynl0ZVxuICAgIGVuZFxuXG4gICAgZGVmIHJlYWRjaGFyXG4gICAgICBnZXRjXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZGxpbmUoc2VwID0gJC8pXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlciwgb3V0YnVmID0gbmlsKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5TVERFUlIgPSAkc3RkZXJyID0gSU8ubmV3XG5TVERJTiAgPSAkc3RkaW4gID0gSU8ubmV3XG5TVERPVVQgPSAkc3Rkb3V0ID0gSU8ubmV3XG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG5TVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuU1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cblNURE9VVC5leHRlbmQoSU86OldyaXRhYmxlKVxuU1RERVJSLmV4dGVuZChJTzo6V3JpdGFibGUpXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIwIiwiMSIsIjIiLCJ0dHk/IiwiQHR0eSIsImNsb3NlZD8iLCJAY2xvc2VkIiwiYXR0cl9hY2Nlc3NvciIsIndyaXRlIiwic3RyaW5nIiwic2l6ZSIsImZsdXNoIiwibW9kdWxlIiwiPDwiLCJzZWxmIiwicHJpbnQiLCJtYXAiLCJhcmdzIiwiU3RyaW5nIiwiYXJnIiwiam9pbiIsIiQsIiwicHV0cyIsIm5ld2xpbmUiLCIkLyIsImVtcHR5PyIsImNob21wIiwiY29uY2F0IiwicmVhZGJ5dGUiLCJnZXRieXRlIiwicmVhZGNoYXIiLCJnZXRjIiwicmVhZGxpbmUiLCJyYWlzZSIsInJlYWRwYXJ0aWFsIiwiJHN0ZGVyciIsIm5ldyIsIiRzdGRpbiIsIiRzdGRvdXQiLCIkd3JpdGVyIiwid3JpdGVfcHJvYz0iLCItIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQSx3Q0FBV0MsQ0FBWCxDQUFBO0FBQUEsSUFDQSx3Q0FBV0MsQ0FBWCxDQURBO0FBQUEsSUFFQSx3Q0FBV0MsQ0FBWCxDQUZBO0FBQUE7QUFJQUMsSUFBQUEsd0JBQUFBLGlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQztBQURGRCxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FKQTtBQUFBO0FBUUFFLElBQUFBLDJCQUFBQSxvQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUM7QUFERkQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBUkE7QUFBQSxRQVlBRSxlQUFBQSxDQUFjLFlBQWRBLENBWkE7QUFBQTtBQWNBQyxJQUFBQSx5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QUMsQ0ExRUE7QUFBQSxFQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUF4QyxDQUFBd0MsQ0FBQSxDQUFBLENBQ0E7QUFBQSxFQTJFQSxzQkFBQUMsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBM0VBO0FBQUEsRUE0RUEsT0FBQSxzQkFBQUEsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBNUVBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIwNTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21haW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmIHNlbGYudG9fc1xuICAnbWFpbidcbmVuZFxuXG5kZWYgc2VsZi5pbmNsdWRlKG1vZClcbiAgT2JqZWN0LmluY2x1ZGUgbW9kXG5lbmRcbiJdLCJuYW1lcyI6WyJ0b19zIiwic2VsZiIsImluY2x1ZGUiLCJtb2QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBLFVBQUlDLElBQUpELFdBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBO0FBREZBLEVBQUFBLENBQUFBLHFCQUFBQSxDQUFBO0FBQUEsRUFJQSxPQUFBRSxDQUFBQSxVQUFJRCxJQUFKQyxjQUFBQSxhQUFBQSxtQkFBaUIsR0FBakJBO0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUEsc0JBQUFBLFNBQUFBLENBQWVDLEdBQWZEO0FBREZBLEVBQUFBLENBQUFBLHdCQUFBQSxDQUFBQSxtQkFKQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMDc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG5cbiAgICBkZWYgaG9tZVxuICAgICAgRU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJjaGRpciIsInByZXZfY3dkIiwiZGlyIiwicHdkIiwiaG9tZSIsIltdIiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSx5QkFBQUEsV0FBQUEsaUJBQVUsR0FBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBLGVBQ0UsY0FBQTtBQUFBO0FBQUEsUUFBQUMsV0FBWSxnQkFBWjtBQUFBLFFBQ0MsbUJBQXFCQyxHQUR0QjtBQUFBLFFBRUEsT0FBQSxxQkFBQSxFQUFBLENBRkE7QUFBQSxRQUFBO0FBQUEsVUFJQyxtQkFBcUJEO0FBSnRCLFFBQUEsQ0FBQTtBQURGRCxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FBQTtBQUFBO0FBUUFHLE1BQUFBLHVCQUFBQSxTQUFBQSxlQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLHVCQUFEO0FBREZBLE1BQUFBLENBQUFBLG9CQUFBQSxDQVJBO0FBQUEsTUFXQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQVhBO0FBQUEsTUFhQSxPQUFBQyxDQUFBQSx3QkFBQUEsVUFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUEsY0FBQSxtQkFBQUMsT0FBQUEsQ0FBSSxNQUFKQSxDQUFBLFNBQWUsR0FBZjtBQURGRCxNQUFBQSxDQUFBQSxxQkFBQUEsQ0FBQUEsZ0JBYkE7QUFERixJQUFBLDRCQUFTRSxJQUFUO0FBREZQLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIxMTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRmlsZSA8IElPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBiYXNlZGlyIHx8PSBEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxuXG4gICAgICAgIGhvbWUgICAgICAgICAgICArPSBzZXBcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xuICAgICAgICBwYXRoICAgICAgICAgICAgID0gcGF0aC5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSlcbiAgICAgICAgYmFzZWRpciAgICAgICAgICA9IGJhc2VkaXIuc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpIGlmIGJhc2VkaXJcbiAgICAgIGVuZFxuICAgICAgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyKVxuICAgIGVuZFxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGBwYXRoYC5yZXNwb25kX3RvPyg6dG9fcGF0aCkpfSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoLiR0b19wYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gI3tPcGFsLmNvZXJjZV90byEoYHBhdGhgLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgUmVnRXhwIGNvbXBhdGlibGUgY2hhciBjbGFzc1xuICAgICAgZnVuY3Rpb24gJHNlcF9jaGFycygpIHtcbiAgICAgICAgaWYgKCN7QUxUX1NFUEFSQVRPUn0gPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1J9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SICsgQUxUX1NFUEFSQVRPUn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmIGRpcm5hbWUocGF0aClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBwYXRoID0gYCRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWJzb2x1dGUgPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoI3tcIl5bI3tzZXBfY2hhcnN9XVwifSkpO1xuXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvcnNcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbXiN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIGJhc2VuYW1lXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIGZpbmFsIHRyYWlsaW5nIHNlcGFyYXRvcnNcblxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gYWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbmFtZShuYW1lLCBzdWZmaXggPSBuaWwpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmFtZSA9IGAkY29lcmNlX3RvX3BhdGgobmFtZSlgXG4gICAgICAleHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWZmaXggIT09IG5pbCkge1xuICAgICAgICAgIHN1ZmZpeCA9ICN7T3BhbC5jb2VyY2VfdG8hKHN1ZmZpeCwgU3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIoLilbI3tzZXBfY2hhcnN9XSokXCJ9KSwgJyQxJyk7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiXig/Oi4qWyN7c2VwX2NoYXJzfV0pPyhbXiN7c2VwX2NoYXJzfV0rKSRcIn0pLCAnJDEnKTtcblxuICAgICAgICBpZiAoc3VmZml4ID09PSBcIi4qXCIpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXC5bXlxcLl0rJC8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmKHN1ZmZpeCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1ZmZpeCA9IE9wYWwuZXNjYXBlX3JlZ2V4cChzdWZmaXgpO1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiI3tzdWZmaXh9JFwifSksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGV4dG5hbWUocGF0aClcbiAgICAgIGBwYXRoID0gJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgZmlsZW5hbWUgPSBiYXNlbmFtZShwYXRoKVxuICAgICAgcmV0dXJuICcnIGlmIGZpbGVuYW1lLmVtcHR5P1xuICAgICAgbGFzdF9kb3RfaWR4ID0gZmlsZW5hbWVbMS4uLTFdLnJpbmRleCgnLicpXG4gICAgICAjIGV4dGVuc2lvbiBuYW1lIG11c3QgY29udGFpbnMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciAuKHNvbWV0aGluZylcbiAgICAgIGxhc3RfZG90X2lkeC5uaWw/IHx8IGxhc3RfZG90X2lkeCArIDEgPT0gZmlsZW5hbWUubGVuZ3RoIC0gMSA/ICcnIDogZmlsZW5hbWVbKGxhc3RfZG90X2lkeCArIDEpLi4tMV1cbiAgICBlbmRcblxuICAgIGRlZiBleGlzdD8ocGF0aClcbiAgICAgIGBPcGFsLm1vZHVsZXNbI3twYXRofV0gIT0gbnVsbGBcbiAgICBlbmRcbiAgICBhbGlhcyBleGlzdHM/IGV4aXN0P1xuXG4gICAgZGVmIGRpcmVjdG9yeT8ocGF0aClcbiAgICAgIGZpbGVzID0gW11cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgICAgI3tmaWxlc30ucHVzaChrZXkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLmdzdWIoLyheLiN7U0VQQVJBVE9SfSt8I3tTRVBBUkFUT1J9KyQpLylcbiAgICAgIGZpbGUgPSBmaWxlcy5maW5kIHsgfGZ8IGYgPX4gL14je3BhdGh9LyB9XG4gICAgICBmaWxlXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbigqcGF0aHMpXG4gICAgICBpZiBwYXRocy5lbXB0eT9cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdCA9ICcnXG4gICAgICBwYXRocyA9IHBhdGhzLmZsYXR0ZW4uZWFjaF93aXRoX2luZGV4Lm1hcCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIGlmIGluZGV4ID09IDAgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzaWYgcGF0aHMubGVuZ3RoID09IGluZGV4ICsgMSAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaXRlbVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcGF0aHMgPSBwYXRocy5yZWplY3QoJjplbXB0eT8pXG4gICAgICBwYXRocy5lYWNoX3dpdGhfaW5kZXggZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBuZXh0X2l0ZW0gPSBwYXRoc1tpbmRleCArIDFdXG4gICAgICAgIGlmIG5leHRfaXRlbS5uaWw/XG4gICAgICAgICAgcmVzdWx0ID0gXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgJiYgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnN1YigvI3tTRVBBUkFUT1J9KyQvLCAnJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICByZXN1bHQgPSBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpIHx8IG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfSN7U0VQQVJBVE9SfVwiXG4gICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXN1bHRcbiAgICBlbmRcblxuICAgIGRlZiBzcGxpdChwYXRoKVxuICAgICAgcGF0aC5zcGxpdChTRVBBUkFUT1IpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIwIiwid2luZG93c19yb290X3J4IiwiYWJzb2x1dGVfcGF0aCIsInNlcCIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInBhdGgiLCJyZXNwb25kX3RvPyIsInRvX3BhdGgiLCJiYXNlZGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwicmFpc2UiLCJzdGFydF93aXRoPyIsImhvbWVfcGF0aF9yZWdleHAiLCJ0cnV0aHk/IiwiY29lcmNlX3RvISIsImRpcm5hbWUiLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIjEiLCItMSIsInJpbmRleCIsIm5pbD8iLCI9PSIsIi0iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJmIiwiPX4iLCJwYXRocyIsInJlc3VsdCIsIm1hcCIsImZsYXR0ZW4iLCJlYWNoX3dpdGhfaW5k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LFVBQUE7QUFBQTtBQUdFLFlBQUEsSUFBQSxRQUFHLGNBQUFLLElBQUFHLGNBQUFBLENBQWUseUJBQWZBLENBQUEsSUFBNkJELFNBQUFwQyxnQkFBQUEsQ0FBc0IseUJBQXRCQSxDQUE3QixNQUFILENBQUE7QUFBQSxjQUNFa0MsT0FBT0EsSUFBQTNDLEtBQUFBLENBQVMsaUJBQUcsaUNBQUgsR0FBa0IsRUFBM0JBLENBRFQsQ0FBQTtBQUFBLFlBR0EsT0FBQXNDLENBQUFBLFNBQVMsYUFBQSxJQUFBLFFBQUcsY0FBQUssSUFBQUcsY0FBQUEsQ0FBZSx5QkFBZkEsQ0FBQSxTQUE2QkQsU0FBQXBDLGdCQUFBQSxDQUFzQix5QkFBdEJBLENBQTdCLENBQUgsQ0FBQTtBQUFBLGNBQ0UsT0FBQSxFQUFBLEdBQUEsQ0FBRzZCLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVo7QUFERixZQUFBO0FBQUEsY0FHRSxPQUFBLEVBQUEsR0FBQSxDQUFHTCxNQUFILENBQUEsR0FBQSxDQUFZSyxJQUFaLENBQUEsR0FBQSxDQUFtQix5QkFBbkI7QUFIRixZQUFBLENBQUEsa0JBQVRMLENBSEE7QUFIRixVQUFBLENBNUxSLENBQUEsbUJBQUEsa0JBQUEsTUEwTE1HLENBMUxOO0FBQUEsUUF5TU0sT0FBQUgsTUF6TU47QUEyS0lqQyxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FqS0E7QUFBQSxNQWtNQSxPQUFBUCxDQUFBQSx5QkFBQUEsWUFBQUEsaUJBQVUsSUFBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQVIsSUFBQVEsT0FBQUEsQ0FBVyx5QkFBWEE7QUFERkEsTUFBQUEsQ0FBQUEsdUJBQUFBLENBQUFBLGlCQWxNQTtBQURGLElBQUEsNEJBQVNpRCxJQUFULFlBUEE7QUFERmhFLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWEsa0JBQWJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjI0MjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2Nlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUHJvY2Vzc1xuICBAX19jbG9ja3NfXyA9IFtdXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxuICAgIGNvbnN0X3NldCBuYW1lLCBAX19jbG9ja3NfXy5zaXplXG4gICAgQF9fY2xvY2tzX18gPDwgZnVuY1xuICBlbmRcblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18gOkNMT0NLX1JFQUxUSU1FLCBgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpIH1gXG5cbiAgbW9ub3RvbmljID0gZmFsc2VcblxuICAleHtcbiAgICBpZiAoT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgIC8vIGxldCBub3cgYmUgdGhlIGJhc2UgdG8gZ2V0IHNtYWxsZXIgbnVtYmVyc1xuICAgICAgdmFyIGhydGltZV9iYXNlID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocnRpbWUgPSBwcm9jZXNzLmhydGltZShocnRpbWVfYmFzZSk7XG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XG4gICAgICAgIHJldHVybiAoKGhydGltZVswXSAqIDEwMDApICsgKHVzIC8gMTAwMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcblxuICBkZWYgc2VsZi5waWRcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRpbWVzXG4gICAgdCA9IFRpbWUubm93LnRvX2ZcbiAgICBCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCByYWlzZShFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxuICAgICV4e1xuICAgICAgdmFyIG1zID0gY2xvY2soKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdmbG9hdF9zZWNvbmQnOiAgICAgIHJldHVybiAgKG1zIC8gMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYSBmbG9hdCAoZGVmYXVsdClcbiAgICAgICAgY2FzZSAnZmxvYXRfbWlsbGlzZWNvbmQnOiByZXR1cm4gIChtcyAvIDEpOyAgICAgICAgICAgIC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgICAgICAgcmV0dXJuICgobXMgLyAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgLyAxKSAgICAgICB8IDApOyAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzogICAgICAgIHJldHVybiAoKG1zICogMTAwMDAwMCkgfCAwKTsgLy8gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgZGVmYXVsdDogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgU2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgR0NcbiAgZGVmIHNlbGYuc3RhcnRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsImNvbnN0X3NldCIsIm5hbWUiLCJzaXplIiwiPDwiLCJmdW5jIiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIm5vdyIsInRvX2YiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiY2xvY2siLCJbXSIsImNsb2NrX2lkIiwicmFpc2UiLCJ1bml0IiwidHJhcCIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsa0JBQWMsRUFBZDtBQUFBLElBQ0FDLFVBQUlDLElBQUpELHlCQUFBQSxnQ0FBQUEsOEJBQTRCLElBQUQsRUFBTyxJQUFsQ0E7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUUsV0FBQUEsQ0FBVUMsTUFBTUosZUFBQUssTUFBQUEsQ0FBQUEsQ0FBaEJGLENBQUE7QUFBQSxNQUNBLE9BQUFILGVBQUFNLE9BQUFBLENBQWVDLElBQWZELENBREE7QUFERkwsSUFBQUEsQ0FBQUEsMkNBQUFBLENBREE7QUFBQSxRQU1BQSxvQkFBQUEsQ0FBbUIsa0JBQWtCLGdDQUFyQ0EsQ0FOQTtBQUFBLElBUUFPLFlBQVksS0FSWjtBQUFBO0FBV0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQTFCRTtBQUFBLElBNEJBLElBQUEsUUFBbURBLFNBQW5ELENBQUE7QUFBQSxVQUFBUCxvQkFBQUEsQ0FBbUIsbUJBQWtCTyxTQUFyQ1AsQ0FBQSxDQTVCQTtBQUFBLElBOEJBUSxVQUFJUCxJQUFKTyxVQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUM7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBOUJBO0FBQUEsSUFrQ0FFLFVBQUlULElBQUpTLFlBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsSUFBSSxvQkFBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBSjtBQUFBLE1BQ0EsT0FBQSxJQUFBLHlCQUFBLFFBQUFDLEtBQUFBLENBQW1CSCxHQUFHQSxHQUFHQSxHQUFHQSxHQUFHQSxDQUEvQkcsQ0FEQTtBQURGSixJQUFBQSxDQUFBQSw4QkFBQUEsQ0FsQ0E7QUFBQSxJQXVDQSxPQUFBSyxDQUFBQSxVQUFJZCxJQUFKYyxvQkFBQUEsMkJBQUFBLHlCQUF1QixRQUFELEVBQVcsSUFBakNBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQXpDRjtBQXlDbUMsTUFBQTtBQUFBLE1BQUEsU0FBTyxjQUFQO0FBQUEsTUFBQSxDQXpDbkM7QUFBQSxNQTBDSSxjQUFDQyxDQUFBQSxRQUFRakIsZUFBQWtCLE9BQUFBLENBQVlDLFFBQVpELENBQVJELENBQUQsYUFBbUNHLE9BQUFBLENBQU0sSUFBQSxxQkFBQSxhQUFlLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCRCxRQUFqQixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQThCbkIsZUFBQWtCLE9BQUFBLENBQVlDLFFBQVpELENBQTlCLENBQXJCRSxDQUFuQyxDQTFDSjtBQUFBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQkEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsbUJBQUEsR0FBQSxDQUFvQkMsSUFBcEIsQ0FBckJEO0FBQ25CO0FBQ0EsSUF2REE7QUF5Q0VKLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSx5QkF2Q0E7QUFERmpCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQTBEQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF1QixDQUFBQSxVQUFJcEIsSUFBSm9CLFdBQUFBLGlCQUFBQSxnQkE1REYsRUE0REVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTVERjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUE0REVBLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGdkIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0ExREE7QUFBQSxFQStEQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQXdCLENBQUFBLFVBQUlyQixJQUFKcUIsWUFBQUEsY0FBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQWpFRixPQUFBO0FBaUVFQSxJQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQUE7QUFERnhCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL0RBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjI1MjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IE9wYWwuY29lcmNlX3RvIShzZWVkLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgREVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBERUZBVUxULnNlZWRcbiAgICBERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIHNpemUgPSBPcGFsLmNvZXJjZV90byEoc2l6ZSwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIGlmIHNpemUgPCAwXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknXG4gICAgZW5kXG5cbiAgICBBcnJheS5uZXcoc2l6ZSkgeyByYW5kKDI1NSkuY2hyIH0uam9pbi5lbmNvZGUoJ0FTQ0lJLThCSVQnKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5kb20gPT09IG90aGVyXG5cbiAgICBzZWVkID09IG90aGVyLnNlZWQgJiYgc3RhdGUgPT0gb3RoZXIuc3RhdGVcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzKGxlbmd0aClcbiAgICBsZW5ndGggPSBPcGFsLmNvZXJjZV90byEobGVuZ3RoLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgQXJyYXkubmV3KGxlbmd0aCkgeyByYW5kKDI1NSkuY2hyIH0uam9pbi5lbmNvZGUoJ0FTQ0lJLThCSVQnKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIHJhbmRvbUZsb2F0KCkge1xuICAgICAgICBzZWxmLnN0YXRlKys7XG4gICAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJhbmRvbUludCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIGxpbWl0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmFuZG9tUmFuZ2UoKSB7XG4gICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0LmVuZDtcblxuICAgICAgICBpZiAobWluID09PSBuaWwgfHwgbWF4ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLiRyYW5kKGxlbmd0aCkgKyBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpO1xuICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX3JhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCAlIDEgPT09IDApIHtcbiAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUludCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpICogbGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbWl0ID0gI3tPcGFsLmNvZXJjZV90byEobGltaXQsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5kb21JbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdlbmVyYXRvcj0oZ2VuZXJhdG9yKVxuICAgIGBPcGFsLiQkcmFuZCA9ICN7Z2VuZXJhdG9yfWBcblxuICAgIGlmIGNvbnN0X2RlZmluZWQ/IDpERUZBVUxUXG4gICAgICBERUZBVUxULnJlc2VlZFxuICAgIGVsc2VcbiAgICAgIGNvbnN0X3NldCA6REVGQVVMVCwgbmV3KG5ld19zZWVkKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwibmV3X3NlZWQiLCJzZWVkIiwiY29lcmNlX3RvISIsIkBzdGF0ZSIsInJlc2VlZCIsIkBzZWVkIiwic2VsZiIsInJhbmQiLCJsaW1pdCIsInNyYW5kIiwibiIsInByZXZpb3VzX3NlZWQiLCJ1cmFuZG9tIiwic2l6ZSIsIjwiLCIwIiwicmFpc2UiLCJuZXciLCIyNTUiLCJjaHIiLCJqb2luIiwiZW5jb2RlIiwiPT0iLCI9PT0iLCJvdGhlciIsInN0YXRlIiwiYnl0ZXMiLCJsZW5ndGgiLCJnZW5lcmF0b3I9IiwiZ2VuZXJhdG9yIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9zZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLGFBQUFBLENBQVksUUFBTyxPQUFuQkEsQ0FBQTtBQUFBO0FBRUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWUsSUFBZkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBSkY7QUFJaUIsTUFBQTtBQUFBLE1BQUEsU0FBTyxzQkFBQUMsVUFBQUEsQ0FBQUEsQ0FBUDtBQUFBLE1BQUEsQ0FKakI7QUFBQSxNQUtJQyxPQUFPLG9CQUFBQyxlQUFBQSxDQUFnQkQsTUFBTSx5QkFBUyxRQUEvQkMsQ0FMWDtBQUFBLE1BTUlDLGFBQVNGLElBTmI7QUFBQSxNQU9JLFdBQUFHLFFBQUFBLENBQU9ILElBQVBHLENBUEo7QUFJRUwsSUFBQUEsQ0FBQUEsbUNBQUFBLENBRkE7QUFBQTtBQVFBSyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQUFXLElBQVhBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFlBQVFKLElBQVI7QUFBQSxNQUNBLE9BQUMsb0NBQUQsQ0FEQTtBQURGRyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FSQTtBQUFBLElBYUFKLFVBQUlNLElBQUpOLGVBQUFBLHFCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxzQkFBRDtBQURGQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FiQTtBQUFBLElBaUJBTyxVQUFJRCxJQUFKQyxXQUFBQSxpQkFBQUEsZ0JBQWMsS0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbkJGLE1BQUE7QUFBQSxNQW9CSSxPQUFBLHVCQUFBQSxNQUFBQSxDQUFhQyxLQUFiRCxDQXBCSjtBQW1CRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBakJBO0FBQUEsSUFxQkFFLFVBQUlILElBQUpHLFlBQUFBLGtCQUFBQSxpQkFBZSxDQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF2QkY7QUF1QmlCLE1BQUE7QUFBQSxNQUFBLE1BQUksc0JBQUFULFVBQUFBLENBQUFBLENBQUo7QUFBQSxNQUFBLENBdkJqQjtBQUFBLE1Bd0JJVSxJQUFJLG9CQUFBUixlQUFBQSxDQUFnQlEsR0FBRyx5QkFBUyxRQUE1QlIsQ0F4QlI7QUFBQSxNQTBCSVMsZ0JBQWdCLHVCQUFBVixNQUFBQSxDQUFBQSxDQTFCcEI7QUFBQSxNQTJCSSx1QkFBQUcsUUFBQUEsQ0FBZU0sQ0FBZk4sQ0EzQko7QUFBQSxNQTRCSSxPQUFBTyxhQTVCSjtBQXVCRUYsSUFBQUEsQ0FBQUEsOEJBQUFBLENBckJBO0FBQUEsSUE2QkFHLFVBQUlOLElBQUpNLGNBQUFBLG9CQUFBQSxtQkFBaUIsSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLE9BQU8sb0JBQUFYLGVBQUFBLENBQWdCVyxNQUFNLHlCQUFTLFFBQS9CWCxDQUFQO0FBQUEsTUFFQSxJQUFBLFFBQUdZLE9BQUFELElBQUFDLEVBQU9DLENBQVBELENBQUgsQ0FBQTtBQUFBLFlBQ0VFLE9BQUFBLENBQU0sK0JBQWUsd0NBQXJCQSxDQURGLENBRkE7QUFBQSxNQU1BLE9BQUFDLE1BQUEscUJBQUFBLE9BQUFBLEVBQUFBLENBQVVKLElBQVZJLENBQUFBLEVBdENKLGdCQUFBLEVBQUE7O0FBQUEsTUFzQ3NCLFdBQUFWLE1BQUFBLENBQUtXLEdBQUxYLENBQUFZLEtBQUFBLENBQUFBLENBdEN0QixrQkFBQSxpQkFBQSxLQXNDSUYsQ0FBQUcsTUFBQUEsQ0FBQUEsQ0FBQUMsUUFBQUEsQ0FBOEMsWUFBOUNBLENBTkE7QUFERlQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBN0JBO0FBQUE7QUF1Q0FVLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBb0Isc0JBQUFDLFFBQUFBLENBQVdDLEtBQVhELENBQXBCLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFFQSxPQUFBLFdBQUF0QixNQUFBQSxDQUFBQSxDQUFBcUIsT0FBQUEsQ0FBUUUsS0FBQXZCLE1BQUFBLENBQUFBLENBQVJxQixDQUFBLFFBQXNCRyxPQUFBQSxDQUFBQSxDQUFBSCxPQUFBQSxDQUFTRSxLQUFBQyxPQUFBQSxDQUFBQSxDQUFUSCxDQUF0QixPQUFBckIsTUFBQUEsQ0FBQUEsQ0FBQXFCLE9BQUFBLENBQVFFLEtBQUF2QixNQUFBQSxDQUFBQSxDQUFScUIsQ0FBQSxDQUZBO0FBREZBLElBQUFBLENBQUFBLDhCQUFBQSxDQXZDQTtBQUFBO0FBNkNBSSxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVLE1BQVZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFNBQVMsb0JBQUF6QixlQUFBQSxDQUFnQnlCLFFBQVEseUJBQVMsUUFBakN6QixDQUFUO0FBQUEsTUFFQSxPQUFBZSxNQUFBLHFCQUFBQSxPQUFBQSxFQUFBQSxDQUFVVSxNQUFWVixDQUFBQSxFQWxESixpQkFBQSxFQUFBOztBQUFBLE1Ba0R3QixXQUFBVixNQUFBQSxDQUFLVyxHQUFMWCxDQUFBWSxLQUFBQSxDQUFBQSxDQWxEeEIsbUJBQUEsa0JBQUEsTUFrRElGLENBQUFHLE1BQUFBLENBQUFBLENBQUFDLFFBQUFBLENBQWdELFlBQWhEQSxDQUZBO0FBREZLLElBQUFBLENBQUFBLDZCQUFBQSxDQTdDQTtBQUFBO0FBbURBbkIsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxLQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFyREYsTUFBQTtBQUFBO0FBdURBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBWVMsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEscUJBQUEsR0FBQSxDQUFzQlIsS0FBdEIsQ0FBckJRO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBa0Isb0JBQUFkLGVBQUFBLENBQWdCTSxPQUFPLHlCQUFTLFFBQWhDTixDQUF5Qzs7QUFFM0Q7QUFDQSxjQUFZYyxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXNCUixLQUF0QixDQUFyQlE7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsSUFqSEE7QUFxREVULElBQUFBLENBQUFBLDhCQUFBQSxDQW5EQTtBQUFBLElBa0hBLE9BQUFxQixDQUFBQSxVQUFJdEIsSUFBSnNCLGlCQUFBQSwwQkFBQUEsU0FBb0IsU0FBcEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUMsY0FBZ0JDLFNBQWpCO0FBQUEsTUFFQSxJQUFBLFlBQUdDLG1CQUFBQSxDQUFlLFNBQWZBLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQSx1QkFBQTFCLFFBQUFBLENBQUFBO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQTJCLFdBQUFBLENBQVUsZUFBVWQsS0FBQUEsS0FBSWpCLFVBQUFBLENBQUFBLENBQUppQixDQUFwQmM7QUFIRixNQUFBLENBRkE7QUFERkgsSUFBQUEsQ0FBQUEscUNBQUFBLENBQUFBLHNCQWxIQTtBQURGL0IsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjcwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL01lcnNlbm5lVHdpc3Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG5kb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxuPGRhdmVoZWl0em1hbkB5YWhvby5jb20+LCBzdWJzZXF1ZW50bHkgcmVhZGFwdGVkIGZyb20gYW4gdXBkYXRlZCB2ZXJzaW9uIG9mXG5ydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cblxuVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuXG4gIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4gIGNvbnRhY3QgPGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sPi5cblxuICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxuXG4gICAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMi8xMC5cbiAgICAgQ29kZWQgYnkgVGFrdWppIE5pc2hpbXVyYSBhbmQgTWFrb3RvIE1hdHN1bW90by5cbiAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiAgICAgTWF0dGhlIEJlbGxldydzIHNpbXBsaWZpY2F0aW9uLCBJc2FrdSBXYWRhJ3MgcmVhbCB2ZXJzaW9uLlxuXG4gICAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9nZW5yYW5kKG10LCBzZWVkKVxuICAgICBvciBpbml0X2J5X2FycmF5KG10LCBpbml0X2tleSwga2V5X2xlbmd0aCkuXG5cbiAgICAgQ29weXJpZ2h0IChDKSAxOTk3IC0gMjAwMiwgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSxcbiAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgIGFyZSBtZXQ6XG5cbiAgICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAgICAzLiBUaGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlXG4gICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4gICAgICAgICAgcGVybWlzc2lvbi5cblxuICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gICAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gICAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuICAgICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cblxuICAgICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuICAgICBodHRwOi8vd3d3Lm1hdGgua2Vpby5hYy5qcC9tYXR1bW90by9lbXQuaHRtbFxuICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG4qL1xudmFyIE1lcnNlbm5lVHdpc3RlciA9IChmdW5jdGlvbigpIHtcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgdmFyIE4gPSA2MjQ7XG4gIHZhciBNID0gMzk3O1xuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gIHZhciBVTUFTSyA9IDB4ODAwMDAwMDA7ICAgICAgICAgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICB2YXIgTE1BU0sgPSAweDdmZmZmZmZmOyAgICAgICAgIC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xuICB2YXIgVFdJU1QgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuIChNSVhCSVRTKCh1KSwodikpID4+PiAxKSBeICgodiAmIDB4MSkgPyBNQVRSSVhfQSA6IDB4MCk7IH07XG5cbiAgZnVuY3Rpb24gaW5pdChzKSB7XG4gICAgdmFyIG10ID0ge2xlZnQ6IDAsIG5leHQ6IE4sIHN0YXRlOiBuZXcgQXJyYXkoTil9O1xuICAgIGluaXRfZ2VucmFuZChtdCwgcyk7XG4gICAgcmV0dXJuIG10O1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbiAgZnVuY3Rpb24gaW5pdF9nZW5yYW5kKG10LCBzKSB7XG4gICAgdmFyIGosIGk7XG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xuICAgIGZvciAoaj0xOyBqPE47IGorKykge1xuICAgICAgbXQuc3RhdGVbal0gPSAoMTgxMjQzMzI1MyAqICgobXQuc3RhdGVbai0xXSBeIChtdC5zdGF0ZVtqLTFdID4+IDMwKSA+Pj4gMCkpICsgaik7XG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBzdGF0ZVtdLiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgIG10LnN0YXRlW2pdICY9IDB4ZmZmZmZmZmY7ICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgIH1cbiAgICBtdC5sZWZ0ID0gMTtcbiAgICBtdC5uZXh0ID0gTjtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgZnVuY3Rpb24gbmV4dF9zdGF0ZShtdCkge1xuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcbiAgICB2YXIgajtcblxuICAgIG10LmxlZnQgPSBOO1xuICAgIG10Lm5leHQgPSAwO1xuXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTSldIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgZnVuY3Rpb24gZ2VucmFuZF9pbnQzMihtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgeTtcblxuICAgIGlmICgtLW10LmxlZnQgPD0gMCkgbmV4dF9zdGF0ZShtdCk7XG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XG5cbiAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICB5IF49ICh5ID4+PiAxMSk7XG4gICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgIHkgXj0gKHkgPj4+IDE4KTtcblxuICAgIHJldHVybiB5ID4+PiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYikge1xuICAgIGEgPj4+PSA1O1xuICAgIGIgPj4+PSA2O1xuICAgIHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgYSA9IGdlbnJhbmRfaW50MzIobXQpLCBiID0gZ2VucmFuZF9pbnQzMihtdCk7XG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcbn0pKCk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3JhbmRvbS9NZXJzZW5uZVR3aXN0ZXIuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVFO0FBQ0E7O0FBRUE7O0FBRUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFRTtBQUNHOztBQUVIO0FBQ0c7QUFDQTs7QUFFSDtBQUNHO0FBQ0E7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0w7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0EifX0seyJvZmZzZXQiOnsibGluZSI6MjI4NDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLmpzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL01lcnNlbm5lVHdpc3RlcidcblxuY2xhc3MgUmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgTUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gTWVyc2VubmVUd2lzdGVyLmluaXQoc2VlZCk7IH0sXG4gICAgcmFuZDogZnVuY3Rpb24obXQpIHsgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiJHdyaXRlciIsImdlbmVyYXRvcj0iLCJzZWxmIiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsZ0NBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLDREQUFEO0FBQUEsSUFFQSwwREFBOEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FKRSxDQUZBO0FBQUE7QUFKRixJQUFBQyxVQUFBLENBWW1CLDBDQVpuQixDQUFBO0FBQUEsSUFZRUMsTUFBQUMsSUFBQUQsY0FBQUEsRUFaRixVQUFBRCxPQUFBLENBWUVDLENBWkY7QUFBQSxJQUFBLE9BQUFELE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBSUU7QUFERkosRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyODcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAje0tlcm5lbC5yYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICBkZWYgPDwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJzw8J1xuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NhcGl0YWxpemUhJ1xuICBlbmRcblxuICBkZWYgY2hvbXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9tcCEnXG4gIGVuZFxuXG4gIGRlZiBjaG9wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvcCEnXG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Rvd25jYXNlISdcbiAgZW5kXG5cbiAgZGVmIGdzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdnc3ViISdcbiAgZW5kXG5cbiAgZGVmIGxzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2xzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBuZXh0ISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbmV4dCEnXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncmV2ZXJzZSEnXG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NsaWNlISdcbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzcXVlZXplISdcbiAgZW5kXG5cbiAgZGVmIHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3ViISdcbiAgZW5kXG5cbiAgZGVmIHN1Y2MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWNjISdcbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3dhcGNhc2UhJ1xuICBlbmRcblxuICBkZWYgdHIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0ciEnXG4gIGVuZFxuXG4gIGRlZiB0cl9zISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHJfcyEnXG4gIGVuZFxuXG4gIGRlZiB1cGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1cGNhc2UhJ1xuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncHJlcGVuZCdcbiAgZW5kXG5cbiAgZGVmIFtdPSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnW109J1xuICBlbmRcblxuICBkZWYgY2xlYXIoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NsZWFyJ1xuICBlbmRcblxuICBkZWYgZW5jb2RlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZW5jb2RlISdcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndW5pY29kZV9ub3JtYWxpemUhJ1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCBmcmVlemluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgZnJlZXplXG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCopXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZV9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIGV2YWwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKilcbiAgIyBzdHViXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqKVxuICAjIHN0dWJcbmVuZFxuIl0sIm5hbWVzIjpbInJhaXNlIiwid2FybiIsImNsYXNzIiwiPDwiLCIlIiwiY2FwaXRhbGl6ZSEiLCJjaG9tcCEiLCJjaG9wISIsImRvd25jYXNlISIsImdzdWIhIiwibHN0cmlwISIsIm5leHQhIiwicmV2ZXJzZSEiLCJzbGljZSEiLCJzcXVlZXplISIsInN0cmlwISIsInN1YiEiLCJzdWNjISIsInN3YXBjYXNlISIsInRyISIsInRyX3MhIiwidXBjYXNlISIsInByZXBlbmQiLCJbXT0iLCJjbGVhciIsImVuY29kZSEiLCJ1bmljb2RlX25vcm1hbGl6ZSEiLCJtb2R1bGUiLCJmcmVlemUiLCJzZWxmIiwiZnJvemVuPyIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFRLHNCQUFBQSxPQUFBQSxDQUFhLHFDQUFzQixPQUFuQ0E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTUMsTUFBQUEsQ0FBTSxNQUFOQSxDQUFlO0FBQ3JCO0FBdkJBO0FBQUEsRUEwQkFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLHdGQUFE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TUV1QyxJQUFBQSxDQUFBQSw4QkFBQUE7QUFERlosRUFBQUEsR0FBQUEsV0FBQUEsV0ExTUE7QUFBQSxFQWlOQU8sVUFBSUwsSUFBSkssYUFBQUEsYUFBQUEsU0FsTkEsRUFrTkFBO0FBQUFBLElBQUFBOztBQUFBQTtBQWxOQTtBQUFBLElBQUEsNERBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQSxPQUFBLEdBQUE7QUFrTkFBLEVBQUFBLENBQUFBLHlCQUFBQSxDQWpOQTtBQUFBLEVBcU5BLE9BQUFNLENBQUFBLFVBQUlYLElBQUpXLGNBQUFBLGNBQUFBLFNBdE5BLEVBc05BQTtBQUFBQSxJQUFBQTs7QUFBQUE7QUF0TkE7QUFBQSxJQUFBLDREQUFBO0FBQUEsSUFBQTtBQUFBLElBQUEsT0FBQSxHQUFBO0FBc05BQSxFQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQUEsbUJBck5BOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjMzMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbC9iYXNlJ1xucmVxdWlyZSAnb3BhbC9taW5pJ1xuXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXG5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcbnJlcXVpcmUgJ2NvcmVsaWIvbWF0aCdcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleCdcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwnXG5yZXF1aXJlICdjb3JlbGliL3RpbWUnXG5yZXF1aXJlICdjb3JlbGliL3N0cnVjdCdcbnJlcXVpcmUgJ2NvcmVsaWIvaW8nXG5yZXF1aXJlICdjb3JlbGliL21haW4nXG5yZXF1aXJlICdjb3JlbGliL2RpcidcbnJlcXVpcmUgJ2NvcmVsaWIvZmlsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2VzcydcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tJ1xucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3Rlci5qcydcblxucmVxdWlyZSAnY29yZWxpYi91bnN1cHBvcnRlZCdcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLFdBQVJBLENBREE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLHVCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSx5QkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FMQTtBQUFBLE1BTUFBLFNBQUFBLENBQVEsaUJBQVJBLENBTkE7QUFBQSxNQU9BQSxTQUFBQSxDQUFRLGtCQUFSQSxDQVBBO0FBQUEsTUFRQUEsU0FBQUEsQ0FBUSxjQUFSQSxDQVJBO0FBQUEsTUFTQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsWUFBUkEsQ0FWQTtBQUFBLE1BV0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FYQTtBQUFBLE1BWUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FaQTtBQUFBLE1BYUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FiQTtBQUFBLE1BY0FBLFNBQUFBLENBQVEsaUJBQVJBLENBZEE7QUFBQSxNQWVBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWZBO0FBQUEsTUFnQkFBLFNBQUFBLENBQVEsb0NBQVJBLENBaEJBO0FBQUEsRUFrQkEsV0FBQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FsQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzMzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4veWFtbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ3YXJuIFwiUkVNT1ZFRDogdXNlIGByZXF1aXJlICdub2RlanMveWFtbCdgIGluc3RlYWRcIlxuIl0sIm5hbWVzIjpbIndhcm4iXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsV0FBQUEsTUFBQUEsQ0FBSyw4Q0FBTEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzMzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvY29uZmlndXJhdGlvbi9wcm9wZXJ0aWVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBSYW1ibGluZ1xuICBtb2R1bGUgVHJpZVxuICAgIG1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAgICAjIFByb3ZpZGVzIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGZvciBSYW1ibGluZzo6VHJpZS5cbiAgICAgIGNsYXNzIFByb3BlcnRpZXNcbiAgICAgICAgIyBUaGUgY29uZmlndXJlZCB7UmVhZGVycyBSZWFkZXJzfS5cbiAgICAgICAgIyBAcmV0dXJuIFtQcm92aWRlckNvbGxlY3Rpb25dIHRoZSBtYXBwaW5nIG9mIGNvbmZpZ3VyZWQge1JlYWRlcnNcbiAgICAgICAgIyAgIFJlYWRlcnN9LlxuICAgICAgICBhdHRyX3JlYWRlciA6cmVhZGVyc1xuXG4gICAgICAgICMgVGhlIGNvbmZpZ3VyZWQge1NlcmlhbGl6ZXJzIFNlcmlhbGl6ZXJzfS5cbiAgICAgICAgIyBAcmV0dXJuIFtQcm92aWRlckNvbGxlY3Rpb25dIHRoZSBtYXBwaW5nIG9mIGNvbmZpZ3VyZWQge1NlcmlhbGl6ZXJzXG4gICAgICAgICMgICBTZXJpYWxpemVyc30uXG4gICAgICAgIGF0dHJfcmVhZGVyIDpzZXJpYWxpemVyc1xuXG4gICAgICAgICMgVGhlIGNvbmZpZ3VyZWQge0NvbXByZXNzb3IgQ29tcHJlc3Nvcn0uXG4gICAgICAgICMgQHJldHVybiBbQ29tcHJlc3Nvcl0gdGhlIGNvbmZpZ3VyZWQgY29tcHJlc3Nvci5cbiAgICAgICAgYXR0cl9hY2Nlc3NvciA6Y29tcHJlc3NvclxuXG4gICAgICAgICMgVGhlIGNvbmZpZ3VyZWQgcm9vdF9idWlsZGVyLCB3aGljaCBzaG91bGQgcmV0dXJuIGEge05vZGVzOjpOb2RlIE5vZGV9XG4gICAgICAgICMgICB3aGVuIGNhbGxlZC5cbiAgICAgICAgIyBAcmV0dXJuIFtQcm9jPE5vZGVzOjpOb2RlPl0gdGhlIGNvbmZpZ3VyZWQgcm9vdF9idWlsZGVyLlxuICAgICAgICBhdHRyX2FjY2Vzc29yIDpyb290X2J1aWxkZXJcblxuICAgICAgICAjIFRoZSBjb25maWd1cmVkIHRtcF9wYXRoLCB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIHRocm93YXdheSBmaWxlcy5cbiAgICAgICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBjb25maWd1cmVkIHRtcF9wYXRoLlxuICAgICAgICBhdHRyX2FjY2Vzc29yIDp0bXBfcGF0aFxuXG4gICAgICAgICMgUmV0dXJucyBhIG5ldyBwcm9wZXJ0aWVzIGluc3RhbmNlLlxuICAgICAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgICAgIHJlc2V0XG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgUmVzZXRzIGJhY2sgdG8gZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgICBkZWYgcmVzZXRcbiAgICAgICAgICByZXNldF9yZWFkZXJzXG4gICAgICAgICAgcmVzZXRfc2VyaWFsaXplcnNcblxuICAgICAgICAgIEBjb21wcmVzc29yID0gUmFtYmxpbmc6OlRyaWU6OkNvbXByZXNzb3IubmV3XG4gICAgICAgICAgQHJvb3RfYnVpbGRlciA9IC0+IHsgUmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpSYXcubmV3IH1cbiAgICAgICAgICBAdG1wX3BhdGggPSAnL3RtcCdcbiAgICAgICAgZW5kXG5cbiAgICAgICAgcHJpdmF0ZVxuXG4gICAgICAgIGF0dHJfd3JpdGVyIDpyZWFkZXJzLCA6c2VyaWFsaXplcnNcblxuICAgICAgICBkZWYgcmVzZXRfcmVhZGVyc1xuICAgICAgICAgIHBsYWluX3RleHRfcmVhZGVyID0gUmFtYmxpbmc6OlRyaWU6OlJlYWRlcnM6OlBsYWluVGV4dC5uZXdcblxuICAgICAgICAgIEByZWFkZXJzID0gUmFtYmxpbmc6OlRyaWU6OkNvbmZpZ3VyYXRpb246OlByb3ZpZGVyQ29sbGVjdGlvbi5uZXcoXG4gICAgICAgICAgICA6cmVhZGVyLFxuICAgICAgICAgICAgdHh0OiBwbGFpbl90ZXh0X3JlYWRlcixcbiAgICAgICAgICApXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiByZXNldF9zZXJpYWxpemVyc1xuICAgICAgICAgIG1hcnNoYWxfc2VyaWFsaXplciA9IFJhbWJsaW5nOjpUcmllOjpTZXJpYWxpemVyczo6TWFyc2hhbC5uZXdcbiAgICAgICAgICB5YW1sX3NlcmlhbGl6ZXIgPSBSYW1ibGluZzo6VHJpZTo6U2VyaWFsaXplcnM6OllhbWwubmV3XG4gICAgICAgICAgemlwX3NlcmlhbGl6ZXIgPSBSYW1ibGluZzo6VHJpZTo6U2VyaWFsaXplcnM6OlppcC5uZXcgc2VsZiB1bmxlc3MgUlVCWV9FTkdJTkUgPT0gJ29wYWwnXG5cbiAgICAgICAgICBpZiBSVUJZX0VOR0lORSA9PSAnb3BhbCdcbiAgICAgICAgICAgIEBzZXJpYWxpemVycyA9IFJhbWJsaW5nOjpUcmllOjpDb25maWd1cmF0aW9uOjpQcm92aWRlckNvbGxlY3Rpb24ubmV3KFxuICAgICAgICAgICAgICA6c2VyaWFsaXplcixcbiAgICAgICAgICAgICAgbWFyc2hhbDogbWFyc2hhbF9zZXJpYWxpemVyLFxuICAgICAgICAgICAgICB5bWw6IHlhbWxfc2VyaWFsaXplcixcbiAgICAgICAgICAgICAgeWFtbDogeWFtbF9zZXJpYWxpemVyLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBzZXJpYWxpemVycyA9IFJhbWJsaW5nOjpUcmllOjpDb25maWd1cmF0aW9uOjpQcm92aWRlckNvbGxlY3Rpb24ubmV3KFxuICAgICAgICAgICAgICA6c2VyaWFsaXplcixcbiAgICAgICAgICAgICAgbWFyc2hhbDogbWFyc2hhbF9zZXJpYWxpemVyLFxuICAgICAgICAgICAgICB5bWw6IHlhbWxfc2VyaWFsaXplcixcbiAgICAgICAgICAgICAgeWFtbDogeWFtbF9zZXJpYWxpemVyLFxuICAgICAgICAgICAgICB6aXA6IHppcF9zZXJpYWxpemVyLFxuICAgICAgICAgICAgKSAgICAgICAgICAgIFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJhdHRyX2FjY2Vzc29yIiwiaW5pdGlhbGl6ZSIsInJlc2V0IiwicmVzZXRfcmVhZGVycyIsInJlc2V0X3NlcmlhbGl6ZXJzIiwiQGNvbXByZXNzb3IiLCJuZXciLCJAcm9vdF9idWlsZGVyIiwiQHRtcF9wYXRoIiwicHJpdmF0ZSIsImF0dHJfd3JpdGVyIiwicGxhaW5fdGV4dF9yZWFkZXIiLCJAcmVhZGVycyIsIm1hcnNoYWxfc2VyaWFsaXplciIsInlhbWxfc2VyaWFsaXplciIsIj09IiwiQHNlcmlhbGl6ZXJzIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRUVDO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFJRSxjQUFBQyxhQUFBQSxDQUFZLFNBQVpBLENBQUE7QUFBQSxjQUtBQSxhQUFBQSxDQUFZLGFBQVpBLENBTEE7QUFBQSxjQVNBQyxlQUFBQSxDQUFjLFlBQWRBLENBVEE7QUFBQSxjQWNBQSxlQUFBQSxDQUFjLGNBQWRBLENBZEE7QUFBQSxjQWtCQUEsZUFBQUEsQ0FBYyxVQUFkQSxDQWxCQTtBQUFBO0FBcUJBQyxVQUFBQSw4QkFBQUEsMkJBQUFBLHNCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxXQUFBQyxPQUFBQSxDQUFBQTtBQURGRCxVQUFBQSxDQUFBQSxzQ0FBQUEsQ0FyQkE7QUFBQTtBQTBCQUMsVUFBQUEseUJBQUFBLHNCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBQ0UsZ0JBQUFDLGVBQUFBLENBQUFBLENBQUE7QUFBQSxnQkFDQUMsbUJBQUFBLENBQUFBLENBREE7QUFBQSxZQUdBQyxrQkFBYyxJQUFBLElBQUEsd0JBQUEsU0FBQSxlQUFBQyxLQUFBQSxDQUFBQSxDQUhkO0FBQUEsWUFJQUMsb0JBQWdCLFFBMUMxQixnQkFBQSxFQUFBOztBQUFBLFlBMEMrQixPQUFBLElBQUEsSUFBQSxJQUFBLHdCQUFBLFNBQUEsVUFBQSxRQUFBRCxLQUFBQSxDQUFBQSxDQTFDL0Isa0JBQUEsaUJBQUEsS0EwQzBCLENBSmhCO0FBQUEsWUFLQSxPQUFBRSxDQUFBQSxnQkFBWSxNQUFaQSxDQUxBO0FBREZOLFVBQUFBLENBQUFBLGlDQUFBQSxDQTFCQTtBQUFBLGNBbUNBTyxTQUFBQSxDQUFBQSxDQW5DQTtBQUFBLGNBcUNBQyxhQUFBQSxDQUFZLFdBQVUsYUFBdEJBLENBckNBO0FBQUE7QUF1Q0FQLFVBQUFBLGlDQUFBQSw4QkFBQUEseUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQTtBQUNFLFlBQUFRLG9CQUFvQixJQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLFlBQUEsY0FBQUwsS0FBQUEsQ0FBQUEsQ0FBcEI7QUFBQSxZQUVBLE9BQUFNLENBQUFBLGVBQVcsSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxrQkFBQSx1QkFBQU4sS0FBQUEsQ0FDVCxVQUNBLGlCQUFBLE9BQUtLLGlCQUFMLEVBRlNMLENBQVhNLENBRkE7QUFERlQsVUFBQUEsQ0FBQUEseUNBQUFBLENBdkNBO0FBQUEsVUFnREEsT0FBQUMsQ0FBQUEscUNBQUFBLGtDQUFBQSw2QkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBQ0UsWUFBQVMscUJBQXFCLElBQUEsSUFBQSxJQUFBLHdCQUFBLFNBQUEsZ0JBQUEsWUFBQVAsS0FBQUEsQ0FBQUEsQ0FBckI7QUFBQSxZQUNBUSxrQkFBa0IsSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxnQkFBQSxTQUFBUixLQUFBQSxDQUFBQSxDQURsQjtBQUFBLFlBRUEsSUFBa0UsMkJBQUFTLE9BQUFBLENBQWUsTUFBZkEsQ0FBbEU7QUFBQSxZQUFBO0FBQUEsY0FBQTtBQUFBLFlBQUEsQ0FGQTtBQUFBLFlBSUEsSUFBRywyQkFBQUEsT0FBQUEsQ0FBZSxNQUFmQSxDQUFIO0FBQUEsY0FDRSxPQUFBQyxDQUFBQSxtQkFBZSxJQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLGtCQUFBLHVCQUFBVixLQUFBQSxDQUNiLGNBQ0Esb0NBQUEsV0FBU08sa0JBQVQsRUFBQSxPQUNLQyxlQURMLEVBQUEsUUFFTUEsZUFGTixFQUZhUixDQUFmVTtBQURGLFlBQUE7QUFBQSxjQUFBLE9BQUE7QUFBQSxZQUFBLENBSkE7QUFERlosVUFBQUEsQ0FBQUEsNkNBQUFBLENBQUFBLDZCQWhEQTtBQUpGTixRQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZGRCxNQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNDIxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmFtYmxpbmcvdHJpZS9jb25maWd1cmF0aW9uL3Byb3ZpZGVyX2NvbGxlY3Rpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgbW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICAgICMgQ29sbGVjdGlvbiBvZiBjb25maWd1cmFibGUgcHJvdmlkZXJzLlxuICAgICAgY2xhc3MgUHJvdmlkZXJDb2xsZWN0aW9uXG4gICAgICAgICMgVGhlIG5hbWUgb2YgdGhpcyBwcm92aWRlciBjb2xsZWN0aW9uLlxuICAgICAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhpcyBwcm92aWRlciBjb2xsZWN0aW9uLlxuICAgICAgICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gICAgICAgICMgQG92ZXJsb2FkIGRlZmF1bHRcbiAgICAgICAgIyAgIFRoZSBkZWZhdWx0IHByb3ZpZGVyLiBVc2VkIHdoZW4gYSBwcm92aWRlciBjYW5ub3QgYmUgcmVzb2x2ZWQgaW5cbiAgICAgICAgIyAgIHtQcm92aWRlckNvbGxlY3Rpb24jcmVzb2x2ZSAjcmVzb2x2ZX0uXG4gICAgICAgICMgQG92ZXJsb2FkIGRlZmF1bHQ9KHByb3ZpZGVyKVxuICAgICAgICAjICAgU2V0cyB0aGUgZGVmYXVsdCBwcm92aWRlci4gTmVlZHMgdG8gYmUgb25lIG9mIHRoZSBjb25maWd1cmVkXG4gICAgICAgICMgICBwcm92aWRlcnMuXG4gICAgICAgICMgICBAcGFyYW0gW09iamVjdF0gcHJvdmlkZXIgdGhlIHByb3ZpZGVyIHRvIHVzZSBhcyBkZWZhdWx0LlxuICAgICAgICAjICAgQHJhaXNlIFtBcmd1bWVudEVycm9yXSB3aGVuIHRoZSBnaXZlbiBwcm92aWRlciBpcyBub3QgaW4gdGhlXG4gICAgICAgICMgICAgIHByb3ZpZGVyIGNvbGxlY3Rpb24uXG4gICAgICAgICMgICBAbm90ZSBJZiBubyBwcm92aWRlcnMgaGF2ZSBiZWVuIGNvbmZpZ3VyZWQsIGBuaWxgIHdpbGwgYmUgYXNzaWduZWQuXG4gICAgICAgICMgQHJldHVybiBbT2JqZWN0LCBuaWxdIHRoZSBkZWZhdWx0IHByb3ZpZGVyIHRvIHVzZSB3aGVuIGEgcHJvdmlkZXJcbiAgICAgICAgIyAgIGNhbm5vdCBiZSByZXNvbHZlZCBpbiB7UHJvdmlkZXJDb2xsZWN0aW9uI3Jlc29sdmUgI3Jlc29sdmV9LlxuICAgICAgICBhdHRyX3JlYWRlciA6ZGVmYXVsdFxuXG4gICAgICAgICMgQ3JlYXRlcyBhIG5ldyBwcm92aWRlciBjb2xsZWN0aW9uLlxuICAgICAgICAjIEBwYXJhbSBbU3RyaW5nXSBuYW1lIHRoZSBuYW1lIGZvciB0aGlzIHByb3ZpZGVyIGNvbGxlY3Rpb24uXG4gICAgICAgICMgQHBhcmFtIFtIYXNoXSBwcm92aWRlcnMgdGhlIGNvbmZpZ3VyZWQgcHJvdmlkZXJzLlxuICAgICAgICAjIEBwYXJhbSBbT2JqZWN0XSBkZWZhdWx0IHRoZSBjb25maWd1cmVkIGRlZmF1bHQgcHJvdmlkZXIuXG4gICAgICAgIGRlZiBpbml0aWFsaXplIG5hbWUsIHByb3ZpZGVycyA9IHt9LCBkZWZhdWx0ID0gbmlsXG4gICAgICAgICAgQG5hbWUgPSBuYW1lXG4gICAgICAgICAgQGNvbmZpZ3VyZWRfcHJvdmlkZXJzID0gcHJvdmlkZXJzXG4gICAgICAgICAgQGNvbmZpZ3VyZWRfZGVmYXVsdCA9IGRlZmF1bHQgfHwgcHJvdmlkZXJzLnZhbHVlcy5maXJzdFxuXG4gICAgICAgICAgcmVzZXRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBBZGRzIGEgbmV3IHByb3ZpZGVyIHRvIHRoZSBwcm92aWRlciBjb2xsZWN0aW9uLlxuICAgICAgICAjIEBwYXJhbSBbU3ltYm9sXSBleHRlbnNpb24gdGhlIGV4dGVuc2lvbiB0aGF0IHRoZSBwcm92aWRlciB3aWxsXG4gICAgICAgICMgICBjb3JyZXNwb25kIHRvLlxuICAgICAgICAjIEBwYXJhbSBbcHJvdmlkZXJdIHByb3ZpZGVyIHRoZSBwcm92aWRlciB0byBhZGQgdG8gdGhlIHByb3ZpZGVyXG4gICAgICAgICMgICBjb2xsZWN0aW9uLlxuICAgICAgICBkZWYgYWRkIGV4dGVuc2lvbiwgcHJvdmlkZXJcbiAgICAgICAgICBwcm92aWRlcnNbZXh0ZW5zaW9uXSA9IHByb3ZpZGVyXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBkZWZhdWx0PSBwcm92aWRlclxuICAgICAgICAgIHVubGVzcyBjb250YWlucz8gcHJvdmlkZXJcbiAgICAgICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsXG4gICAgICAgICAgICAgIFwiZGVmYXVsdCAje25hbWV9IHNob3VsZCBiZSBwYXJ0IG9mIGNvbmZpZ3VyZWQgI3tuYW1lfXNcIlxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgQGRlZmF1bHQgPSBwcm92aWRlclxuICAgICAgICBlbmRcblxuICAgICAgICAjIExpc3Qgb2YgY29uZmlndXJlZCBwcm92aWRlcnMuXG4gICAgICAgICMgQHJldHVybiBbSGFzaF0gdGhlIG1hcHBpbmcgb2YgZXh0ZW5zaW9ucyB0byB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAgICAgICMgICBwcm92aWRlcnMuXG4gICAgICAgIGRlZiBwcm92aWRlcnNcbiAgICAgICAgICBAcHJvdmlkZXJzIHx8PSB7fVxuICAgICAgICBlbmRcblxuICAgICAgICAjIFJlc29sdmVzIHRoZSBwcm92aWRlciBmcm9tIGEgZmlsZXBhdGggYmFzZWQgb24gdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICAjIEBwYXJhbSBbU3RyaW5nXSBmaWxlcGF0aCB0aGUgZmlsZXBhdGggdG8gcmVzb2x2ZSBpbnRvIGEgcHJvdmlkZXIuXG4gICAgICAgICMgQHJldHVybiBbT2JqZWN0XSB0aGUgcHJvdmlkZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZmlsZSBleHRlbnNpb24gaW5cbiAgICAgICAgIyAgIHRoaXMgcHJvdmlkZXIgY29sbGVjdGlvbi4geyNkZWZhdWx0fSBpZiBub3QgZm91bmQuXG4gICAgICAgIGRlZiByZXNvbHZlIGZpbGVwYXRoXG4gICAgICAgICAgcHJvdmlkZXJzW2ZpbGVfZm9ybWF0IGZpbGVwYXRoXSB8fCBkZWZhdWx0XG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgUmVzZXRzIHRoZSBwcm92aWRlciBjb2xsZWN0aW9uIHRvIHRoZSBpbml0aWFsIHZhbHVlcy5cbiAgICAgICAgZGVmIHJlc2V0XG4gICAgICAgICAgcHJvdmlkZXJzLmNsZWFyXG4gICAgICAgICAgY29uZmlndXJlZF9wcm92aWRlcnMuZWFjaCB7IHxrLCB2fCBzZWxmW2tdID0gdiB9XG4gICAgICAgICAgc2VsZi5kZWZhdWx0ID0gY29uZmlndXJlZF9kZWZhdWx0XG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgR2V0IHByb3ZpZGVyIGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBmb3JtYXQuXG4gICAgICAgICMgQHJldHVybiBbQXJyYXk8U3ltYm9sPl0gdGhlIHByb3ZpZGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBmb3JtYXQuXG4gICAgICAgICMgQHNlZSBodHRwczovL3J1YnktZG9jLm9yZy9jb3JlLTIuNS4wL0hhc2guaHRtbCNtZXRob2QtaS01Qi01RFxuICAgICAgICAjICAgSGFzaCNrZXlzXG4gICAgICAgIGRlZiBmb3JtYXRzXG4gICAgICAgICAgcHJvdmlkZXJzLmtleXNcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBHZXQgcHJvdmlkZXIgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGZvcm1hdC5cbiAgICAgICAgIyBAcGFyYW0gW1N5bWJvbF0gZm9ybWF0IHRoZSBmb3JtYXQgdG8gc2VhcmNoIGZvciBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgIyBAcmV0dXJuIFtPYmplY3RdIHRoZSBwcm92aWRlciBjb3JyZXNwb25kaW5nIHRvIHRoYXQgZm9ybWF0LlxuICAgICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9IYXNoLmh0bWwjbWV0aG9kLWktNUItNURcbiAgICAgICAgIyAgIEhhc2gjW11cbiAgICAgICAgZGVmIFtdIGZvcm1hdFxuICAgICAgICAgIHByb3ZpZGVyc1tmb3JtYXRdXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHByaXZhdGVcblxuICAgICAgICBhdHRyX3JlYWRlciA6Y29uZmlndXJlZF9wcm92aWRlcnMsIDpjb25maWd1cmVkX2RlZmF1bHRcblxuICAgICAgICBkZWYgW109IGZvcm1hdCwgaW5zdGFuY2VcbiAgICAgICAgICBwcm92aWRlcnNbZm9ybWF0XSA9IGluc3RhbmNlXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiB2YWx1ZXNcbiAgICAgICAgICBwcm92aWRlcnMudmFsdWVzXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBmaWxlX2Zvcm1hdCBmaWxlcGF0aFxuICAgICAgICAgIGZvcm1hdCA9IEZpbGUuZXh0bmFtZSBmaWxlcGF0aFxuICAgICAgICAgIGZvcm1hdC5zbGljZSEgMFxuICAgICAgICAgIGZvcm1hdC50b19zeW1cbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGNvbnRhaW5zPyBwcm92aWRlclxuICAgICAgICAgIHByb3ZpZGVyLm5pbD8gfHxcbiAgICAgICAgICAgIChwcm92aWRlcnMuYW55PyAmJiBwcm92aWRlcl9pbnN0YW5jZXMuaW5jbHVkZT8ocHJvdmlkZXIpKVxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOnByb3ZpZGVyX2luc3RhbmNlcywgOnZhbHVlc1xuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAbmFtZSIsIm5hbWUiLCJAY29uZmlndXJlZF9wcm92aWRlcnMiLCJwcm92aWRlcnMiLCJAY29uZmlndXJlZF9kZWZhdWx0IiwiZGVmYXVsdCQiLCJ2YWx1ZXMiLCJmaXJzdCIsInJlc2V0IiwiYWRkIiwiJHdyaXRlciIsImV4dGVuc2lvbiIsInByb3ZpZGVyIiwiW109IiwiLSIsIjEiLCJkZWZhdWx0PSIsImNvbnRhaW5zPyIsInJhaXNlIiwiQGRlZmF1bHQiLCJAcHJvdmlkZXJzIiwicmVzb2x2ZSIsIltdIiwiZmlsZV9mb3JtYXQiLCJmaWxlcGF0aCIsImRlZmF1bHQiLCJjbGVhciIsImVhY2giLCJjb25maWd1cmVkX3Byb3ZpZGVycyIsImsiLCJ2Iiwic2VsZiIsImNvbmZpZ3VyZWRfZGVmYXVsdCIsImZvcm1hdHMiLCJrZXlzIiwiZm9ybWF0IiwicHJpdmF0ZSIsImluc3RhbmNlIiwiZXh0bmFtZSIsInNsaWNlISIsIjAiLCJ0b19zeW0iLCJuaWw/IiwiYW55PyIsInByb3Zp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UUFBa0JDLG9CQUFBQSxDQUFBQSxDQUFBQyxhQUFBQSxDQUE0QmpDLFFBQTVCaUMsQ0FBbEIsTUFESDtBQURGNUIsVUFBQUEsQ0FBQUEsa0RBQUFBLENBdkdBO0FBQUEsVUE0R0EsV0FBQTZCLGNBQUFBLENBQWEsc0JBQXFCLFFBQWxDQSxDQTVHQTtBQUhGakQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzU3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvY29uZmlndXJhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5pZiBSVUJZX0VOR0lORSA9PSAnb3BhbCdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9jb25maWd1cmF0aW9uL3Byb3BlcnRpZXMnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvY29uZmlndXJhdGlvbi9wcm92aWRlcl9jb2xsZWN0aW9uJyAgXG5lbHNlXG4gICV3KHByb3BlcnRpZXMgcHJvdmlkZXJfY29sbGVjdGlvbikuZWFjaCBkbyB8ZmlsZXxcbiAgICByZXF1aXJlIEZpbGUuam9pbigncmFtYmxpbmcnLCAndHJpZScsICdjb25maWd1cmF0aW9uJywgZmlsZSlcbiAgZW5kXG5lbmRcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBOYW1lc3BhY2UgZm9yIGNvbmZpZ3VyYXRpb24gY2xhc3Nlcy5cbiAgICBtb2R1bGUgQ29uZmlndXJhdGlvblxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIj09IiwicmVxdWlyZSIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsRUFBQSxJQUFHLDJCQUFBQSxPQUFBQSxDQUFlLE1BQWZBLENBQUg7QUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsd0NBQVJBLENBQUE7QUFBQSxRQUNBQSxTQUFBQSxDQUFRLGlEQUFSQSxDQURBO0FBREYsRUFBQTtBQUFBLElBQUE7QUFBQSxFQUFBLENBQUE7QUFBQSxFQVNBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBLE1BQUFBLEdBQUFBLFdBQUFBO0FBRkZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBLFdBVEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzYxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvY29tcGFyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICAjIFByb3ZpZGVzIHRoZSBjb21wYXJhYmxlIGJlaGF2aW9yIGZvciB0aGUgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICBtb2R1bGUgQ29tcGFyYWJsZVxuICAgICAgIyBDb21wYXJlcyB0d28gbm9kZXMuXG4gICAgICAjIEBwYXJhbSBbTm9kZXM6Ok5vZGVdIG90aGVyIHRoZSBub2RlIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgICMgQHJldHVybiBbQm9vbGVhbl0gYHRydWVgIGlmIHRoZSBub2Rlcycge05vZGVzOjpOb2RlI2xldHRlciAjbGV0dGVyfSBhbmRcbiAgICAgICMgICB7Tm9kZXM6Ok5vZGUjY2hpbGRyZW5fdHJlZSAjY2hpbGRyZW5fdHJlZX0gYXJlIGVxdWFsLCBgZmFsc2VgXG4gICAgICAjICAgb3RoZXJ3aXNlLlxuICAgICAgZGVmID09IG90aGVyXG4gICAgICAgIGxldHRlciA9PSBvdGhlci5sZXR0ZXIgJiZcbiAgICAgICAgICB0ZXJtaW5hbD8gPT0gb3RoZXIudGVybWluYWw/ICYmXG4gICAgICAgICAgY2hpbGRyZW5fdHJlZSA9PSBvdGhlci5jaGlsZHJlbl90cmVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI9PSIsImxldHRlciIsIm90aGVyIiwidGVybWluYWw/IiwiY2hpbGRyZW5fdHJlZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQU1FQyxRQUFBQSxzQkFBQUEsdUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSxjQUFBLFdBQUFDLFFBQUFBLENBQUFBLENBQUFELE9BQUFBLENBQVVFLEtBQUFELFFBQUFBLENBQUFBLENBQVZELENBQUEsUUFDRUcsY0FBQUEsQ0FBQUEsQ0FBQUgsT0FBQUEsQ0FBYUUsS0FBQUMsY0FBQUEsQ0FBQUEsQ0FBYkgsQ0FERixPQUFBQyxRQUFBQSxDQUFBQSxDQUFBRCxPQUFBQSxDQUFVRSxLQUFBRCxRQUFBQSxDQUFBQSxDQUFWRCxDQUFBLENBQUEsUUFFRUksZUFBQUEsQ0FBQUEsQ0FBQUosT0FBQUEsQ0FBaUJFLEtBQUFFLGVBQUFBLENBQUFBLENBQWpCSixDQUZGO0FBREZBLFFBQUFBLENBQUFBLGtDQUFBQTtBQU5GRCxNQUFBQSxHQUFBQSxXQUFBQTtBQUZGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNjQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmFtYmxpbmcvdHJpZS9jb21wcmVzc2libGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBQcm92aWRlcyB0aGUgY29tcHJlc3NpYmxlIGJlaGF2aW9yIGZvciB0aGUgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICBtb2R1bGUgQ29tcHJlc3NpYmxlXG4gICAgICAjIEluZGljYXRlcyBpZiB0aGUgY3VycmVudCB7UmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpOb2RlIE5vZGV9IGNhbiBiZVxuICAgICAgIyBjb21wcmVzc2VkIG9yIG5vdC5cbiAgICAgICMgQHJldHVybiBbQm9vbGVhbl0gYHRydWVgIGZvciBub24te05vZGVzOjpOb2RlI3Rlcm1pbmFsPyB0ZXJtaW5hbH0gbm9kZXNcbiAgICAgICMgICB3aXRoIG9uZSBjaGlsZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICBkZWYgY29tcHJlc3NpYmxlP1xuICAgICAgICAhKHJvb3Q/IHx8IHRlcm1pbmFsPykgJiYgY2hpbGRyZW5fdHJlZS5zaXplID09IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNvbXByZXNzaWJsZT8iLCJyb290PyIsInRlcm1pbmFsPyIsIiEiLCJjaGlsZHJlbl90cmVlIiwic2l6ZSIsIj09IiwiMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUtFQyxRQUFBQSxpQ0FBQUEsb0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsY0FBRSxrQkFBQUMsVUFBQUEsQ0FBQUEsQ0FBQSxhQUFTQyxjQUFBQSxDQUFBQSxDQUFULENBQUZDLE1BQUFBLENBQUFBLENBQUEsUUFBeUJDLGVBQUFBLENBQUFBLENBQUFDLE1BQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQXNCQyxDQUF0QkQsQ0FBekI7QUFERk4sUUFBQUEsQ0FBQUEsK0NBQUFBO0FBTEZELE1BQUFBLEdBQUFBLFdBQUFBO0FBRkZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjM2NzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL2NvbXByZXNzb3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBSZXNwb25zaWJsZSBmb3IgdGhlIGNvbXByZXNzaW9uIHByb2Nlc3Mgb2YgYSB0cmllIGRhdGEgc3RydWN0dXJlLlxuICAgIGNsYXNzIENvbXByZXNzb3JcbiAgICAgICMgQ29tcHJlc3NlcyBhIHtOb2Rlczo6Tm9kZSBOb2RlfSBmcm9tIGEgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgICMgQHBhcmFtIFtOb2Rlczo6UmF3XSBub2RlIHRoZSBub2RlIHRvIGNvbXByZXNzLlxuICAgICAgIyBAcmV0dXJuIFtOb2Rlczo6Q29tcHJlc3NlZF0gbm9kZSB0aGUgY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBub2RlLlxuICAgICAgZGVmIGNvbXByZXNzIG5vZGVcbiAgICAgICAgaWYgbm9kZS5jb21wcmVzc2libGU/XG4gICAgICAgICAgY29tcHJlc3NfY2hpbGRfYW5kX21lcmdlIG5vZGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvbXByZXNzX2NoaWxkcmVuX2FuZF9jb3B5IG5vZGVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgcHJpdmF0ZVxuXG4gICAgICBkZWYgY29tcHJlc3NfY2hpbGRfYW5kX21lcmdlIG5vZGVcbiAgICAgICAgbWVyZ2Ugbm9kZSwgY29tcHJlc3Mobm9kZS5maXJzdF9jaGlsZClcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgbWVyZ2Ugbm9kZSwgb3RoZXJcbiAgICAgICAgbGV0dGVyID0gbm9kZS5sZXR0ZXIudG9fcyA8PCBvdGhlci5sZXR0ZXIudG9fc1xuXG4gICAgICAgIG5ld19jb21wcmVzc2VkX25vZGUoXG4gICAgICAgICAgbGV0dGVyLnRvX3N5bSxcbiAgICAgICAgICBub2RlLnBhcmVudCxcbiAgICAgICAgICBvdGhlci5jaGlsZHJlbl90cmVlLFxuICAgICAgICAgIG90aGVyLnRlcm1pbmFsPyxcbiAgICAgICAgKVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBjb21wcmVzc19jaGlsZHJlbl9hbmRfY29weSBub2RlXG4gICAgICAgIG5ld19jb21wcmVzc2VkX25vZGUoXG4gICAgICAgICAgbm9kZS5sZXR0ZXIsXG4gICAgICAgICAgbm9kZS5wYXJlbnQsXG4gICAgICAgICAgY29tcHJlc3NfY2hpbGRyZW4obm9kZS5jaGlsZHJlbl90cmVlKSxcbiAgICAgICAgICBub2RlLnRlcm1pbmFsPyxcbiAgICAgICAgKVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBjb21wcmVzc19jaGlsZHJlbiB0cmVlXG4gICAgICAgIG5ld190cmVlID0ge31cblxuICAgICAgICB0cmVlLmVhY2ggZG8gfGxldHRlciwgY2hpbGR8XG4gICAgICAgICAgY29tcHJlc3NlZF9jaGlsZCA9IGNvbXByZXNzIGNoaWxkXG4gICAgICAgICAgbmV3X3RyZWVbbGV0dGVyXSA9IGNvbXByZXNzZWRfY2hpbGRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgbmV3X3RyZWVcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgbmV3X2NvbXByZXNzZWRfbm9kZSBsZXR0ZXIsIHBhcmVudCwgdHJlZSwgdGVybWluYWxcbiAgICAgICAgbm9kZSA9IFJhbWJsaW5nOjpUcmllOjpOb2Rlczo6Q29tcHJlc3NlZC5uZXcgbGV0dGVyLCBwYXJlbnQsIHRyZWVcbiAgICAgICAgbm9kZS50ZXJtaW5hbCEgaWYgdGVybWluYWxcblxuICAgICAgICB0cmVlLmVhY2hfdmFsdWUgeyB8Y2hpbGR8IGNoaWxkLnBhcmVudCA9IG5vZGUgfVxuICAgICAgICBub2RlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImNvbXByZXNzIiwibm9kZSIsImNvbXByZXNzaWJsZT8iLCJjb21wcmVzc19jaGlsZF9hbmRfbWVyZ2UiLCJjb21wcmVzc19jaGlsZHJlbl9hbmRfY29weSIsInByaXZhdGUiLCJtZXJnZSIsImZpcnN0X2NoaWxkIiwibGV0dGVyIiwidG9fcyIsIjw8Iiwib3RoZXIiLCJuZXdfY29tcHJlc3NlZF9ub2RlIiwidG9fc3ltIiwicGFyZW50IiwiY2hpbGRyZW5fdHJlZSIsInRlcm1pbmFsPyIsImNvbXByZXNzX2NoaWxkcmVuIiwibmV3X3RyZWUiLCJlYWNoIiwidHJlZSIsImNvbXByZXNzZWRfY2hpbGQiLCJjaGlsZCIsIiR3cml0ZXIiLCJbXT0iLCItIiwiMSIsIm5ldyIsInRlcm1pbmFsIiwidGVybWluYWwhIiwiZWFjaF92YWx1ZSIsInBhcmVudD0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRUVDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFJRTtBQUFBQyxRQUFBQSw0QkFBQUEseUJBQUFBLG9CQUFhLElBQWJBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLElBQUEsUUFBR0MsSUFBQUMsa0JBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLFlBQ0UsV0FBQUMsMEJBQUFBLENBQXlCRixJQUF6QkU7QUFERixVQUFBO0FBQUEsWUFHRSxXQUFBQyw0QkFBQUEsQ0FBMkJI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QSxDQTNEM0I7QUFBQSxZQUFBUCxVQUFBLENBMkRpRHRCLElBM0RqRCxDQUFBO0FBQUEsWUEyRGtDOEIsTUFBQVQsS0FBQVMsV0FBQUEsRUEzRGxDLFVBQUFSLE9BQUEsQ0EyRGtDUSxDQTNEbEM7QUFBQSxZQUFBLE9BQUFSLE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBLFFBQUEsQ0FBQUUsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0EyRFFLLENBSEE7QUFBQSxVQUlBLE9BQUE3QixJQUpBO0FBREZXLFFBQUFBLENBQUFBLCtDQUFBQSxDQUFBQSwrQkE3Q0E7QUFKRmIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzc3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvY29udGFpbmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBSYW1ibGluZ1xuICBtb2R1bGUgVHJpZVxuICAgICMgV3JhcHBlciBvbiB0b3Agb2YgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICBjbGFzcyBDb250YWluZXJcbiAgICAgIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgICAgICMgVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIHRyaWUuXG4gICAgICAjIEByZXR1cm4gW05vZGVzOjpOb2RlXSB0aGUgcm9vdCBub2RlIG9mIHRoaXMgdHJpZS5cbiAgICAgIGF0dHJfcmVhZGVyIDpyb290XG5cbiAgICAgICMgQ3JlYXRlcyBhIG5ldyB0cmllLlxuICAgICAgIyBAcGFyYW0gW05vZGVzOjpOb2RlXSByb290IHRoZSByb290IG5vZGUgZm9yIHRoZSB0cmllXG4gICAgICAjIEBwYXJhbSBbQ29tcHJlc3Nvcl0gY29tcHJlc3NvciByZXNwb25zaWJsZSBmb3IgY29tcHJlc3NpbmcgdGhlIHRyaWVcbiAgICAgICMgQHlpZWxkIFtDb250YWluZXJdIHRoZSB0cmllIGp1c3QgY3JlYXRlZC5cbiAgICAgIGRlZiBpbml0aWFsaXplIHJvb3QsIGNvbXByZXNzb3JcbiAgICAgICAgQHJvb3QgPSByb290XG4gICAgICAgIEBjb21wcmVzc29yID0gY29tcHJlc3NvclxuXG4gICAgICAgIHlpZWxkIHNlbGYgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlbmRcblxuICAgICAgIyBBZGRzIGEgd29yZCB0byB0aGUgdHJpZS5cbiAgICAgICMgQHBhcmFtIFtTdHJpbmddIHdvcmQgdGhlIHdvcmQgdG8gYWRkIHRoZSBicmFuY2ggZnJvbS5cbiAgICAgICMgQHJldHVybiBbTm9kZXM6Ok5vZGVdIHRoZSBqdXN0IGFkZGVkIGJyYW5jaCdzIHJvb3Qgbm9kZS5cbiAgICAgICMgQHJhaXNlIFtJbnZhbGlkT3BlcmF0aW9uXSBpZiB0aGUgdHJpZSBpcyBhbHJlYWR5IGNvbXByZXNzZWQuXG4gICAgICAjIEBzZWUgTm9kZXM6OlJhdyNhZGRcbiAgICAgICMgQHNlZSBOb2Rlczo6Q29tcHJlc3NlZCNhZGRcbiAgICAgIGRlZiBhZGQgd29yZFxuICAgICAgICByb290LmFkZCBjaGFyX3N5bWJvbHMgd29yZFxuICAgICAgZW5kXG5cbiAgICAgICMgQWRkcyBhbGwgcHJvdmlkZWQgd29yZHMgdG8gdGhlIHRyaWUuXG4gICAgICAjIEBwYXJhbSBbQXJyYXk8U3RyaW5nPl0gd29yZHMgdGhlIHdvcmRzIHRvIGFkZCB0aGUgYnJhbmNoIGZyb20uXG4gICAgICAjIEByZXR1cm4gW0FycmF5PE5vZGVzOjpOb2RlPl0gdGhlIGNvbGxlY3Rpb24gb2Ygbm9kZXMgYWRkZWQuXG4gICAgICAjIEByYWlzZSBbSW52YWxpZE9wZXJhdGlvbl0gaWYgdGhlIHRyaWUgaXMgYWxyZWFkeSBjb21wcmVzc2VkLlxuICAgICAgIyBAc2VlIE5vZGVzOjpSYXcjYWRkXG4gICAgICAjIEBzZWUgTm9kZXM6OkNvbXByZXNzZWQjYWRkXG4gICAgICBkZWYgY29uY2F0IHdvcmRzXG4gICAgICAgIHdvcmRzLm1hcCB7IHx3b3JkfCBhZGQgd29yZCB9XG4gICAgICBlbmRcblxuICAgICAgIyBDb21wcmVzc2VzIHRoZSBleGlzdGluZyB0cmllIHVzaW5nIHJlZHVuZGFudCBub2RlIGVsaW1pbmF0aW9uLiBNYXJrc1xuICAgICAgIyB0aGUgdHJpZSBhcyBjb21wcmVzc2VkLiBEb2VzIG5vdGhpbmcgaWYgdGhlIHRyaWUgaGFzIGFscmVhZHkgYmVlblxuICAgICAgIyBjb21wcmVzc2VkLlxuICAgICAgIyBAcmV0dXJuIFtDb250YWluZXJdIHNlbGZcbiAgICAgICMgQG5vdGUgVGhpcyBtZXRob2QgcmVwbGFjZXMgdGhlIHJvb3Qge05vZGVzOjpSYXcgUmF3fSBub2RlIHdpdGggYVxuICAgICAgIyAgIHtOb2Rlczo6Q29tcHJlc3NlZCBDb21wcmVzc2VkfSB2ZXJzaW9uIG9mIGl0LlxuICAgICAgZGVmIGNvbXByZXNzIVxuICAgICAgICBzZWxmLnJvb3QgPSBjb21wcmVzc19yb290IHVubGVzcyByb290LmNvbXByZXNzZWQ/XG4gICAgICAgIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICAjIENvbXByZXNzZXMgdGhlIGV4aXN0aW5nIHRyaWUgdXNpbmcgcmVkdW5kYW50IG5vZGUgZWxpbWluYXRpb24uIFJldHVybnNcbiAgICAgICMgYSBuZXcgdHJpZSB3aXRoIHRoZSBjb21wcmVzc2VkIHJvb3QuXG4gICAgICAjIEByZXR1cm4gW0NvbnRhaW5lcl0gQSBuZXcge0NvbnRhaW5lcn0gd2l0aCB0aGUge05vZGVzOjpDb21wcmVzc2VkXG4gICAgICAjICAgQ29tcHJlc3NlZH0gcm9vdCBub2RlIG9yIHNlbGYgaWYgdGhlIHRyaWUgaGFzIGFscmVhZHkgYmVlblxuICAgICAgIyAgIGNvbXByZXNzZWQuXG4gICAgICBkZWYgY29tcHJlc3NcbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgcm9vdC5jb21wcmVzc2VkP1xuICAgICAgICBSYW1ibGluZzo6VHJpZTo6Q29udGFpbmVyLm5ldyBjb21wcmVzc19yb290LCBjb21wcmVzc29yXG4gICAgICBlbmRcblxuICAgICAgIyBDaGVja3MgaWYgYSBwYXRoIGZvciBhIHdvcmQgb3IgcGFydGlhbCB3b3JkIGV4aXN0cyBpbiB0aGUgdHJpZS5cbiAgICAgICMgQHBhcmFtIFtTdHJpbmddIHdvcmQgdGhlIHdvcmQgb3IgcGFydGlhbCB3b3JkIHRvIGxvb2sgZm9yIGluIHRoZSB0cmllLlxuICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgaWYgdGhlIHdvcmQgb3IgcGFydGlhbCB3b3JkIGlzIGZvdW5kLCBgZmFsc2VgXG4gICAgICAjICAgb3RoZXJ3aXNlLlxuICAgICAgIyBAc2VlIE5vZGVzOjpSYXcjcGFydGlhbF93b3JkP1xuICAgICAgIyBAc2VlIE5vZGVzOjpDb21wcmVzc2VkI3BhcnRpYWxfd29yZD9cbiAgICAgIGRlZiBwYXJ0aWFsX3dvcmQ/IHdvcmQgPSAnJ1xuICAgICAgICByb290LnBhcnRpYWxfd29yZD8gd29yZC5jaGFyc1xuICAgICAgZW5kXG5cbiAgICAgICMgQ2hlY2tzIGlmIGEgd2hvbGUgd29yZCBleGlzdHMgaW4gdGhlIHRyaWUuXG4gICAgICAjIEBwYXJhbSBbU3RyaW5nXSB3b3JkIHRoZSB3b3JkIHRvIGxvb2sgZm9yIGluIHRoZSB0cmllLlxuICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgb25seSBpZiB0aGUgd29yZCBpcyBmb3VuZCBhbmQgdGhlIGxhc3RcbiAgICAgICMgICBjaGFyYWN0ZXIgY29ycmVzcG9uZHMgdG8gYSB0ZXJtaW5hbCBub2RlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICMgQHNlZSBOb2Rlczo6UmF3I3dvcmQ/XG4gICAgICAjIEBzZWUgTm9kZXM6OkNvbXByZXNzZWQjd29yZD9cbiAgICAgIGRlZiB3b3JkPyB3b3JkID0gJydcbiAgICAgICAgcm9vdC53b3JkPyB3b3JkLmNoYXJzXG4gICAgICBlbmRcblxuICAgICAgIyBSZXR1cm5zIGFsbCB3b3JkcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXJzLlxuICAgICAgIyBAcGFyYW0gW1N0cmluZ10gd29yZCB0aGUgd29yZCB0byBsb29rIGZvciBpbiB0aGUgdHJpZS5cbiAgICAgICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gYWxsIHRoZSB3b3JkcyBjb250YWluZWQgaW4gdGhlIHRyaWUgdGhhdCBzdGFydFxuICAgICAgIyAgIHdpdGggdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXJzLlxuICAgICAgIyBAc2VlIE5vZGVzOjpSYXcjc2NhblxuICAgICAgIyBAc2VlIE5vZGVzOjpDb21wcmVzc2VkI3NjYW5cbiAgICAgIGRlZiBzY2FuIHdvcmQgPSAnJ1xuICAgICAgICByb290LnNjYW4od29yZC5jaGFycykudG9fYVxuICAgICAgZW5kXG5cbiAgICAgICMgUmV0dXJucyBhbGwgd29yZHMgd2l0aGluIGEgc3RyaW5nIHRoYXQgbWF0Y2ggYSB3b3JkIGNvbnRhaW5lZCBpbiB0aGVcbiAgICAgICMgdHJpZS5cbiAgICAgICMgQHBhcmFtIFtTdHJpbmddIHBocmFzZSB0aGUgc3RyaW5nIHRvIGxvb2sgZm9yIG1hdGNoaW5nIHdvcmRzIGluLlxuICAgICAgIyBAcmV0dXJuIFtFbnVtZXJhdG9yPFN0cmluZz5dIGFsbCB0aGUgd29yZHMgaW4gdGhlIGdpdmVuIHN0cmluZyB0aGF0XG4gICAgICAjICAgbWF0Y2ggYSB3b3JkIGluIHRoZSB0cmllLlxuICAgICAgIyBAeWllbGQgW1N0cmluZ10gZWFjaCB3b3JkIGZvdW5kIGluIHBocmFzZS5cbiAgICAgICMgQHNlZSBOb2Rlczo6Tm9kZSN3b3Jkc193aXRoaW5cbiAgICAgIGRlZiB3b3Jkc193aXRoaW4gcGhyYXNlXG4gICAgICAgIHdvcmRzX3dpdGhpbl9yb290KHBocmFzZSkudG9fYVxuICAgICAgZW5kXG5cbiAgICAgICMgQ2hlY2tzIGlmIHRoZXJlIGFyZSBhbnkgdmFsaWQgd29yZHMgaW4gYSBnaXZlbiBzdHJpbmcuXG4gICAgICAjIEBwYXJhbSBbU3RyaW5nXSBwaHJhc2UgdGhlIHN0cmluZyB0byBsb29rIGZvciBtYXRjaGluZyB3b3JkcyBpbi5cbiAgICAgICMgQHJldHVybiBbQm9vbGVhbl0gYHRydWVgIGlmIGFueSB3b3JkIHdpdGhpbiBwaHJhc2UgaXMgY29udGFpbmVkIGluIHRoZVxuICAgICAgIyAgIHRyaWUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgIyBAc2VlIENvbnRhaW5lciN3b3Jkc193aXRoaW5cbiAgICAgIGRlZiB3b3Jkc193aXRoaW4/IHBocmFzZVxuICAgICAgICB3b3Jkc193aXRoaW5fcm9vdChwaHJhc2UpLmFueT9cbiAgICAgIGVuZFxuXG4gICAgICAjIENvbXBhcmVzIHR3byB0cmllIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgICMgQHBhcmFtIFtDb250YWluZXJdIG90aGVyIHRoZSB0cmllIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgICMgQHJldHVybiBbQm9vbGVhbl0gYHRydWVgIGlmIHRoZSB0cmllcyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgZGVmID09IG90aGVyXG4gICAgICAgIHJvb3QgPT0gb3RoZXIucm9vdFxuICAgICAgZW5kXG5cbiAgICAgICMgSXRlcmF0ZXMgb3ZlciB0aGUgd29yZHMgY29udGFpbmVkIGluIHRoZSB0cmllLlxuICAgICAgIyBAeWllbGQgW1N0cmluZ10gdGhlIHdvcmRzIGNvbnRhaW5lZCBpbiB0aGlzIHRyaWUgbm9kZS5cbiAgICAgIGRlZiBlYWNoXG4gICAgICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgICAgcm9vdC5lYWNoIGRvIHx3b3JkfFxuICAgICAgICAgIHlpZWxkIHdvcmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgIyBAcmV0dXJuIFtTdHJpbmddIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250YWluZXIuXG4gICAgICBkZWYgaW5zcGVjdFxuICAgICAgICBcIiM8I3tzZWxmLmNsYXNzLm5hbWV9IHJvb3Q6ICN7cm9vdC5pbnNwZWN0fT5cIlxuICAgICAgZW5kXG5cbiAgICAgICMgR2V0IHtOb2Rlczo6Tm9kZSBOb2RlfSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGV0dGVyLlxuICAgICAgIyBAcGFyYW0gW1N5bWJvbF0gbGV0dGVyIHRoZSBsZXR0ZXIgdG8gc2VhcmNoIGZvciBpbiB0aGUgcm9vdCBub2RlLlxuICAgICAgIyBAcmV0dXJuIFtOb2Rlczo6Tm9kZV0gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGF0IGxldHRlci5cbiAgICAgICMgQHNlZSBOb2Rlczo6Tm9kZSNbXVxuICAgICAgZGVmIFtdIGxldHRlclxuICAgICAgICByb290W2xldHRlcl1cbiAgICAgIGVuZFxuXG4gICAgICAjIFJvb3Qgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICAgIyBAcmV0dXJuIFtBcnJheTxOb2Rlczo6Tm9kZT5dIHRoZSBhcnJheSBvZiBjaGlsZHJlbiBub2RlcyBjb250YWluZWQgaW5cbiAgICAgICMgICB0aGUgcm9vdCBub2RlLlxuICAgICAgIyBAc2VlIE5vZGVzOjpOb2RlI2NoaWxkcmVuXG4gICAgICBkZWYgY2hpbGRyZW5cbiAgICAgICAgcm9vdC5jaGlsZHJlblxuICAgICAgZW5kXG5cbiAgICAgICMgUm9vdCBub2RlJ3MgY2hpbGRyZW4gdHJlZS5cbiAgICAgICMgQHJldHVybiBbQXJyYXk8Tm9kZXM6Ok5vZGU+XSB0aGUgYXJyYXkgb2YgY2hpbGRyZW4gbm9kZXMgY29udGFpbmVkIGluXG4gICAgICAjICAgdGhlIHJvb3Qgbm9kZS5cbiAgICAgICMgQHNlZSBOb2Rlczo6Tm9kZSNjaGlsZHJlbl90cmVlXG4gICAgICBkZWYgY2hpbGRyZW5fdHJlZVxuICAgICAgICByb290LmNoaWxkcmVuX3RyZWVcbiAgICAgIGVuZFxuXG4gICAgICAjIEluZGljYXRlcyBpZiB0aGUgcm9vdCB7Tm9kZXM6Ok5vZGUgTm9kZX0gY2FuIGJlXG4gICAgICAjIGNvbXByZXNzZWQgb3Igbm90LlxuICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgZm9yIG5vbi17Tm9kZXM6Ok5vZGUjdGVybWluYWw/IHRlcm1pbmFsfVxuICAgICAgIyAgICBub2RlcyB3aXRoIG9uZSBjaGlsZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICBkZWYgY29tcHJlc3NlZD9cbiAgICAgICAgcm9vdC5jb21wcmVzc2VkP1xuICAgICAgZW5kXG5cbiAgICAgICMgQXJyYXkgb2Ygd29yZHMgY29udGFpbmVkIGluIHRoZSByb290IHtOb2Rlczo6Tm9kZSBOb2RlfS5cbiAgICAgICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gYWxsIHdvcmRzIGNvbnRhaW5lZCBpbiB0aGlzIHRyaWUuXG4gICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9FbnVtZXJhYmxlLmh0bWwjbWV0aG9kLWktdG9fYVxuICAgICAgIyAgIEVudW1lcmFibGUjdG9fYVxuICAgICAgZGVmIHRvX2FcbiAgICAgICAgcm9vdC50b19hXG4gICAgICBlbmRcblxuICAgICAgIyBDaGVjayBpZiBhIGxldHRlciBpcyBwYXJ0IG9mIHRoZSByb290IHtOb2Rlczo6Tm9kZX0ncyBjaGlsZHJlbiB0cmVlLlxuICAgICAgIyBAcGFyYW0gW1N5bWJvbF0gbGV0dGVyIHRoZSBsZXR0ZXIgdG8gc2VhcmNoIGZvciBpbiB0aGUgcm9vdCBub2RlLlxuICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBsZXR0ZXIgaXMgY29udGFpbmVkIG9yIG5vdC5cbiAgICAgICMgQHNlZSBOb2Rlczo6Tm9kZSNrZXk/XG4gICAgICBkZWYga2V5PyBsZXR0ZXJcbiAgICAgICAgcm9vdC5rZXk/IGxldHRlclxuICAgICAgZW5kXG5cbiAgICAgICMgU2l6ZSBvZiB0aGUgUm9vdCB7Tm9kZXM6Ok5vZGUgTm9kZX0ncyBjaGlsZHJlbiB0cmVlLlxuICAgICAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIGxldHRlcnMgaW4gdGhlIHJvb3Qgbm9kZS5cbiAgICAgIGRlZiBzaXplXG4gICAgICAgIHJvb3Quc2l6ZVxuICAgICAgZW5kXG5cbiAgICAgIGFsaWFzX21ldGhvZCA6aW5jbHVkZT8sIDp3b3JkP1xuICAgICAgYWxpYXNfbWV0aG9kIDptYXRjaD8sIDpwYXJ0aWFsX3dvcmQ/XG4gICAgICBhbGlhc19tZXRob2QgOndvcmRzLCA6c2NhblxuICAgICAgYWxpYXNfbWV0aG9kIDo8PCwgOmFkZFxuICAgICAgYWxpYXNfbWV0aG9kIDpoYXNfa2V5PywgOmtleT9cbiAgICAgIGFsaWFzX21ldGhvZCA6aGFzX2xldHRlcj8sIDprZXk/XG5cbiAgICAgIHByaXZhdGVcblxuICAgICAgYXR0cl9yZWFkZXIgOmNvbXByZXNzb3JcbiAgICAgIGF0dHJfd3JpdGVyIDpyb290XG5cbiAgICAgIGRlZiB3b3Jkc193aXRoaW5fcm9vdCBwaHJhc2VcbiAgICAgICAgcmV0dXJuIGVudW1fZm9yIDp3b3Jkc193aXRoaW5fcm9vdCwgcGhyYXNlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICAgICBjaGFycyA9IHBocmFzZS5jaGFyc1xuICAgICAgICAwLnVwdG8oY2hhcnMubGVuZ3RoIC0gMSkuZWFjaCBkbyB8c3RhcnRpbmdfaW5kZXh8XG4gICAgICAgICAgbmV3X3BocmFzZSA9IGNoYXJzLnNsaWNlIHN0YXJ0aW5nX2luZGV4Li4oY2hhcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICByb290Lm1hdGNoX3ByZWZpeCBuZXdfcGhyYXNlIGRvIHx3b3JkfFxuICAgICAgICAgICAgeWllbGQgd29yZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgY29tcHJlc3Nfcm9vdFxuICAgICAgICBjb21wcmVzc29yLmNvbXByZXNzIHJvb3RcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgY2hhcl9zeW1ib2xzIHdvcmRcbiAgICAgICAgc3ltYm9scyA9IFtdXG4gICAgICAgIHdvcmQucmV2ZXJzZS5lYWNoX2NoYXIgeyB8Y3wgc3ltYm9scyA8PCBjLnRvX3N5bSB9XG4gICAgICAgIHN5bWJvbHNcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByb290Iiwicm9vdCIsIkBjb21wcmVzc29yIiwiY29tcHJlc3NvciIsImJsb2NrX2dpdmVuPyIsInNlbGYiLCJhZGQiLCJjaGFyX3N5bWJvbHMiLCJ3b3JkIiwiY29uY2F0IiwibWFwIiwid29yZHMiLCJjb21wcmVzcyEiLCJjb21wcmVzc2VkPyIsIiR3cml0ZXIiLCJjb21wcmVzc19yb290Iiwicm9vdD0iLCItIiwiMSIsImNvbXByZXNzIiwibmV3IiwicGFydGlhbF93b3JkPyIsImNoYXJzIiwid29yZD8iLCJzY2FuIiwidG9fYSIsIndvcmRzX3dpdGhpbiIsIndvcmRzX3dpdGhpbl9yb290IiwicGhyYXNlIiwid29yZHNfd2l0aGluPyIsImFueT8iLCI9PSIsIm90aGVyIiwiZWFjaCIsImVudW1fZm9yIiwiaW5zcGVjdCIsIm5hbWUiLCJbXSIsImxldHRlciIsImNoaWxkcmVuIiwiY2hpbGRyZW5fdHJlZSIsImtleT8iLCJzaXplIiwiYWxpYXNfbWV0aG9kIiwicHJpdmF0ZSIsImF0dHJfd3JpdGVyIiwiMCIsInVwdG8iLCJsZW5ndGgiLCJuZXdfcGhyYXNlIiwic2xpY2UiLCJzdGFydGluZ19pbmRleCIsIm1hdGNoX3ByZWZpeCIsInN5bWJvbHMiLCJlYWNoX2NoYXIiLCJyZXZlcnNlIiwiPDwiLCJjIiwidG9fc3ltIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxN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QUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBWixZQUFBQSxDQUFBQSxDQUFBZ0IsVUFBQUEsS0FBb0JsQixNQUFBQSxDQUFBQSxDQUFwQmtCO0FBREZKLFFBQUFBLENBQUFBLHlDQUFBQSxDQWhOQTtBQUFBLFFBb05BLE9BQUFSLENBQUFBLGdDQUFBQSw2QkFBQUEsd0JBQWlCLElBQWpCQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFDRSxVQUFBOEMsVUFBVSxFQUFWO0FBQUEsVUFDQUMsTUFBQTlDLElBQUErQyxTQUFBQSxDQUFBQSxDQUFBRCxhQUFBQSxFQUFBQSxFQUFBQSxFQTdOUixpQkE2TmtDLENBN05sQyxFQUFBOztBQUFBO0FBQUE7QUE2TmtDLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQTdObEM7QUFBQSxZQTZOcUMsT0FBQUQsT0FBQUcsT0FBQUEsQ0FBV0MsQ0FBQUMsUUFBQUEsQ0FBQUEsQ0FBWEYsQ0E3TnJDLENBQUEsbUJBQUEsa0JBQUEsTUE2TlFGLENBREE7QUFBQSxVQUVBLE9BQUFELE9BRkE7QUFERjlDLFFBQUFBLENBQUFBLHdDQUFBQSxDQUFBQSx3QkFwTkE7QUFERlgsTUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDA0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvZW51bWVyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICAjIFByb3ZpZGVzIGVudW1lcmFibGUgYmVoYXZpb3IgdG8gdGhlIHRyaWUgZGF0YSBzdHJ1Y3R1cmUuXG4gICAgbW9kdWxlIEVudW1lcmFibGVcbiAgICAgIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgICAgICMgUmV0dXJucyBudW1iZXIgb2Ygd29yZHMgY29udGFpbmVkIGluIHRoZSB0cmllXG4gICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9FbnVtZXJhYmxlLmh0bWwjbWV0aG9kLWktY291bnRcbiAgICAgICMgICBFbnVtZXJhYmxlI2NvdW50XG4gICAgICBhbGlhc19tZXRob2QgOnNpemUsIDpjb3VudFxuXG4gICAgICAjIEl0ZXJhdGVzIG92ZXIgdGhlIHdvcmRzIGNvbnRhaW5lZCBpbiB0aGUgdHJpZS5cbiAgICAgICMgQHlpZWxkIFtTdHJpbmddIHRoZSB3b3JkcyBjb250YWluZWQgaW4gdGhpcyB0cmllIG5vZGUuXG4gICAgICBkZWYgZWFjaFxuICAgICAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICAgIHlpZWxkIGFzX3dvcmQgaWYgdGVybWluYWw/XG5cbiAgICAgICAgY2hpbGRyZW5fdHJlZS5lYWNoX3ZhbHVlIGRvIHxjaGlsZHxcbiAgICAgICAgICBjaGlsZC5lYWNoIGRvIHx3b3JkfFxuICAgICAgICAgICAgeWllbGQgd29yZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImluY2x1ZGUiLCJhbGlhc19tZXRob2QiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJ0ZXJtaW5hbD8iLCJhc193b3JkIiwiZWFjaF92YWx1ZSIsImNoaWxkcmVuX3RyZWUiLCJjaGlsZCIsIndvcmQiXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRUVBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxZQUFBQyxTQUFBQSxDQUFRLElBQUEsSUFBQSxlQUFSQSxDQUFBO0FBQUEsWUFLQUMsY0FBQUEsQ0FBYSxRQUFPLE9BQXBCQSxDQUxBO0FBQUE7QUFTQUMsUUFBQUEsd0JBQUFBLHFCQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQUFBO0FBQUFBO0FBQ0UsVUFBQSxJQUE2QkMsZ0JBQTdCO0FBQUEsVUFBQTtBQUFBLFlBQUEsV0FBT0MsVUFBQUEsQ0FBUyxNQUFUQTtBQUFQLFVBQUEsQ0FBQTtBQUFBLFVBRUEsSUFBQSxZQUFpQkMsY0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQTtBQUFBLFlBQUEsd0JBQU1DLFNBQUFBLENBQUFBLENBQU4sQ0FBQSxDQUZBO0FBQUEsVUFJQSxPQUFBQyxVQUFBQyxlQUFBQSxDQUFBQSxDQUFBRCxjQUFBQSxFQUFBQSxFQUFBQSxFQXJCUixnQkFxQnFDLEtBckJyQyxFQUFBOztBQUFBO0FBQUE7QUFxQnFDLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXJCckM7QUFBQSxZQXNCVSxPQUFBTCxNQUFBTyxLQUFBUCxRQUFBQSxFQUFBQSxFQUFBQSxFQXRCVixnQkFzQnlCLElBdEJ6QixFQUFBOztBQUFBO0FBQUE7QUFzQnlCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXRCekI7QUFBQSxjQXVCWSxPQUFBLG9CQUFNUSxJQUFOLENBQUEsQ0F2QlosQ0FBQSxrQkFBQSxpQkFBQSxLQXNCVVIsQ0F0QlYsQ0FBQSxrQkFBQSxpQkFBQSxLQXFCUUssQ0FKQTtBQURGTCxRQUFBQSxDQUFBQSxnQ0FBQUEsQ0FUQTtBQURGSCxNQUFBQSxHQUFBQSxXQUFBQTtBQUZGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MDk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmFtYmxpbmcvdHJpZS9pbnNwZWN0YWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICAjIFByb3ZpZGVzIHByZXR0eSBwcmludGluZyBiZWhhdmlvciBmb3IgdGhlIHRyaWUgZGF0YSBzdHJ1Y3R1cmUuXG4gICAgbW9kdWxlIEluc3BlY3RhYmxlXG4gICAgICAjIEByZXR1cm4gW1N0cmluZ10gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIGRlZiBpbnNwZWN0XG4gICAgICAgIFwiIzwje2NsYXNzX25hbWV9ICN7YXR0cmlidXRlc30+XCJcbiAgICAgIGVuZFxuXG4gICAgICBwcml2YXRlXG5cbiAgICAgIGRlZiBjbGFzc19uYW1lXG4gICAgICAgIHNlbGYuY2xhc3MubmFtZVxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBhdHRyaWJ1dGVzXG4gICAgICAgIFtcbiAgICAgICAgICBsZXR0ZXJfaW5zcGVjdCxcbiAgICAgICAgICB0ZXJtaW5hbF9pbnNwZWN0LFxuICAgICAgICAgIGNoaWxkcmVuX2luc3BlY3QsXG4gICAgICAgIF0uam9pbiAnLCAnXG4gICAgICBlbmRcblxuICAgICAgZGVmIGxldHRlcl9pbnNwZWN0XG4gICAgICAgIFwibGV0dGVyOiAje2xldHRlci5pbnNwZWN0fVwiXG4gICAgICBlbmRcblxuICAgICAgZGVmIHRlcm1pbmFsX2luc3BlY3RcbiAgICAgICAgXCJ0ZXJtaW5hbDogI3t0ZXJtaW5hbC5pbnNwZWN0fVwiXG4gICAgICBlbmRcblxuICAgICAgZGVmIGNoaWxkcmVuX2luc3BlY3RcbiAgICAgICAgXCJjaGlsZHJlbjogI3tjaGlsZHJlbl90cmVlLmtleXMuaW5zcGVjdH1cIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiaW5zcGVjdCIsImNsYXNzX25hbWUiLCJhdHRyaWJ1dGVzIiwicHJpdmF0ZSIsInNlbGYiLCJjbGFzcyIsIm5hbWUiLCJsZXR0ZXJfaW5zcGVjdCIsInRlcm1pbmFsX2luc3BlY3QiLCJjaGlsZHJlbl9pbnNwZWN0Iiwiam9pbiIsImxldHRlciIsInRlcm1pbmFsIiwiY2hpbGRyZW5fdHJlZSIsImtleXMiXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRUVBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFFRTtBQUFBQyxRQUFBQSwyQkFBQUEseUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxJQUFBLEdBQUEsS0FBS0MsWUFBQUEsQ0FBQUEsQ0FBTCxDQUFBLEdBQUEsR0FBQSxHQUFBLEtBQW1CQyxZQUFBQSxDQUFBQSxDQUFuQixDQUFBLEdBQUE7QUFERkYsUUFBQUEsQ0FBQUEsb0NBQUFBLENBQUE7QUFBQSxZQUlBRyxTQUFBQSxDQUFBQSxDQUpBO0FBQUE7QUFNQUYsUUFBQUEsOEJBQUFBLDRCQUFBQSxzQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQUcsSUFBQUMsT0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUE7QUFERkwsUUFBQUEsQ0FBQUEsdUNBQUFBLENBTkE7QUFBQTtBQVVBQyxRQUFBQSw4QkFBQUEsNEJBQUFBLHNCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEtBQ0VLLGdCQUFBQSxDQUFBQSxDQURGLE1BRUVDLGtCQUFBQSxDQUFBQSxDQUZGLE1BR0VDLGtCQUFBQSxDQUFBQSxDQUhGLENBQUFDLE1BQUFBLENBSU8sSUFKUEE7QUFERlIsUUFBQUEsQ0FBQUEsdUNBQUFBLENBVkE7QUFBQTtBQWtCQUssUUFBQUEsa0NBQUFBLGdDQUFBQSwwQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSxFQUFBLEdBQUEsVUFBQSxHQUFBLEtBQVdJLFFBQUFBLENBQUFBLENBQUFYLFNBQUFBLENBQUFBLENBQVg7QUFERk8sUUFBQUEsQ0FBQUEsMkNBQUFBLENBbEJBO0FBQUE7QUFzQkFDLFFBQUFBLG9DQUFBQSxrQ0FBQUEsNEJBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsRUFBQSxHQUFBLFlBQUEsR0FBQSxLQUFhSSxVQUFBQSxDQUFBQSxDQUFBWixTQUFBQSxDQUFBQSxDQUFiO0FBREZRLFFBQUFBLENBQUFBLDZDQUFBQSxDQXRCQTtBQUFBO0FBMEJBQyxRQUFBQSxvQ0FBQUEsa0NBQUFBLDRCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxZQUFBLEdBQUEsS0FBYUksZUFBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBQWQsU0FBQUEsQ0FBQUEsQ0FBYjtBQURGUyxRQUFBQSxDQUFBQSw2Q0FBQUEsQ0ExQkE7QUFGRlYsTUFBQUEsR0FBQUEsV0FBQUE7QUFGRkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDE2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvaW52YWxpZF9vcGVyYXRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBSYWlzZWQgd2hlbiB0cnlpbmcgdG8gZXhlY3V0ZSBhbiBpbnZhbGlkIG9wZXJhdGlvbiBvbiBhIHRyaWUgZGF0YVxuICAgICMgc3RydWN0dXJlLlxuICAgIGNsYXNzIEludmFsaWRPcGVyYXRpb24gPCBSdW50aW1lRXJyb3JcbiAgICAgICMgQ3JlYXRlcyBhIG5ldyB7SW52YWxpZE9wZXJhdGlvbiBJbnZhbGlkT3BlcmF0aW9ufSBleGNlcHRpb24uXG4gICAgICAjIEBwYXJhbSBbU3RyaW5nLCBuaWxdIG1lc3NhZ2UgdGhlIGV4Y2VwdGlvbiBtZXNzYWdlLlxuICAgICAgZGVmIGluaXRpYWxpemUgbWVzc2FnZSA9IG5pbFxuICAgICAgICBzdXBlclxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJpbml0aWFsaXplIl0sIm1hcHBpbmdzIjoiOzs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BR0VDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFHRSxPQUFBQyxDQUFBQSw4QkFBQUEsaUNBQUFBLHNCQUFlLE9BQWZBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTtBQVZOO0FBVXFCLFVBQUE7QUFBQSxVQUFBLFlBQVUsR0FBVjtBQUFBLFVBQUEsQ0FWckI7QUFBQSxVQVdRLE9BQUEsVUFBQSxFQUFBLHFGQUFBLFFBQUEsT0FBQSxDQVhSO0FBVU1BLFFBQUFBLENBQUFBLDZDQUFBQSxDQUFBQTtBQUhGRCxNQUFBQSxHQUFBQSxXQUFBQSxFQUF5Qiw0QkFBekJBO0FBSEZELElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQxOTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL3JlYWRlcnMvcGxhaW5fdGV4dC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICBtb2R1bGUgUmVhZGVyc1xuICAgICAgIyBGaWxlIHJlYWRlciBmb3IgLnR4dCBmaWxlcy5cbiAgICAgIGNsYXNzIFBsYWluVGV4dFxuICAgICAgICAjIFlpZWxkcyBlYWNoIHdvcmQgcmVhZCBmcm9tIGEgLnR4dCBmaWxlLlxuICAgICAgICAjIEBwYXJhbSBbU3RyaW5nXSBmaWxlcGF0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlIHRvIGxvYWQgdGhlIHdvcmRzXG4gICAgICAgICMgICBmcm9tLlxuICAgICAgICAjIEB5aWVsZCBbU3RyaW5nXSBFYWNoIGxpbmUgcmVhZCBmcm9tIHRoZSBmaWxlLlxuICAgICAgICBkZWYgZWFjaF93b3JkIGZpbGVwYXRoXG4gICAgICAgICAgRmlsZS5mb3JlYWNoKGZpbGVwYXRoKSB7IHxsaW5lfCB5aWVsZCBsaW5lLmNob21wISB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJlYWNoX3dvcmQiLCJmb3JlYWNoIiwiZmlsZXBhdGgiLCJsaW5lIiwiY2hvbXAhIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRUVDO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUEsVUFLRSxPQUFBQyxDQUFBQSw2QkFBQUEseUJBQUFBLHFCQUFjLFFBQWRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUFBQTtBQUFBQSxZQUNFLE9BQUFDLE1BQUEsb0JBQUFBLFdBQUFBLEVBQUFBLENBQWFDLFFBQWJELENBQUFBLEVBYlYsZ0JBYW9DLElBYnBDLEVBQUE7O0FBQUE7QUFBQTtBQWFvQyxjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0FicEM7QUFBQSxjQWEwQyxPQUFBLG9CQUFNRSxJQUFBQyxXQUFBQSxDQUFBQSxDQUFOLENBQUEsQ0FiMUMsQ0FBQSxrQkFBQSxpQkFBQSxLQWFVSDtBQURGRCxVQUFBQSxDQUFBQSxvQ0FBQUEsQ0FBQUE7QUFMRkQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDI0MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvcmVhZGVycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5pZiBSVUJZX0VOR0lORSA9PSAnb3BhbCdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9yZWFkZXJzL3BsYWluX3RleHQnXG5lbHNlXG4gICV3KHBsYWluX3RleHQpLmVhY2ggZG8gfGZpbGV8XG4gICAgcmVxdWlyZSBGaWxlLmpvaW4oJ3JhbWJsaW5nJywgJ3RyaWUnLCAncmVhZGVycycsIGZpbGUpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBSYW1ibGluZ1xuICBtb2R1bGUgVHJpZVxuICAgICMgTmFtZXNwYWNlIGZvciBhbGwgcmVhZGVycy5cbiAgICBtb2R1bGUgUmVhZGVyc1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIj09IiwicmVxdWlyZSIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsRUFBQSxJQUFHLDJCQUFBQSxPQUFBQSxDQUFlLE1BQWZBLENBQUg7QUFBQSxRQUNFQyxTQUFBQSxDQUFRLGtDQUFSQTtBQURGLEVBQUE7QUFBQSxJQUFBO0FBQUEsRUFBQSxDQUFBO0FBQUEsRUFRQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQSxNQUFBQSxHQUFBQSxXQUFBQTtBQUZGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQSxXQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQyNzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL3NlcmlhbGl6ZXJzL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgbW9kdWxlIFNlcmlhbGl6ZXJzXG4gICAgICAjIEJhc2ljIGZpbGUgc2VyaWFsaXplci4gRHVtcHMvbG9hZHMgc3RyaW5nIGNvbnRlbnRzIGZyb20gZmlsZXMuXG4gICAgICBjbGFzcyBGaWxlXG4gICAgICAgICMgTG9hZHMgY29udGVudHMgZnJvbSBhIHNwZWNpZmllZCBmaWxlcGF0aC5cbiAgICAgICAgIyBAcGFyYW0gW1N0cmluZ10gZmlsZXBhdGggdGhlIGZpbGVwYXRoIHRvIGxvYWQgY29udGVudHMgZnJvbS5cbiAgICAgICAgIyBAcmV0dXJuIFtTdHJpbmddIGFsbCBjb250ZW50cyBvZiB0aGUgZmlsZS5cbiAgICAgICAgZGVmIGxvYWQgZmlsZXBhdGhcbiAgICAgICAgICA6OkZpbGUucmVhZCBmaWxlcGF0aFxuICAgICAgICBlbmRcblxuICAgICAgICAjIER1bXBzIGNvbnRlbnRzIGludG8gYSBzcGVjaWZpZWQgZmlsZXBhdGguXG4gICAgICAgICMgQHBhcmFtIFtTdHJpbmddIGNvbnRlbnRzIHRoZSBjb250ZW50cyB0byBkdW1wLlxuICAgICAgICAjIEBwYXJhbSBbU3RyaW5nXSBmaWxlcGF0aCB0aGUgZmlsZXBhdGggdG8gZHVtcCB0aGUgY29udGVudHMgdG8uXG4gICAgICAgICMgQHJldHVybiBbTnVtZXJpY10gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gdG8gZGlzay5cbiAgICAgICAgZGVmIGR1bXAgY29udGVudHMsIGZpbGVwYXRoXG4gICAgICAgICAgOjpGaWxlLm9wZW4gZmlsZXBhdGgsICd3KycgZG8gfGZ8XG4gICAgICAgICAgICBmLndyaXRlIGNvbnRlbnRzXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJsb2FkIiwicmVhZCIsImZpbGVwYXRoIiwiZHVtcCIsIm9wZW4iLCJmIiwid3JpdGUiLCJjb250ZW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUVFQztBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBSUU7QUFBQUMsVUFBQUEsd0JBQUFBLGVBQUFBLGdCQUFTLFFBQVRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUEsSUFBQSxJQUFBLFNBQUFDLE1BQUFBLENBQVlDLFFBQVpEO0FBREZELFVBQUFBLENBQUFBLDBCQUFBQSxDQUFBO0FBQUEsVUFRQSxPQUFBRyxDQUFBQSx3QkFBQUEsZUFBQUEsZ0JBQVMsUUFBQSxFQUFVLFFBQW5CQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBQyxNQUFBLElBQUEsSUFBQSxTQUFBQSxRQUFBQSxFQUFBQSxDQUFZRixVQUFVLElBQXRCRSxDQUFBQSxFQXBCVixnQkFvQnlDLENBcEJ6QyxFQUFBOztBQUFBO0FBQUE7QUFvQnlDLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXBCekM7QUFBQSxjQXFCWSxPQUFBQyxDQUFBQyxPQUFBQSxDQUFRQyxRQUFSRCxDQXJCWixDQUFBLGtCQUFBLGlCQUFBLEtBb0JVRjtBQURGRCxVQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQUEsZ0JBUkE7QUFKRkosUUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDMyNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvc2VyaWFsaXplcnMvbWFyc2hhbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICBtb2R1bGUgU2VyaWFsaXplcnNcbiAgICAgICMgU2VyaWFsaXplciBmb3IgUnVieSBtYXJzaGFsIGZvcm1hdCAoLm1hcnNoYWwpIGZpbGVzLlxuICAgICAgY2xhc3MgTWFyc2hhbFxuICAgICAgICAjIENyZWF0ZXMgYSBuZXcgTWFyc2hhbCBzZXJpYWxpemVyLlxuICAgICAgICAjIEBwYXJhbSBbU2VyaWFsaXplcl0gc2VyaWFsaXplciB0aGUgc2VyaWFsaXplciByZXNwb25zaWJsZSB0byB3cml0ZSB0b1xuICAgICAgICAjICAgYW5kIHJlYWQgZnJvbSBkaXNrLlxuICAgICAgICBkZWYgaW5pdGlhbGl6ZSBzZXJpYWxpemVyID0gbmlsXG4gICAgICAgICAgQHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IFJhbWJsaW5nOjpUcmllOjpTZXJpYWxpemVyczo6RmlsZS5uZXdcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBMb2FkcyBtYXJzaGFsZWQgb2JqZWN0IGZyb20gY29udGVudHMgaW4gZmlsZXBhdGggYW5kIGRlc2VyaWFsaXplcyBpdFxuICAgICAgICAjIGludG8gYSB7Tm9kZXM6Ok5vZGUgTm9kZX0uXG4gICAgICAgICMgQHBhcmFtIFtTdHJpbmddIGZpbGVwYXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUgdG8gbG9hZCB0aGVcbiAgICAgICAgIyAgIG1hcnNoYWxlZCBvYmplY3QgZnJvbS5cbiAgICAgICAgIyBAcmV0dXJuIFtOb2Rlczo6Tm9kZV0gVGhlIGRlc2VyaWFsaXplZCB7Tm9kZXM6Ok5vZGUgTm9kZX0uXG4gICAgICAgICMgQHNlZSBodHRwczovL3J1YnktZG9jLm9yZy9jb3JlLTIuNS4wL01hcnNoYWwuaHRtbCNtZXRob2QtYy1sb2FkXG4gICAgICAgICMgICBNYXJzaGFsLmxvYWRcbiAgICAgICAgIyBAbm90ZSBVc2Ugb2ZcbiAgICAgICAgIyAgIHtodHRwczovL3J1YnktZG9jLm9yZy9jb3JlLTIuNS4wL01hcnNoYWwuaHRtbCNtZXRob2QtYy1sb2FkXG4gICAgICAgICMgICBNYXJzaGFsLmxvYWR9IGlzIGdlbmVyYWxseSBkaXNjb3VyYWdlZC4gT25seSB1c2UgdGhpcyB3aXRoIHRydXN0ZWRcbiAgICAgICAgIyAgIGlucHV0LlxuICAgICAgICBkZWYgbG9hZCBmaWxlcGF0aFxuICAgICAgICAgIDo6TWFyc2hhbC5sb2FkIHNlcmlhbGl6ZXIubG9hZCBmaWxlcGF0aFxuICAgICAgICBlbmRcblxuICAgICAgICAjIFNlcmlhbGl6ZXMgYSB7Tm9kZXM6Ok5vZGUgTm9kZX0gYW5kIGR1bXBzIGl0IGFzIGEgbWFyc2hhbGVkIG9iamVjdFxuICAgICAgICAjIGludG8gZmlsZXBhdGguXG4gICAgICAgICMgQHBhcmFtIFtOb2Rlczo6Tm9kZV0gbm9kZSB0aGUgbm9kZSB0byBzZXJpYWxpemVcbiAgICAgICAgIyBAcGFyYW0gW1N0cmluZ10gZmlsZXBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSB0byBkdW1wIHRoZVxuICAgICAgICAjICAgbWFyc2hhbGVkIG9iamVjdCBpbnRvLlxuICAgICAgICAjIEByZXR1cm4gW051bWVyaWNdIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHRvIGRpc2suXG4gICAgICAgICMgQHNlZSBodHRwczovL3J1YnktZG9jLm9yZy9jb3JlLTIuNS4wL01hcnNoYWwuaHRtbCNtZXRob2QtYy1kdW1wXG4gICAgICAgICMgICBNYXJzaGFsLmR1bXBcbiAgICAgICAgZGVmIGR1bXAgbm9kZSwgZmlsZXBhdGhcbiAgICAgICAgICBzZXJpYWxpemVyLmR1bXAgOjpNYXJzaGFsLmR1bXAobm9kZSksIGZpbGVwYXRoXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHByaXZhdGVcblxuICAgICAgICBhdHRyX3JlYWRlciA6c2VyaWFsaXplclxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJpbml0aWFsaXplIiwiQHNlcmlhbGl6ZXIiLCJzZXJpYWxpemVyIiwibmV3IiwibG9hZCIsImZpbGVwYXRoIiwiZHVtcCIsIm5vZGUiLCJwcml2YXRlIiwiYXR0cl9yZWFkZXIiXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0VBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFRUM7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUlFO0FBQUFDLFVBQUFBLDhCQUFBQSx3QkFBQUEsc0JBQWUsVUFBZkE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBWFI7QUFXdUIsWUFBQTtBQUFBLFlBQUEsZUFBYSxHQUFiO0FBQUEsWUFBQSxDQVh2QjtBQUFBLFlBWVUsT0FBQUMsQ0FBQUEsa0JBQWMsY0FBQUMsVUFBQSxTQUFjLElBQUEsSUFBQSxJQUFBLHdCQUFBLFNBQUEsZ0JBQUEsU0FBQUMsS0FBQUEsQ0FBQUEsQ0FBZCxDQUFkRixDQVpWO0FBV1FELFVBQUFBLENBQUFBLG9DQUFBQSxDQUFBO0FBQUE7QUFlQUksVUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxRQUFUQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLElBQUEsSUFBQSxZQUFBQSxNQUFBQSxLQUFlRixZQUFBQSxDQUFBQSxDQUFBRSxNQUFBQSxDQUFnQkMsUUFBaEJELENBQWZBO0FBREZBLFVBQUFBLENBQUFBLDZCQUFBQSxDQWZBO0FBQUE7QUEyQkFFLFVBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVMsSUFBQSxFQUFNLFFBQWZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLFdBQUFKLFlBQUFBLENBQUFBLENBQUFJLE1BQUFBLENBQWdCLElBQUEsSUFBQSxZQUFBQSxNQUFBQSxDQUFlQyxJQUFmRCxHQUFzQkQsUUFBdENDO0FBREZBLFVBQUFBLENBQUFBLDZCQUFBQSxDQTNCQTtBQUFBLGNBK0JBRSxTQUFBQSxDQUFBQSxDQS9CQTtBQUFBLFVBaUNBLFdBQUFDLGFBQUFBLENBQVksWUFBWkEsQ0FqQ0E7QUFKRlYsUUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGRkQsTUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDM4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvc2VyaWFsaXplcnMveWFtbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICBtb2R1bGUgU2VyaWFsaXplcnNcbiAgICAgICMgU2VyaWFsaXplciBmb3IgUnVieSB5YW1sIGZvcm1hdCAoLnlhbWwpIGZpbGVzLlxuICAgICAgY2xhc3MgWWFtbFxuICAgICAgICAjIENyZWF0ZXMgYSBuZXcgWWFtbCBzZXJpYWxpemVyLlxuICAgICAgICAjIEBwYXJhbSBbU2VyaWFsaXplcl0gc2VyaWFsaXplciB0aGUgc2VyaWFsaXplciByZXNwb25zaWJsZSB0byB3cml0ZSB0b1xuICAgICAgICAjICAgYW5kIHJlYWQgZnJvbSBkaXNrLlxuICAgICAgICBkZWYgaW5pdGlhbGl6ZSBzZXJpYWxpemVyID0gbmlsXG4gICAgICAgICAgQHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IFJhbWJsaW5nOjpUcmllOjpTZXJpYWxpemVyczo6RmlsZS5uZXdcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBMb2FkcyBzZXJpYWxpemVkIG9iamVjdCBmcm9tIFlBTUwgZmlsZSBpbiBmaWxlcGF0aCBhbmQgZGVzZXJpYWxpemVzXG4gICAgICAgICMgaXQgaW50byBhIHtOb2Rlczo6Tm9kZSBOb2RlfS5cbiAgICAgICAgIyBAcGFyYW0gW1N0cmluZ10gZmlsZXBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSB0byBsb2FkIHRoZVxuICAgICAgICAjICAgc2VyaWFsaXplZCBZQU1MIG9iamVjdCBmcm9tLlxuICAgICAgICAjIEByZXR1cm4gW05vZGVzOjpOb2RlXSBUaGUgZGVzZXJpYWxpemVkIHtOb2Rlczo6Tm9kZSBOb2RlfS5cbiAgICAgICAgIyBAc2VlIGh0dHBzOi8vcnVieS1kb2Mub3JnL3N0ZGxpYi0yLjUuMC9saWJkb2MvcHN5Y2gvcmRvYy9Qc3ljaC5odG1sI21ldGhvZC1jLXNhZmVfbG9hZFxuICAgICAgICAjICAgUHN5Y2guc2FmZV9sb2FkXG4gICAgICAgIGRlZiBsb2FkIGZpbGVwYXRoXG4gICAgICAgICAgcmVxdWlyZSAneWFtbCdcbiAgICAgICAgICA6OllBTUwuc2FmZV9sb2FkKFxuICAgICAgICAgICAgc2VyaWFsaXplci5sb2FkKGZpbGVwYXRoKSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgU3ltYm9sLFxuICAgICAgICAgICAgICBSYW1ibGluZzo6VHJpZTo6Tm9kZXM6OlJhdyxcbiAgICAgICAgICAgICAgUmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpDb21wcmVzc2VkLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICApXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgU2VyaWFsaXplcyBhIHtOb2Rlczo6Tm9kZSBOb2RlfSBhbmQgZHVtcHMgaXQgYXMgYSBZQU1MIG9iamVjdCBpbnRvXG4gICAgICAgICMgZmlsZXBhdGguXG4gICAgICAgICMgQHBhcmFtIFtOb2Rlczo6Tm9kZV0gbm9kZSB0aGUgbm9kZSB0byBzZXJpYWxpemVcbiAgICAgICAgIyBAcGFyYW0gW1N0cmluZ10gZmlsZXBhdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSB0byBkdW1wIHRoZSBZQU1MXG4gICAgICAgICMgICBvYmplY3QgaW50by5cbiAgICAgICAgIyBAcmV0dXJuIFtOdW1lcmljXSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiB0byBkaXNrLlxuICAgICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvc3RkbGliLTIuNS4wL2xpYmRvYy9wc3ljaC9yZG9jL1BzeWNoLmh0bWwjbWV0aG9kLWMtZHVtcFxuICAgICAgICAjICAgUHN5Y2guZHVtcFxuICAgICAgICBkZWYgZHVtcCBub2RlLCBmaWxlcGF0aFxuICAgICAgICAgIHJlcXVpcmUgJ3lhbWwnXG4gICAgICAgICAgc2VyaWFsaXplci5kdW1wIDo6WUFNTC5kdW1wKG5vZGUpLCBmaWxlcGF0aFxuICAgICAgICBlbmRcblxuICAgICAgICBwcml2YXRlXG5cbiAgICAgICAgYXR0cl9yZWFkZXIgOnNlcmlhbGl6ZXJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5pdGlhbGl6ZSIsIkBzZXJpYWxpemVyIiwic2VyaWFsaXplciIsIm5ldyIsImxvYWQiLCJyZXF1aXJlIiwic2FmZV9sb2FkIiwiZmlsZXBhdGgiLCJkdW1wIiwibm9kZSIsInByaXZhdGUiLCJhdHRyX3JlYWRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUVFQztBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBSUU7QUFBQUMsVUFBQUEsOEJBQUFBLHFCQUFBQSxzQkFBZSxVQUFmQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFYUjtBQVd1QixZQUFBO0FBQUEsWUFBQSxlQUFhLEdBQWI7QUFBQSxZQUFBLENBWHZCO0FBQUEsWUFZVSxPQUFBQyxDQUFBQSxrQkFBYyxjQUFBQyxVQUFBLFNBQWMsSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxnQkFBQSxTQUFBQyxLQUFBQSxDQUFBQSxDQUFkLENBQWRGLENBWlY7QUFXUUQsVUFBQUEsQ0FBQUEsaUNBQUFBLENBQUE7QUFBQTtBQVdBSSxVQUFBQSx3QkFBQUEsZUFBQUEsZ0JBQVMsUUFBVEE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBQ0UsZ0JBQUFDLFNBQUFBLENBQVEsTUFBUkEsQ0FBQTtBQUFBLFlBQ0EsT0FBQSxJQUFBLElBQUEsU0FBQUMsV0FBQUEsS0FDRUosWUFBQUEsQ0FBQUEsQ0FBQUUsTUFBQUEsQ0FBZ0JHLFFBQWhCSCxHQUNBLENBQ0Usc0JBREYsRUFFRSxJQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLFVBQUEsUUFGRixFQUdFLElBQUEsSUFBQSxJQUFBLHdCQUFBLFNBQUEsVUFBQSxlQUhGLEdBS0EsSUFDQSxJQVJGRSxDQURBO0FBREZGLFVBQUFBLENBQUFBLDBCQUFBQSxDQVhBO0FBQUE7QUFpQ0FJLFVBQUFBLHdCQUFBQSxlQUFBQSxnQkFBUyxJQUFBLEVBQU0sUUFBZkE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBQ0UsZ0JBQUFILFNBQUFBLENBQVEsTUFBUkEsQ0FBQTtBQUFBLFlBQ0EsV0FBQUgsWUFBQUEsQ0FBQUEsQ0FBQU0sTUFBQUEsQ0FBZ0IsSUFBQSxJQUFBLFNBQUFBLE1BQUFBLENBQVlDLElBQVpELEdBQW1CRCxRQUFuQ0MsQ0FEQTtBQURGQSxVQUFBQSxDQUFBQSwwQkFBQUEsQ0FqQ0E7QUFBQSxjQXNDQUUsU0FBQUEsQ0FBQUEsQ0F0Q0E7QUFBQSxVQXdDQSxXQUFBQyxhQUFBQSxDQUFZLFlBQVpBLENBeENBO0FBSkZaLFFBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkZELE1BQUFBLEdBQUFBLFdBQUFBO0FBREZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ0NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL3NlcmlhbGl6ZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbmlmIFJVQllfRU5HSU5FID09ICdvcGFsJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL3NlcmlhbGl6ZXJzL2ZpbGUnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvc2VyaWFsaXplcnMvbWFyc2hhbCdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9zZXJpYWxpemVycy95YW1sJ1xuZWxzZSAgICBcbiAgJXcoZmlsZSBtYXJzaGFsIHlhbWwgemlwKS5lYWNoIGRvIHxmaWxlfFxuICAgIHJlcXVpcmUgRmlsZS5qb2luKCdyYW1ibGluZycsICd0cmllJywgJ3NlcmlhbGl6ZXJzJywgZmlsZSlcbiAgZW5kXG5lbmRcblxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICAjIE5hbWVzcGFjZSBmb3IgYWxsIHNlcmlhbGl6ZXJzLlxuICAgIG1vZHVsZSBTZXJpYWxpemVyc1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIj09IiwicmVxdWlyZSIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsRUFBQSxJQUFHLDJCQUFBQSxPQUFBQSxDQUFlLE1BQWZBLENBQUg7QUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsZ0NBQVJBLENBQUE7QUFBQSxRQUNBQSxTQUFBQSxDQUFRLG1DQUFSQSxDQURBO0FBQUEsUUFFQUEsU0FBQUEsQ0FBUSxnQ0FBUkEsQ0FGQTtBQURGLEVBQUE7QUFBQSxJQUFBO0FBQUEsRUFBQSxDQUFBO0FBQUEsRUFXQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQSxNQUFBQSxHQUFBQSxXQUFBQTtBQUZGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQSxXQVhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ0NzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL3N0cmluZ2lmeWFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBQcm92aWRlcyB0aGUgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGJlaGF2aW9yIGZvciB0aGUgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICBtb2R1bGUgU3RyaW5naWZ5YWJsZVxuICAgICAgIyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZSwgaWYgaXQgaXMgYSB0ZXJtaW5hbCBub2RlLlxuICAgICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgICMgQHJhaXNlIFtJbnZhbGlkT3BlcmF0aW9uXSBpZiBub2RlIGlzIG5vdCB0ZXJtaW5hbCBvciBpcyByb290LlxuICAgICAgZGVmIGFzX3dvcmRcbiAgICAgICAgaWYgbGV0dGVyICYmICF0ZXJtaW5hbD9cbiAgICAgICAgICByYWlzZSBSYW1ibGluZzo6VHJpZTo6SW52YWxpZE9wZXJhdGlvbixcbiAgICAgICAgICAgICdDYW5ub3QgcmVwcmVzZW50IGJyYW5jaCBhcyBhIHdvcmQnXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHRvX3NcbiAgICAgIGVuZFxuXG4gICAgICAjIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIGRlZiB0b19zXG4gICAgICAgIHBhcmVudC50b19zICsgbGV0dGVyLnRvX3NcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImFzX3dvcmQiLCJsZXR0ZXIiLCJ0ZXJtaW5hbD8iLCIhIiwicmFpc2UiLCJ0b19zIiwiKyIsInBhcmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUlFO0FBQUFDLFFBQUFBLDJCQUFBQSwyQkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztBQUFBQTtBQUNFLFVBQUEsSUFBQSxRQUFHLGtCQUFBQyxRQUFBQSxDQUFBQSxDQUFBLFFBQVdDLGNBQUFBLENBQUFBLENBQURDLE1BQUFBLENBQUFBLENBQVYsTUFBSCxDQUFBO0FBQUEsZ0JBQ0VDLE9BQUFBLENBQU0sSUFBQSxJQUFBLHdCQUFBLFNBQUEsdUJBQ0osbUNBREZBLENBREYsQ0FBQTtBQUFBLFVBS0EsV0FBQUMsTUFBQUEsQ0FBQUEsQ0FMQTtBQURGTCxRQUFBQSxDQUFBQSxzQ0FBQUEsQ0FBQTtBQUFBO0FBV0FLLFFBQUFBLHdCQUFBQSx3QkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUFDLGFBQUFDLFFBQUFBLENBQUFBLENBQUFGLE1BQUFBLENBQUFBLENBQUFDLE1BQWNMLFFBQUFBLENBQUFBLENBQUFJLE1BQUFBLENBQUFBLENBQWRDO0FBREZELFFBQUFBLENBQUFBLG1DQUFBQSxDQVhBO0FBSkZOLE1BQUFBLEdBQUFBLFdBQUFBO0FBRkZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1MjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL25vZGVzL25vZGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgbW9kdWxlIE5vZGVzXG4gICAgICAjIEEgcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIGluIHRoZSB0cmllIGRhdGEgc3RydWN0dXJlLlxuICAgICAgY2xhc3MgTm9kZVxuICAgICAgICBpbmNsdWRlIFJhbWJsaW5nOjpUcmllOjpDb21wcmVzc2libGVcbiAgICAgICAgaW5jbHVkZSBSYW1ibGluZzo6VHJpZTo6RW51bWVyYWJsZVxuICAgICAgICBpbmNsdWRlIFJhbWJsaW5nOjpUcmllOjpDb21wYXJhYmxlXG4gICAgICAgIGluY2x1ZGUgUmFtYmxpbmc6OlRyaWU6OlN0cmluZ2lmeWFibGVcbiAgICAgICAgaW5jbHVkZSBSYW1ibGluZzo6VHJpZTo6SW5zcGVjdGFibGVcblxuICAgICAgICAjIEBvdmVybG9hZCBsZXR0ZXJcbiAgICAgICAgIyAgIExldHRlcihzKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAgICMgQG92ZXJsb2FkIGxldHRlcj0obGV0dGVyKVxuICAgICAgICAjICAgU2V0cyB0aGUgbGV0dGVyKHMpIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgbm9kZS4gRW5zdXJlcyB0aGVcbiAgICAgICAgIyAgIHtOb2RlI2xldHRlciAjbGV0dGVyfSBpbiB0aGUge05vZGUjcGFyZW50ICNwYXJlbnR9J3NcbiAgICAgICAgIyAgIHtOb2RlI2NoaWxkcmVuX3RyZWUgI2NoaWxkcmVuX3RyZWV9IGlzIHVwZGF0ZWQuXG4gICAgICAgICMgICBAcGFyYW0gW1N0cmluZywgU3ltYm9sLCBuaWxdIGxldHRlciB0aGUgbGV0dGVyIHZhbHVlLlxuICAgICAgICAjIEByZXR1cm4gW1N5bWJvbCwgbmlsXSB0aGUgY29ycmVzcG9uZGluZyBsZXR0ZXIocykuXG4gICAgICAgIGF0dHJfcmVhZGVyIDpsZXR0ZXJcblxuICAgICAgICAjIENoaWxkIG5vZGVzIHRyZWUuXG4gICAgICAgICMgQHJldHVybiBbSGFzaF0gdGhlIGNoaWxkcmVuX3RyZWUgaGFzaCwgY29uc2lzdGluZyBvZiBgOmxldHRlciA9PlxuICAgICAgICAjICAgbm9kZWAuXG4gICAgICAgIGF0dHJfYWNjZXNzb3IgOmNoaWxkcmVuX3RyZWVcblxuICAgICAgICAjIFBhcmVudCBub2RlLlxuICAgICAgICAjIEByZXR1cm4gW05vZGUsIG5pbF0gdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgICBhdHRyX2FjY2Vzc29yIDpwYXJlbnRcblxuICAgICAgICAjIENyZWF0ZXMgYSBuZXcgbm9kZS5cbiAgICAgICAgIyBAcGFyYW0gW1N5bWJvbCwgbmlsXSBsZXR0ZXIgdGhlIE5vZGUncyBsZXR0ZXIgdmFsdWVcbiAgICAgICAgIyBAcGFyYW0gW05vZGUsIG5pbF0gcGFyZW50IHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgICAgZGVmIGluaXRpYWxpemUgbGV0dGVyID0gbmlsLCBwYXJlbnQgPSBuaWwsIGNoaWxkcmVuX3RyZWUgPSB7fVxuICAgICAgICAgIEBsZXR0ZXIgPSBsZXR0ZXJcbiAgICAgICAgICBAcGFyZW50ID0gcGFyZW50XG4gICAgICAgICAgQGNoaWxkcmVuX3RyZWUgPSBjaGlsZHJlbl90cmVlXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgQ2hpbGQgbm9kZXMuXG4gICAgICAgICMgQHJldHVybiBbQXJyYXk8Tm9kZT5dIHRoZSBhcnJheSBvZiBjaGlsZHJlbiBub2RlcyBjb250YWluZWRcbiAgICAgICAgIyAgIGluIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAgIGRlZiBjaGlsZHJlblxuICAgICAgICAgIGNoaWxkcmVuX3RyZWUudmFsdWVzXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgRmlyc3QgY2hpbGQgbm9kZS5cbiAgICAgICAgIyBAcmV0dXJuIFtOb2RlLCBuaWxdIHRoZSBmaXJzdCBjaGlsZCBjb250YWluZWQgaW4gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgICAgZGVmIGZpcnN0X2NoaWxkXG4gICAgICAgICAgcmV0dXJuIGlmIGNoaWxkcmVuX3RyZWUuZW1wdHk/XG5cbiAgICAgICAgICBjaGlsZHJlbl90cmVlLmVhY2hfdmFsdWUgZG8gfGNoaWxkfFxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgSW5kaWNhdGVzIGlmIHRoZSBjdXJyZW50IG5vZGUgaXMgdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgaWYgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHBhcmVudCwgYGZhbHNlYFxuICAgICAgICAjICAgb3RoZXJ3aXNlLlxuICAgICAgICBkZWYgcm9vdD9cbiAgICAgICAgICAhcGFyZW50XG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgSW5kaWNhdGVzIGlmIGEge05vZGUgTm9kZX0gaXMgdGVybWluYWwgb3Igbm90LlxuICAgICAgICAjIEByZXR1cm4gW0Jvb2xlYW5dIGB0cnVlYCBmb3IgdGVybWluYWwgbm9kZXMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgICBkZWYgdGVybWluYWw/XG4gICAgICAgICAgISF0ZXJtaW5hbFxuICAgICAgICBlbmRcblxuICAgICAgICAjIE1hcmsge05vZGUgTm9kZX0gYXMgdGVybWluYWwuXG4gICAgICAgICMgQHJldHVybiBbTm9kZV0gdGhlIG1vZGlmaWVkIG5vZGUuXG4gICAgICAgIGRlZiB0ZXJtaW5hbCFcbiAgICAgICAgICBzZWxmLnRlcm1pbmFsID0gdHJ1ZVxuICAgICAgICAgIHNlbGZcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGxldHRlcj0gbGV0dGVyXG4gICAgICAgICAgQGxldHRlciA9IGxldHRlci50b19zeW0gaWYgbGV0dGVyXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgQ2hlY2tzIGlmIGEgcGF0aCBmb3IgYSBzZXQgb2YgY2hhcmFjdGVycyBleGlzdHMgaW4gdGhlIHRyaWUuXG4gICAgICAgICMgQHBhcmFtIFtBcnJheTxTdHJpbmc+XSBjaGFycyB0aGUgY2hhcmFjdGVycyB0byBsb29rIGZvciBpbiB0aGUgdHJpZS5cbiAgICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgaWYgdGhlIGNoYXJhY3RlcnMgYXJlIGZvdW5kLCBgZmFsc2VgXG4gICAgICAgICMgICBvdGhlcndpc2UuXG4gICAgICAgIGRlZiBwYXJ0aWFsX3dvcmQ/IGNoYXJzXG4gICAgICAgICAgcmV0dXJuIHRydWUgaWYgY2hhcnMuZW1wdHk/XG5cbiAgICAgICAgICBwYXJ0aWFsX3dvcmRfY2hhcnM/IGNoYXJzXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgQ2hlY2tzIGlmIGEgcGF0aCBmb3Igc2V0IG9mIGNoYXJhY3RlcnMgcmVwcmVzZW50cyBhIHdvcmQgaW4gdGhlIHRyaWUuXG4gICAgICAgICMgQHBhcmFtIFtBcnJheTxTdHJpbmc+XSBjaGFycyB0aGUgY2hhcmFjdGVycyB0byBsb29rIGZvciBpbiB0aGUgdHJpZS5cbiAgICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgaWYgdGhlIGNoYXJhY3RlcnMgYXJlIGZvdW5kIGFuZCBmb3JtIGEgd29yZCxcbiAgICAgICAgIyAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgICBkZWYgd29yZD8gY2hhcnMgPSBbXVxuICAgICAgICAgIHJldHVybiB0ZXJtaW5hbD8gaWYgY2hhcnMuZW1wdHk/XG5cbiAgICAgICAgICB3b3JkX2NoYXJzPyBjaGFyc1xuICAgICAgICBlbmRcblxuICAgICAgICAjIFJldHVybnMgdGhlIG5vZGUgdGhhdCBzdGFydHMgd2l0aCB0aGUgc3BlY2lmaWVkIGNoYXJhY3RlcnMuXG4gICAgICAgICMgQHBhcmFtIFtBcnJheTxTdHJpbmc+XSBjaGFycyB0aGUgY2hhcmFjdGVycyB0byBsb29rIGZvciBpbiB0aGUgdHJpZS5cbiAgICAgICAgIyBAcmV0dXJuIFtOb2RlXSB0aGUgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXJzLlxuICAgICAgICAjICAge01pc3NpbmcgTWlzc2luZ30gd2hlbiBub3QgZm91bmQuXG4gICAgICAgIGRlZiBzY2FuIGNoYXJzXG4gICAgICAgICAgcmV0dXJuIHNlbGYgaWYgY2hhcnMuZW1wdHk/XG5cbiAgICAgICAgICBjbG9zZXN0X25vZGUgY2hhcnNcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBSZXR1cm5zIGFsbCB3b3JkcyB0aGF0IG1hdGNoIGEgcHJlZml4IG9mIGFueSBsZW5ndGggd2l0aGluIGNoYXJzLlxuICAgICAgICAjIEBwYXJhbSBbU3RyaW5nXSBjaGFycyB0aGUgY2hhcnMgdG8gYmFzZSB0aGUgcHJlZml4IG9uLlxuICAgICAgICAjIEByZXR1cm4gW0VudW1lcmF0b3I8U3RyaW5nPl0gYWxsIHRoZSB3b3JkcyB0aGF0IG1hdGNoIGEgcHJlZml4IGdpdmVuXG4gICAgICAgICMgICBieSBjaGFycy5cbiAgICAgICAgIyBAeWllbGQgW1N0cmluZ10gZWFjaCB3b3JkIGZvdW5kLlxuICAgICAgICBkZWYgbWF0Y2hfcHJlZml4IGNoYXJzXG4gICAgICAgICAgcmV0dXJuIGVudW1fZm9yIDptYXRjaF9wcmVmaXgsIGNoYXJzIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICAgICAgIHlpZWxkIGFzX3dvcmQgaWYgdGVybWluYWw/XG5cbiAgICAgICAgICBjaGlsZHJlbl9tYXRjaF9wcmVmaXggY2hhcnMgZG8gfHdvcmR8XG4gICAgICAgICAgICB5aWVsZCB3b3JkXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgR2V0IHtOb2RlIE5vZGV9IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsZXR0ZXIuXG4gICAgICAgICMgQHBhcmFtIFtTeW1ib2xdIGxldHRlciB0aGUgbGV0dGVyIHRvIHNlYXJjaCBmb3IgaW4gdGhlIG5vZGUuXG4gICAgICAgICMgQHJldHVybiBbTm9kZV0gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byB0aGF0IGxldHRlci5cbiAgICAgICAgIyBAc2VlIGh0dHBzOi8vcnVieS1kb2Mub3JnL2NvcmUtMi41LjAvSGFzaC5odG1sI21ldGhvZC1pLTVCLTVEXG4gICAgICAgICMgICBIYXNoI1tdXG4gICAgICAgIGRlZiBbXSBsZXR0ZXJcbiAgICAgICAgICBjaGlsZHJlbl90cmVlW2xldHRlcl1cbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBTZXQgdGhlIHtOb2RlIE5vZGV9IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBsZXR0ZXIuXG4gICAgICAgICMgQHBhcmFtIFtTeW1ib2xdIGxldHRlciB0aGUgbGV0dGVyIHRvIGluc2VydCBvciB1cGRhdGUgaW4gdGhlIG5vZGUnc1xuICAgICAgICAjIEBwYXJhbSBbTm9kZV0gbm9kZSB0aGUge05vZGUgTm9kZX0gdG8gYXNzaWduIHRvIHRoYXQgbGV0dGVyLlxuICAgICAgICAjIEByZXR1cm4gW05vZGVdIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluc2VydGVkIG9yXG4gICAgICAgICMgICB1cGRhdGVkIGxldHRlci5cbiAgICAgICAgIyBAc2VlIGh0dHBzOi8vcnVieS1kb2Mub3JnL2NvcmUtMi41LjAvSGFzaC5odG1sI21ldGhvZC1pLTVCLTVEXG4gICAgICAgICMgICBIYXNoI1tdXG4gICAgICAgIGRlZiBbXT0gbGV0dGVyLCBub2RlXG4gICAgICAgICAgY2hpbGRyZW5fdHJlZVtsZXR0ZXJdID0gbm9kZVxuICAgICAgICBlbmRcblxuICAgICAgICAjIENoZWNrIGlmIGEge05vZGUgTm9kZX0ncyBjaGlsZHJlbiB0cmVlIGNvbnRhaW5zIGEgZ2l2ZW5cbiAgICAgICAgIyAgIGxldHRlci5cbiAgICAgICAgIyBAcGFyYW0gW1N5bWJvbF0gbGV0dGVyIHRoZSBsZXR0ZXIgdG8gc2VhcmNoIGZvciBpbiB0aGUgbm9kZS5cbiAgICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBgdHJ1ZWAgaWYgdGhlIGxldHRlciBpcyBwcmVzZW50LCBgZmFsc2VgIG90aGVyd2lzZVxuICAgICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9IYXNoLmh0bWwjbWV0aG9kLWktaGFzX2tleS0zRlxuICAgICAgICAjICAgSGFzaCNrZXk/XG4gICAgICAgIGRlZiBrZXk/IGxldHRlclxuICAgICAgICAgIGNoaWxkcmVuX3RyZWUua2V5PyBsZXR0ZXJcbiAgICAgICAgZW5kXG5cbiAgICAgICAgIyBEZWxldGUgYSBnaXZlbiBsZXR0ZXIgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHtOb2RlIE5vZGV9IGZyb21cbiAgICAgICAgIyAgIHRoaXMge05vZGUgTm9kZX0ncyBjaGlsZHJlbiB0cmVlLlxuICAgICAgICAjIEBwYXJhbSBbU3ltYm9sXSBsZXR0ZXIgdGhlIGxldHRlciB0byBkZWxldGUgZnJvbSB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gICAgICAgICMgICB0cmVlLlxuICAgICAgICAjIEByZXR1cm4gW05vZGVdIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRlbGV0ZWQgbGV0dGVyLlxuICAgICAgICAjIEBzZWUgaHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9IYXNoLmh0bWwjbWV0aG9kLWktZGVsZXRlXG4gICAgICAgICMgICBIYXNoI2RlbGV0ZVxuICAgICAgICBkZWYgZGVsZXRlIGxldHRlclxuICAgICAgICAgIGNoaWxkcmVuX3RyZWUuZGVsZXRlIGxldHRlclxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOmhhc19rZXk/LCA6a2V5P1xuXG4gICAgICAgIHByb3RlY3RlZFxuXG4gICAgICAgIGRlZiBtaXNzaW5nXG4gICAgICAgICAgUmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpNaXNzaW5nLm5ld1xuICAgICAgICBlbmRcblxuICAgICAgICBwcml2YXRlXG5cbiAgICAgICAgYXR0cl9hY2Nlc3NvciA6dGVybWluYWxcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiYXR0cl9hY2Nlc3NvciIsImluaXRpYWxpemUiLCJAbGV0dGVyIiwibGV0dGVyIiwiQHBhcmVudCIsInBhcmVudCIsIkBjaGlsZHJlbl90cmVlIiwiY2hpbGRyZW5fdHJlZSIsImNoaWxkcmVuIiwidmFsdWVzIiwiZmlyc3RfY2hpbGQiLCJlbXB0eT8iLCJlYWNoX3ZhbHVlIiwiY2hpbGQiLCJyb290PyIsIiEiLCJ0ZXJtaW5hbD8iLCJ0ZXJtaW5hbCIsInRlcm1pbmFsISIsIiR3cml0ZXIiLCJ0ZXJtaW5hbD0iLCJzZWxmIiwiLSIsIjEiLCJsZXR0ZXI9IiwidG9fc3ltIiwicGFydGlhbF93b3JkPyIsImNoYXJzIiwicGFydGlhbF93b3JkX2NoYXJzPyIsIndvcmQ/Iiwid29yZF9jaGFycz8iLCJzY2FuIiwiY2xvc2VzdF9ub2RlIiwibWF0Y2hfcHJlZml4IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJhc193b3JkIiwiY2hpbGRyZW5fbWF0Y2hfcHJlZml4Iiwid29yZCIsIltdIiwiW109Iiwibm9kZSIsImtleT8iLCJkZWxldGUiLCJhbGlhc19tZXRob2QiLCJwcm90ZWN0ZWQiLCJtaXNzaW5nIiwibmV3IiwicHJpdmF0ZSJdLCJt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LFdBQUFBO0FBREZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ3MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL25vZGVzL2NvbXByZXNzZWQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgbW9kdWxlIE5vZGVzXG4gICAgICAjIEEgcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIGluIGFuIGNvbXByZXNzZWQgdHJpZSBkYXRhIHN0cnVjdHVyZS5cbiAgICAgIGNsYXNzIENvbXByZXNzZWQgPCBSYW1ibGluZzo6VHJpZTo6Tm9kZXM6Ok5vZGVcbiAgICAgICAgIyBBbHdheXMgcmFpc2VzIHtSYW1ibGluZzo6VHJpZTo6SW52YWxpZE9wZXJhdGlvbiBJbnZhbGlkT3BlcmF0aW9ufSB3aGVuXG4gICAgICAgICMgdHJ5aW5nIHRvIGFkZCBhIHdvcmQgdG8gdGhlIGN1cnJlbnQgY29tcHJlc3NlZCB0cmllIG5vZGVcbiAgICAgICAgIyBAcGFyYW0gW1N0cmluZ10gXyB0aGUgd29yZCB0byBhZGQgdG8gdGhlIHRyaWUuXG4gICAgICAgICMgQHJhaXNlIFtJbnZhbGlkT3BlcmF0aW9uXSBpZiB0aGUgdHJpZSBpcyBhbHJlYWR5IGNvbXByZXNzZWQuXG4gICAgICAgICMgQHJldHVybiBbbmlsXSB0aGlzIG5ldmVyIHJldHVybnMgYXMgaXQgYWx3YXlzIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICAgIGRlZiBhZGQgX1xuICAgICAgICAgIHJhaXNlIFJhbWJsaW5nOjpUcmllOjpJbnZhbGlkT3BlcmF0aW9uLFxuICAgICAgICAgICAgJ0Nhbm5vdCBhZGQgd29yZCB0byBjb21wcmVzc2VkIHRyaWUnXG4gICAgICAgIGVuZFxuXG4gICAgICAgICMgQWx3YXlzIHJldHVybiBgdHJ1ZWAgZm9yIGEgY29tcHJlc3NlZCBub2RlLlxuICAgICAgICAjIEByZXR1cm4gW0Jvb2xlYW5dIGFsd2F5cyBgdHJ1ZWAgZm9yIGEgY29tcHJlc3NlZCBub2RlLlxuICAgICAgICBkZWYgY29tcHJlc3NlZD9cbiAgICAgICAgICB0cnVlXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHByaXZhdGVcblxuICAgICAgICBkZWYgcGFydGlhbF93b3JkX2NoYXJzPyBjaGFyc1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5fdHJlZVtjaGFycy5maXJzdC50b19zeW1dXG4gICAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBjaGlsZFxuXG4gICAgICAgICAgY2hpbGRfbGV0dGVyID0gY2hpbGQubGV0dGVyLnRvX3NcblxuICAgICAgICAgIGlmIGNoYXJzLnNpemUgPj0gY2hpbGRfbGV0dGVyLnNpemVcbiAgICAgICAgICAgIGxldHRlciA9IGNoYXJzLnNsaWNlISgwLCBjaGlsZF9sZXR0ZXIuc2l6ZSkuam9pblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnRpYWxfd29yZD8gY2hhcnMgaWYgY2hpbGRfbGV0dGVyID09IGxldHRlclxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgbGV0dGVyID0gY2hhcnMuam9pblxuICAgICAgICAgIGNoaWxkX2xldHRlciA9IGNoaWxkX2xldHRlci5zbGljZSAwLCBsZXR0ZXIuc2l6ZVxuICAgICAgICAgIGNoaWxkX2xldHRlciA9PSBsZXR0ZXJcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIHdvcmRfY2hhcnM/IGNoYXJzXG4gICAgICAgICAgbGV0dGVyID0gY2hhcnMuc2xpY2UhIDBcbiAgICAgICAgICBsZXR0ZXJfc3ltID0gbGV0dGVyLnRvX3N5bVxuXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbl90cmVlW2xldHRlcl9zeW1dXG4gICAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBjaGlsZFxuXG4gICAgICAgICAgbG9vcCBkb1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLndvcmQ/IGNoYXJzIGlmIGxldHRlcl9zeW0gPT0gY2hpbGQubGV0dGVyXG5cbiAgICAgICAgICAgIGJyZWFrIGlmIGNoYXJzLmVtcHR5P1xuXG4gICAgICAgICAgICBsZXR0ZXIgPDwgY2hhcnMuc2xpY2UhKDApXG4gICAgICAgICAgICBsZXR0ZXJfc3ltID0gbGV0dGVyLnRvX3N5bVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGNsb3Nlc3Rfbm9kZSBjaGFyc1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5fdHJlZVtjaGFycy5maXJzdC50b19zeW1dXG4gICAgICAgICAgcmV0dXJuIG1pc3NpbmcgdW5sZXNzIGNoaWxkXG5cbiAgICAgICAgICBjaGlsZF9sZXR0ZXIgPSBjaGlsZC5sZXR0ZXIudG9fc1xuXG4gICAgICAgICAgaWYgY2hhcnMuc2l6ZSA+PSBjaGlsZF9sZXR0ZXIuc2l6ZVxuICAgICAgICAgICAgbGV0dGVyID0gY2hhcnMuc2xpY2UhKDAsIGNoaWxkX2xldHRlci5zaXplKS5qb2luXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuc2NhbiBjaGFycyBpZiBjaGlsZF9sZXR0ZXIgPT0gbGV0dGVyXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICBsZXR0ZXIgPSBjaGFycy5qb2luXG4gICAgICAgICAgY2hpbGRfbGV0dGVyID0gY2hpbGRfbGV0dGVyLnNsaWNlIDAsIGxldHRlci5zaXplXG5cbiAgICAgICAgICBjaGlsZF9sZXR0ZXIgPT0gbGV0dGVyID8gY2hpbGQgOiBtaXNzaW5nXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiBjaGlsZHJlbl9tYXRjaF9wcmVmaXggY2hhcnNcbiAgICAgICAgICByZXR1cm4gZW51bV9mb3IgOmNoaWxkcmVuX21hdGNoX3ByZWZpeCwgY2hhcnMgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICAgICAgcmV0dXJuIGlmIGNoYXJzLmVtcHR5P1xuXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbl90cmVlW2NoYXJzLmZpcnN0LnRvX3N5bV1cbiAgICAgICAgICByZXR1cm4gdW5sZXNzIGNoaWxkXG5cbiAgICAgICAgICBjaGlsZF9sZXR0ZXIgPSBjaGlsZC5sZXR0ZXIudG9fc1xuICAgICAgICAgIGxldHRlciA9IGNoYXJzLnNsaWNlISgwLCBjaGlsZF9sZXR0ZXIuc2l6ZSkuam9pblxuXG4gICAgICAgICAgcmV0dXJuIHVubGVzcyBjaGlsZF9sZXR0ZXIgPT0gbGV0dGVyXG5cbiAgICAgICAgICBjaGlsZC5tYXRjaF9wcmVmaXggY2hhcnMgZG8gfHdvcmR8XG4gICAgICAgICAgICB5aWVsZCB3b3JkXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJhZGQiLCJyYWlzZSIsImNvbXByZXNzZWQ/IiwicHJpdmF0ZSIsInBhcnRpYWxfd29yZF9jaGFycz8iLCJjaGlsZCIsImNoaWxkcmVuX3RyZWUiLCJbXSIsImNoYXJzIiwiZmlyc3QiLCJ0b19zeW0iLCJjaGlsZF9sZXR0ZXIiLCJsZXR0ZXIiLCJ0b19zIiwiPj0iLCJzaXplIiwic2xpY2UhIiwiMCIsImpvaW4iLCI9PSIsInBhcnRpYWxfd29yZD8iLCJzbGljZSIsIndvcmRfY2hhcnM/IiwibGV0dGVyX3N5bSIsImxvb3AiLCJ3b3JkPyIsImVtcHR5PyIsIjw8IiwiY2xvc2VzdF9ub2RlIiwibWlzc2luZyIsInNjYW4iLCJjaGlsZHJlbl9tYXRjaF9wcmVmaXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIm1hdGNoX3ByZWZpeCIsIndvcmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFB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TUMsSUFBTixDQUFBLENBNUZaLENBQUEsa0JBQUEsaUJBQUEsS0EyRlVELENBWkE7QUFERkgsVUFBQUEsQ0FBQUEsaURBQUFBLENBQUFBLGlDQWpFQTtBQU5GaEMsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUIsSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxVQUFBLFNBQW5CQTtBQUZGRCxNQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0ODgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmFtYmxpbmcvdHJpZS9ub2Rlcy9taXNzaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBSYW1ibGluZ1xuICBtb2R1bGUgVHJpZVxuICAgIG1vZHVsZSBOb2Rlc1xuICAgICAgIyBBIHJlcHJlc2VudGF0aW9uIG9mIGEgbWlzc2luZyBub2RlIGluIHRoZSB0cmllIGRhdGEgc3RydWN0dXJlLiBSZXR1cm5lZFxuICAgICAgIyB3aGVuIGEgbm9kZSBpcyBub3QgZm91bmQuXG4gICAgICBjbGFzcyBNaXNzaW5nIDwgUmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpOb2RlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyJdLCJtYXBwaW5ncyI6Ijs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBR0VDO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUEsUUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxVQUFBLFNBQWhCQTtBQUhGRCxNQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxJQUFBQSxHQUFBQSxXQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmFtYmxpbmcvdHJpZS9ub2Rlcy9yYXcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgbW9kdWxlIE5vZGVzXG4gICAgICAjIEEgcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIGluIGFuIHVuY29tcHJlc3NlZCB0cmllIGRhdGEgc3RydWN0dXJlLlxuICAgICAgY2xhc3MgUmF3IDwgUmFtYmxpbmc6OlRyaWU6Ok5vZGVzOjpOb2RlXG4gICAgICAgICMgQWRkcyBhIHdvcmQgdG8gdGhlIGN1cnJlbnQgcmF3ICh1bmNvbXByZXNzZWQpIHRyaWUgbm9kZS5cbiAgICAgICAgIyBAcGFyYW0gW0FycmF5PFN5bWJvbD5dIGNoYXJzIHRoZSBjaGFyIGFycmF5IHRvIGFkZCB0byB0aGUgdHJpZS5cbiAgICAgICAgIyBAcmV0dXJuIFtSYXddIHRoZSBhZGRlZC9tb2RpZmllZCBub2RlIGJhc2VkIG9uIHRoZSB3b3JkIGFkZGVkLlxuICAgICAgICAjIEBub3RlIFRoaXMgbWV0aG9kIGNsZWFycyB0aGUgY29udGVudHMgb2YgdGhlIGNoYXJzIHZhcmlhYmxlLlxuICAgICAgICBkZWYgYWRkIGNoYXJzXG4gICAgICAgICAgaWYgY2hhcnMuZW1wdHk/XG4gICAgICAgICAgICB0ZXJtaW5hbCFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhZGRfdG9fY2hpbGRyZW5fdHJlZSBjaGFyc1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICAjIEFsd2F5cyByZXR1cm4gYGZhbHNlYCBmb3IgYSByYXcgKHVuY29tcHJlc3NlZCkgbm9kZS5cbiAgICAgICAgIyBAcmV0dXJuIFtCb29sZWFuXSBhbHdheXMgYGZhbHNlYCBmb3IgYSByYXcgKHVuY29tcHJlc3NlZCkgbm9kZS5cbiAgICAgICAgZGVmIGNvbXByZXNzZWQ/XG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgcHJpdmF0ZVxuXG4gICAgICAgIGRlZiBhZGRfdG9fY2hpbGRyZW5fdHJlZSBjaGFyc1xuICAgICAgICAgIGxldHRlciA9IGNoYXJzLnBvcFxuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5fdHJlZVtsZXR0ZXJdIHx8IG5ld19ub2RlKGxldHRlcilcbiAgICAgICAgICBjaGlsZC5hZGQgY2hhcnNcbiAgICAgICAgICBjaGlsZFxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgbmV3X25vZGUgbGV0dGVyXG4gICAgICAgICAgbm9kZSA9IFJhbWJsaW5nOjpUcmllOjpOb2Rlczo6UmF3Lm5ldyBsZXR0ZXIsIHNlbGZcbiAgICAgICAgICBjaGlsZHJlbl90cmVlW2xldHRlcl0gPSBub2RlXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgcGFydGlhbF93b3JkX2NoYXJzPyBjaGFycyA9IFtdXG4gICAgICAgICAgbGV0dGVyID0gY2hhcnMuc2hpZnQudG9fc3ltXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbl90cmVlW2xldHRlcl1cbiAgICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNoaWxkXG5cbiAgICAgICAgICBjaGlsZC5wYXJ0aWFsX3dvcmQ/IGNoYXJzXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGRlZiB3b3JkX2NoYXJzPyBjaGFycyA9IFtdXG4gICAgICAgICAgbGV0dGVyID0gY2hhcnMuc2hpZnQudG9fc3ltXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbl90cmVlW2xldHRlcl1cbiAgICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNoaWxkXG5cbiAgICAgICAgICBjaGlsZC53b3JkPyBjaGFyc1xuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgY2xvc2VzdF9ub2RlIGNoYXJzXG4gICAgICAgICAgbGV0dGVyID0gY2hhcnMuc2hpZnQudG9fc3ltXG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbl90cmVlW2xldHRlcl1cbiAgICAgICAgICByZXR1cm4gbWlzc2luZyB1bmxlc3MgY2hpbGRcblxuICAgICAgICAgIGNoaWxkLnNjYW4gY2hhcnNcbiAgICAgICAgZW5kXG5cbiAgICAgICAgZGVmIGNoaWxkcmVuX21hdGNoX3ByZWZpeCBjaGFyc1xuICAgICAgICAgIHJldHVybiBlbnVtX2ZvciA6Y2hpbGRyZW5fbWF0Y2hfcHJlZml4LCBjaGFycyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgICAgICByZXR1cm4gaWYgY2hhcnMuZW1wdHk/XG5cbiAgICAgICAgICBsZXR0ZXIgPSBjaGFycy5zaGlmdC50b19zeW1cbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuX3RyZWVbbGV0dGVyXVxuXG4gICAgICAgICAgcmV0dXJuIHVubGVzcyBjaGlsZFxuXG4gICAgICAgICAgY2hpbGQubWF0Y2hfcHJlZml4IGNoYXJzIGRvIHx3b3JkfFxuICAgICAgICAgICAgeWllbGQgd29yZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYWRkIiwiY2hhcnMiLCJlbXB0eT8iLCJ0ZXJtaW5hbCEiLCJhZGRfdG9fY2hpbGRyZW5fdHJlZSIsImNvbXByZXNzZWQ/IiwicHJpdmF0ZSIsImxldHRlciIsInBvcCIsImNoaWxkIiwiY2hpbGRyZW5fdHJlZSIsIltdIiwibmV3X25vZGUiLCJub2RlIiwibmV3Iiwic2VsZiIsIiR3cml0ZXIiLCJbXT0iLCItIiwiMSIsInBhcnRpYWxfd29yZF9jaGFycz8iLCJzaGlmdCIsInRvX3N5bSIsInBhcnRpYWxfd29yZD8iLCJ3b3JkX2NoYXJzPyIsIndvcmQ/IiwiY2xvc2VzdF9ub2RlIiwibWlzc2luZyIsInNjYW4iLCJjaGlsZHJlbl9tYXRjaF9wcmVmaXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIm1hdGNoX3ByZWZpeCIsIndvcmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0VBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFRUM7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUtFO0FBQUFDLFVBQUFBLHVCQUFBQSxhQUFBQSxlQUFRLEtBQVJBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLElBQUEsUUFBR0MsS0FBQUMsV0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsY0FDRSxXQUFBQyxjQUFBQSxDQUFBQTtBQURGLFlBQUE7QUFBQSxjQUdFLFdBQUFDLHNCQUFBQSxDQUFxQkgsS0FBckJHO0FBSEYsWUFBQTtBQURGSixVQUFBQSxDQUFBQSx3QkFBQUEsQ0FBQTtBQUFBO0FBVUFLLFVBQUFBLCtCQUFBQSx5QkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBQTtBQURGQSxVQUFBQSxDQUFBQSxvQ0FBQUEsQ0FWQTtBQUFBLGNBY0FDLFNBQUFBLENBQUFBLENBZEE7QUFBQTtBQWdCQUYsVUFBQUEsd0NBQUFBLDhCQUFBQSxnQ0FBeUIsS0FBekJBO0FBQUFBLFlBQUFBOztBQUFBQTtBQUNFLFlBQUFHLFNBQVNOLEtBQUFPLEtBQUFBLENBQUFBLENBQVQ7QUFBQSxZQUNBQyxRQUFRLGtCQUFBQyxlQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFjSixNQUFkSSxDQUFBLGFBQXlCQyxVQUFBQSxDQUFTTCxNQUFUSyxDQUF6QixDQURSO0FBQUEsWUFFQUgsS0FBQVQsS0FBQUEs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QUFBQSxZQUVBLElBQUEsUUFBVTlCLEtBQUFDLFdBQUFBLENBQUFBLENBQVYsQ0FBQTtBQUFBLGNBQUEsVUFBQSxDQUZBO0FBQUEsWUFJQUssU0FBU04sS0FBQW9CLE9BQUFBLENBQUFBLENBQUFDLFFBQUFBLENBQUFBLENBSlQ7QUFBQSxZQUtBYixZQUFRQyxlQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFjSixNQUFkSSxDQUxSO0FBQUEsWUFPQSxJQUFBLFFBQWNGLEtBQWQsQ0FBQTtBQUFBLFlBQUE7QUFBQSxjQUFBO0FBQUEsWUFBQSxDQVBBO0FBQUEsWUFTQSxPQUFBdUIsTUFBQXZCLEtBQUF1QixnQkFBQUEsRUFBQUEsQ0FBbUIvQixLQUFuQitCLENBQUFBLEVBM0VWLGdCQTJFdUMsSUEzRXZDLEVBQUE7O0FBQUE7QUFBQTtBQTJFdUMsY0FBQTtBQUFBLGNBQUE7QUFBQSxjQUFBLENBM0V2QztBQUFBLGNBNEVZLE9BQUEsb0JBQU1DLElBQU4sQ0FBQSxDQTVFWixDQUFBLGtCQUFBLGlCQUFBLEtBMkVVRCxDQVRBO0FBREZILFVBQUFBLENBQUFBLDBDQUFBQSxDQUFBQSxpQ0FyREE7QUFMRjlCLFFBQUFBLEdBQUFBLFdBQUFBLEVBQVksSUFBQSxJQUFBLElBQUEsd0JBQUEsU0FBQSxVQUFBLFNBQVpBO0FBRkZELE1BQUFBLEdBQUFBLFdBQUFBO0FBREZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjUwNjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyYW1ibGluZy90cmllL25vZGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbmlmIFJVQllfRU5HSU5FID09ICdvcGFsJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL25vZGVzL25vZGUnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvbm9kZXMvY29tcHJlc3NlZCdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9ub2Rlcy9taXNzaW5nJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL25vZGVzL3JhdydcbmVsc2VcbiAgJXcobm9kZSBtaXNzaW5nIGNvbXByZXNzZWQgcmF3KS5lYWNoIGRvIHxmaWxlfFxuICAgIHJlcXVpcmUgRmlsZS5qb2luKCdyYW1ibGluZycsICd0cmllJywgJ25vZGVzJywgZmlsZSlcbiAgZW5kXG5lbmRcblxubW9kdWxlIFJhbWJsaW5nXG4gIG1vZHVsZSBUcmllXG4gICAgIyBOYW1lc3BhY2UgZm9yIGFsbCBub2Rlcy5cbiAgICBtb2R1bGUgTm9kZXNcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI9PSIsInJlcXVpcmUiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUVBLEVBQUEsSUFBRywyQkFBQUEsT0FBQUEsQ0FBZSxNQUFmQSxDQUFIO0FBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUEsUUFDQUEsU0FBQUEsQ0FBUSxnQ0FBUkEsQ0FEQTtBQUFBLFFBRUFBLFNBQUFBLENBQVEsNkJBQVJBLENBRkE7QUFBQSxRQUdBQSxTQUFBQSxDQUFRLHlCQUFSQSxDQUhBO0FBREYsRUFBQTtBQUFBLElBQUE7QUFBQSxFQUFBLENBQUE7QUFBQSxFQVdBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBLE1BQUFBLEdBQUFBLFdBQUFBO0FBRkZBLElBQUFBLEdBQUFBLFdBQUFBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBLFdBWEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTA5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUvdmVyc2lvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgUmFtYmxpbmdcbiAgbW9kdWxlIFRyaWVcbiAgICAjIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgcmFtYmxpbmctdHJpZS5cbiAgICBWRVJTSU9OID0gJzIuMS4xJ1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVFLHVDQUFVLE9BQVY7QUFGRkEsSUFBQUEsR0FBQUEsV0FBQUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTExNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJhbWJsaW5nL3RyaWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxuaWYgUlVCWV9FTkdJTkUgPT0gJ29wYWwnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvY29uZmlndXJhdGlvbidcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9jb21wYXJhYmxlJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL2NvbXByZXNzaWJsZSdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9jb21wcmVzc29yJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL2NvbnRhaW5lcidcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9lbnVtZXJhYmxlJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL2luc3BlY3RhYmxlJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL2ludmFsaWRfb3BlcmF0aW9uJ1xuICByZXF1aXJlICdyYW1ibGluZy90cmllL3JlYWRlcnMnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvc2VyaWFsaXplcnMnXG4gIHJlcXVpcmUgJ3JhbWJsaW5nL3RyaWUvc3RyaW5naWZ5YWJsZSdcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS9ub2RlcydcbiAgcmVxdWlyZSAncmFtYmxpbmcvdHJpZS92ZXJzaW9uJ1xuZWxzZSAgICBcbiAgJXcoXG4gICAgY29tcGFyYWJsZSBjb21wcmVzc2libGUgY29tcHJlc3NvciBjb25maWd1cmF0aW9uIGNvbnRhaW5lciBlbnVtZXJhYmxlXG4gICAgaW5zcGVjdGFibGUgaW52YWxpZF9vcGVyYXRpb24gcmVhZGVycyBzZXJpYWxpemVycyBzdHJpbmdpZnlhYmxlIG5vZGVzXG4gICAgdmVyc2lvblxuICApLmVhY2ggZG8gfGZpbGV8XG4gICAgcmVxdWlyZSBGaWxlLmpvaW4oJ3JhbWJsaW5nJywgJ3RyaWUnLCBmaWxlKVxuICBlbmRcbmVuZFxuXG4jIEdlbmVyYWwgbmFtZXNwYWNlIGZvciBhbGwgUmFtYmxpbmcgZ2Vtcy5cbm1vZHVsZSBSYW1ibGluZ1xuICAjIEVudHJ5IHBvaW50IGZvciByYW1ibGluZy10cmllIEFQSS5cbiAgbW9kdWxlIFRyaWVcbiAgICBjbGFzcyA8PCBzZWxmXG4gICAgICAjIENyZWF0ZXMgYSBuZXcgUmFtYmxpbmc6OlRyaWUuIEVudHJ5IHBvaW50IGZvciB0aGUgUmFtYmxpbmc6OlRyaWUgQVBJLlxuICAgICAgIyBAcGFyYW0gW1N0cmluZywgbmlsXSBmaWxlcGF0aCB0aGUgZmlsZSB0byBsb2FkIHRoZSB3b3JkcyBmcm9tLlxuICAgICAgIyBAcGFyYW0gW1JlYWRlciwgbmlsXSByZWFkZXIgdGhlIGZpbGUgcGFyc2VyIHRvIGdldCBlYWNoIHdvcmQuXG4gICAgICAjIEByZXR1cm4gW0NvbnRhaW5lcl0gdGhlIHRyaWUganVzdCBjcmVhdGVkLlxuICAgICAgIyBAeWllbGQgW0NvbnRhaW5lcl0gdGhlIHRyaWUganVzdCBjcmVhdGVkLlxuICAgICAgIyBAc2VlIFJhbWJsaW5nOjpUcmllOjpSZWFkZXJzIFJlYWRlcnMuXG4gICAgICBkZWYgY3JlYXRlIGZpbGVwYXRoID0gbmlsLCByZWFkZXIgPSBuaWxcbiAgICAgICAgcm9vdCA9IHJvb3RfYnVpbGRlci5jYWxsXG5cbiAgICAgICAgUmFtYmxpbmc6OlRyaWU6OkNvbnRhaW5lci5uZXcgcm9vdCwgY29tcHJlc3NvciBkbyB8Y29udGFpbmVyfFxuICAgICAgICAgIGlmIGZpbGVwYXRoXG4gICAgICAgICAgICByZWFkZXIgfHw9IHJlYWRlcnMucmVzb2x2ZSBmaWxlcGF0aFxuICAgICAgICAgICAgcmVhZGVyLmVhY2hfd29yZCBmaWxlcGF0aCBkbyB8d29yZHxcbiAgICAgICAgICAgICAgY29udGFpbmVyIDw8IHdvcmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgeWllbGQgY29udGFpbmVyIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAjIExvYWRzIGFuIGV4aXN0aW5nIHRyaWUgZnJvbSBkaXNrIGludG8gbWVtb3J5LiBCeSBkZWZhdWx0LCBpdCB3aWxsXG4gICAgICAjIGRlZHVjZSB0aGUgY29ycmVjdCB3YXkgdG8gZGVzZXJpYWxpemUgYmFzZWQgb24gdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgIyBBdmFpbGFibGUgZm9ybWF0cyBhcmUgYHltbGAsIGBtYXJzaGFsYCwgYW5kIGB6aXBgIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgICAgICMgcHJldmlvdXMgZm9ybWF0cy4gWW91IGNhbiBhbHNvIGRlZmluZSB5b3VyIG93bi5cbiAgICAgICMgQHBhcmFtIFtTdHJpbmddIGZpbGVwYXRoIHRoZSBmaWxlIHRvIGxvYWQgdGhlIHdvcmRzIGZyb20uXG4gICAgICAjIEBwYXJhbSBbU2VyaWFsaXplciwgbmlsXSBzZXJpYWxpemVyIHRoZSBvYmplY3QgcmVzcG9uc2libGUgb2YgbG9hZGluZ1xuICAgICAgIyAgIHRoZSB0cmllIGZyb20gZGlza1xuICAgICAgIyBAcmV0dXJuIFtDb250YWluZXJdIHRoZSB0cmllIGp1c3QgbG9hZGVkLlxuICAgICAgIyBAeWllbGQgW0NvbnRhaW5lcl0gdGhlIHRyaWUganVzdCBsb2FkZWQuXG4gICAgICAjIEBzZWUgUmFtYmxpbmc6OlRyaWU6OlNlcmlhbGl6ZXJzIFNlcmlhbGl6ZXJzLlxuICAgICAgIyBAbm90ZSBVc2Ugb2ZcbiAgICAgICMgICB7aHR0cHM6Ly9ydWJ5LWRvYy5vcmcvY29yZS0yLjUuMC9NYXJzaGFsLmh0bWwjbWV0aG9kLWMtbG9hZFxuICAgICAgIyAgIE1hcnNoYWwubG9hZH0gaXMgZ2VuZXJhbGx5IGRpc2NvdXJhZ2VkLiBPbmx5IHVzZSB0aGUgYC5tYXJzaGFsYFxuICAgICAgIyAgIGZvcm1hdCB3aXRoIHRydXN0ZWQgaW5wdXQuXG4gICAgICBkZWYgbG9hZCBmaWxlcGF0aCwgc2VyaWFsaXplciA9IG5pbFxuICAgICAgICBzZXJpYWxpemVyIHx8PSBzZXJpYWxpemVycy5yZXNvbHZlIGZpbGVwYXRoXG4gICAgICAgIHJvb3QgPSBzZXJpYWxpemVyLmxvYWQgZmlsZXBhdGhcbiAgICAgICAgUmFtYmxpbmc6OlRyaWU6OkNvbnRhaW5lci5uZXcgcm9vdCwgY29tcHJlc3NvciBkbyB8Y29udGFpbmVyfFxuICAgICAgICAgIHlpZWxkIGNvbnRhaW5lciBpZiBibG9ja19naXZlbj9cbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgIyBEdW1wcyBhbiBleGlzdGluZyB0cmllIGZyb20gbWVtb3J5IGludG8gZGlzay4gQnkgZGVmYXVsdCwgaXQgd2lsbFxuICAgICAgIyBkZWR1Y2UgdGhlIGNvcnJlY3Qgd2F5IHRvIHNlcmlhbGl6ZSBiYXNlZCBvbiB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAjIEF2YWlsYWJsZSBmb3JtYXRzIGFyZSBgeW1sYCwgYG1hcnNoYWxgLCBhbmQgYHppcGAgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAgICAgIyBwcmV2aW91cyBmb3JtYXRzLiBZb3UgY2FuIGFsc28gZGVmaW5lIHlvdXIgb3duLlxuICAgICAgIyBAcGFyYW0gW0NvbnRhaW5lcl0gdHJpZSB0aGUgdHJpZSB0byBkdW1wIGludG8gZGlzay5cbiAgICAgICMgQHBhcmFtIFtTdHJpbmddIGZpbGVwYXRoIHRoZSBmaWxlIHRvIGR1bXAgdG8gc2VyaWFsaXplZCB0cmllIGludG8uXG4gICAgICAjIEBwYXJhbSBbU2VyaWFsaXplciwgbmlsXSBzZXJpYWxpemVyIHRoZSBvYmplY3QgcmVzcG9uc2libGUgb2ZcbiAgICAgICMgICBzZXJpYWxpemluZyBhbmQgZHVtcGluZyB0aGUgdHJpZSBpbnRvIGRpc2suXG4gICAgICAjIEBzZWUgUmFtYmxpbmc6OlRyaWU6OlNlcmlhbGl6ZXJzIFNlcmlhbGl6ZXJzLlxuICAgICAgZGVmIGR1bXAgdHJpZSwgZmlsZXBhdGgsIHNlcmlhbGl6ZXIgPSBuaWxcbiAgICAgICAgc2VyaWFsaXplciB8fD0gc2VyaWFsaXplcnMucmVzb2x2ZSBmaWxlcGF0aFxuICAgICAgICBzZXJpYWxpemVyLmR1bXAgdHJpZS5yb290LCBmaWxlcGF0aFxuICAgICAgZW5kXG5cbiAgICAgICMgUHJvdmlkZXMgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGZvciB0aGUgUmFtYmxpbmc6OlRyaWUgZ2VtLlxuICAgICAgIyBAcmV0dXJuIFtDb25maWd1cmF0aW9uOjpQcm9wZXJ0aWVzXSB0aGUgY29uZmlndXJlZCBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAgIyAgIGdlbS5cbiAgICAgICMgQHlpZWxkIFtDb25maWd1cmF0aW9uOjpQcm9wZXJ0aWVzXSB0aGUgY29uZmlndXJlZCBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAgIyAgIGdlbS5cbiAgICAgIGRlZiBjb25maWdcbiAgICAgICAgeWllbGQgcHJvcGVydGllcyBpZiBibG9ja19naXZlbj9cbiAgICAgICAgcHJvcGVydGllc1xuICAgICAgZW5kXG5cbiAgICAgIHByaXZhdGVcblxuICAgICAgZGVmIHByb3BlcnRpZXNcbiAgICAgICAgQHByb3BlcnRpZXMgfHw9IFJhbWJsaW5nOjpUcmllOjpDb25maWd1cmF0aW9uOjpQcm9wZXJ0aWVzLm5ld1xuICAgICAgZW5kXG5cbiAgICAgIGRlZiByZWFkZXJzXG4gICAgICAgIHByb3BlcnRpZXMucmVhZGVyc1xuICAgICAgZW5kXG5cbiAgICAgIGRlZiBzZXJpYWxpemVyc1xuICAgICAgICBwcm9wZXJ0aWVzLnNlcmlhbGl6ZXJzXG4gICAgICBlbmRcblxuICAgICAgZGVmIGNvbXByZXNzb3JcbiAgICAgICAgcHJvcGVydGllcy5jb21wcmVzc29yXG4gICAgICBlbmRcblxuICAgICAgZGVmIHJvb3RfYnVpbGRlclxuICAgICAgICBwcm9wZXJ0aWVzLnJvb3RfYnVpbGRlclxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPT0iLCJyZXF1aXJlIiwibW9kdWxlIiwiY3JlYXRlIiwicm9vdCIsInJvb3RfYnVpbGRlciIsImNhbGwiLCJuZXciLCJjb21wcmVzc29yIiwiZmlsZXBhdGgiLCJyZWFkZXIiLCJyZWFkZXJzIiwicmVzb2x2ZSIsImVhY2hfd29yZCIsImNvbnRhaW5lciIsIjw8Iiwid29yZCIsImJsb2NrX2dpdmVuPyIsImxvYWQiLCJzZXJpYWxpemVyIiwic2VyaWFsaXplcnMiLCJkdW1wIiwidHJpZSIsImNvbmZpZyIsInByb3BlcnRpZXMiLCJwcml2YXRlIiwiQHByb3BlcnRpZXMiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxFQUFBLElBQUcsMkJBQUFBLE9BQUFBLENBQWUsTUFBZkEsQ0FBSDtBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSw2QkFBUkEsQ0FBQTtBQUFBLFFBQ0FBLFNBQUFBLENBQVEsMEJBQVJBLENBREE7QUFBQSxRQUVBQSxTQUFBQSxDQUFRLDRCQUFSQSxDQUZBO0FBQUEsUUFHQUEsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FIQTtBQUFBLFFBSUFBLFNBQUFBLENBQVEseUJBQVJBLENBSkE7QUFBQSxRQUtBQSxTQUFBQSxDQUFRLDBCQUFSQSxDQUxBO0FBQUEsUUFNQUEsU0FBQUEsQ0FBUSwyQkFBUkEsQ0FOQTtBQUFBLFFBT0FBLFNBQUFBLENBQVEsaUNBQVJBLENBUEE7QUFBQSxRQVFBQSxTQUFBQSxDQUFRLHVCQUFSQSxDQVJBO0FBQUEsUUFTQUEsU0FBQUEsQ0FBUSwyQkFBUkEsQ0FUQTtBQUFBLFFBVUFBLFNBQUFBLENBQVEsNkJBQVJBLENBVkE7QUFBQSxRQVdBQSxTQUFBQSxDQUFRLHFCQUFSQSxDQVhBO0FBQUEsUUFZQUEsU0FBQUEsQ0FBUSx1QkFBUkEsQ0FaQTtBQURGLEVBQUE7QUFBQSxJQUFBO0FBQUEsRUFBQSxDQUFBO0FBQUEsRUF5QkEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUVFQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0U7QUFBQSxRQUFBOztBQUFBO0FBT0U7QUFBQUMsUUFBQUEsMEJBQUFBLFlBQUFBLGtCQUFXLFFBQUEsRUFBZ0IsTUFBM0JBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQTtBQXRDTjtBQXNDaUIsVUFBQTtBQUFBLFVBQUEsYUFBVyxHQUFYO0FBQUEsVUFBQSxDQXRDakI7QUFBQTtBQXNDaUMsVUFBQTtBQUFBLFVBQUEsV0FBUyxHQUFUO0FBQUEsVUFBQSxDQXRDakM7QUFBQSxVQXVDUUMsV0FBT0MsY0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0F2Q2Y7QUFBQSxVQXlDUSxPQUFBQyxNQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLGNBQUFBLE9BQUFBLEVBQUFBLENBQThCSCxVQUFNSSxZQUFBQSxDQUFBQSxDQUFwQ0QsQ0FBQUEsRUF6Q1IsZ0JBeUMyRCxTQXpDM0QsRUFBQTs7QUFBQTtBQUFBO0FBeUMyRCxZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0F6QzNEO0FBQUEsWUEwQ1UsSUFBQSxRQUFHRSxRQUFILENBQUE7QUFBQTtBQUNFLGNBQUFDLFNBM0NaLGNBMkNZQSxNQTNDWixhQTJDdUJDLFNBQUFBLENBQUFBLENBQUFDLFNBQUFBLENBQWdCSCxRQUFoQkcsQ0EzQ3ZCLENBMkNZO0FBQUEsY0FDQUMsTUFBQUgsTUFBQUcsYUFBQUEsRUFBQUEsQ0FBaUJKLFFBQWpCSSxDQUFBQSxFQTVDWixnQkE0QzBDLElBNUMxQyxFQUFBOztBQUFBO0FBQUE7QUE0QzBDLGdCQUFBO0FBQUEsZ0JBQUE7QUFBQSxnQkFBQSxDQTVDMUM7QUFBQSxnQkE2Q2MsT0FBQUMsU0FBQUMsT0FBQUEsQ0FBYUMsSUFBYkQsQ0E3Q2QsQ0FBQSxrQkFBQSxpQkFBQSxLQTRDWUYsQ0FEQSxDQURGLENBMUNWO0FBQUEsWUFpRFUsSUFBbUJJLGdCQUFuQjtBQUFBLGNBQUEsT0FBQSxvQkFBTUgsU0FBTixDQUFBO0FBQUEsWUFBQTtBQUFBO0FBQUEsWUFBQSxDQWpEVixDQUFBLGtCQUFBLGlCQUFBLEtBeUNRUCxDQXpDUjtBQXNDTUosUUFBQUEsQ0FBQUEsd0JBQUFBLENBQUE7QUFBQTtBQTZCQWUsUUFBQUEsd0JBQUFBLFVBQUFBLGdCQUFTLFFBQUEsRUFBVSxVQUFuQkE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQUFBO0FBQUFBO0FBbkVOO0FBbUV5QixVQUFBO0FBQUEsVUFBQSxlQUFhLEdBQWI7QUFBQSxVQUFBLENBbkV6QjtBQUFBLFVBb0VRQyxhQXBFUixjQW9FUUEsVUFwRVIsYUFvRXVCQyxhQUFBQSxDQUFBQSxDQUFBUixTQUFBQSxDQUFvQkgsUUFBcEJHLENBcEV2QixDQUFBO0FBQUEsVUFxRVFSLE9BQU9lLFVBQUFELE1BQUFBLENBQWdCVCxRQUFoQlMsQ0FyRWY7QUFBQSxVQXNFUSxPQUFBWCxNQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLGNBQUFBLE9BQUFBLEVBQUFBLENBQThCSCxVQUFNSSxZQUFBQSxDQUFBQSxDQUFwQ0QsQ0FBQUEsRUF0RVIsZ0JBc0UyRCxTQXRFM0QsRUFBQTs7QUFBQTtBQUFBO0FBc0UyRCxZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0F0RTNEO0FBQUEsWUF1RVUsSUFBbUJVLGdCQUFuQjtBQUFBLGNBQUEsT0FBQSxvQkFBTUgsU0FBTixDQUFBO0FBQUEsWUFBQTtBQUFBO0FBQUEsWUFBQSxDQXZFVixDQUFBLGtCQUFBLGlCQUFBLEtBc0VRUCxDQXRFUjtBQW1FTVcsUUFBQUEsQ0FBQUEsc0JBQUFBLENBN0JBO0FBQUE7QUE4Q0FHLFFBQUFBLHdCQUFBQSxVQUFBQSxnQkFBUyxJQUFBLEVBQU0sUUFBTixFQUFnQixVQUF6QkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBcEZOO0FBb0YrQixVQUFBO0FBQUEsVUFBQSxlQUFhLEdBQWI7QUFBQSxVQUFBLENBcEYvQjtBQUFBLFVBcUZRRixhQXJGUixjQXFGUUEsVUFyRlIsYUFxRnVCQyxhQUFBQSxDQUFBQSxDQUFBUixTQUFBQSxDQUFvQkgsUUFBcEJHLENBckZ2QixDQUFBO0FBQUEsVUFzRlEsT0FBQU8sVUFBQUUsTUFBQUEsQ0FBZ0JDLElBQUFsQixNQUFBQSxDQUFBQSxHQUFXSyxRQUEzQlksQ0F0RlI7QUFvRk1BLFFBQUFBLENBQUFBLHNCQUFBQSxDQTlDQTtBQUFBO0FBd0RBRSxRQUFBQSwwQkFBQUEsWUFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQTtBQUNFLFVBQUEsSUFBb0JOLGdCQUFwQjtBQUFBLFlBQUEsd0JBQU1PLFlBQUFBLENBQUFBLENBQU4sQ0FBQSxDQUFBO0FBQUEsVUFDQSxXQUFBQSxZQUFBQSxDQUFBQSxDQURBO0FBREZELFFBQUFBLENBQUFBLHVCQUFBQSxDQXhEQTtBQUFBLFlBNkRBRSxTQUFBQSxDQUFBQSxDQTdEQTtBQUFBO0FBK0RBRCxRQUFBQSw4QkFBQUEsZ0JBQUFBLHNCQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTs7QUFBQUEsVUFDRSxPQUFBRSxDQUFBQSxrQkF0R1IsY0FzR1FBLGVBdEdSLFNBc0d3QixJQUFBLElBQUEsSUFBQSx3QkFBQSxTQUFBLGtCQUFBLGVBQUFuQixLQUFBQSxDQUFBQSxDQXRHeEIsQ0FzR1FtQjtBQURGRixRQUFBQSxDQUFBQSwyQkFBQUEsQ0EvREE7QUFBQTtBQW1FQWIsUUFBQUEsMkJBQUFBLGFBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBYSxZQUFBQSxDQUFBQSxDQUFBYixTQUFBQSxDQUFBQTtBQURGQSxRQUFBQSxDQUFBQSx3QkFBQUEsQ0FuRUE7QUFBQTtBQXVFQVMsUUFBQUEsK0JBQUFBLGtCQUFBQSx1QkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQUksWUFBQUEsQ0FBQUEsQ0FBQUosYUFBQUEsQ0FBQUE7QUFERkEsUUFBQUEsQ0FBQUEsNkJBQUFBLENBdkVBO0FBQUE7QUEyRUFaLFFBQUFBLDhCQUFBQSxpQkFBQUEsc0JBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLFdBQUFnQixZQUFBQSxDQUFBQSxDQUFBaEIsWUFBQUEsQ0FBQUE7QUFERkEsUUFBQUEsQ0FBQUEsNEJBQUFBLENBM0VBO0FBQUEsUUErRUEsT0FBQUgsQ0FBQUEsZ0NBQUFBLG1CQUFBQSx3QkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQW1CLFlBQUFBLENBQUFBLENBQUFuQixjQUFBQSxDQUFBQTtBQURGQSxRQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsd0JBL0VBO0FBUEYsTUFBQSw0QkFBU3NCLElBQVQ7QUFERnpCLElBQUFBLEdBQUFBLFdBQUFBO0FBRkZBLEVBQUFBLEdBQUFBLFdBQUFBLFdBekJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjUyNzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL3JhbWJsaW5nLXRyaWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcblxucmVxdWlyZSAncmFtYmxpbmcvdHJpZSdcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLFdBQUFBLFNBQUFBLENBQVEsZUFBUkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTI4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vanNvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSlNPTlxuICBjbGFzcyBKU09ORXJyb3IgPCBTdGFuZGFyZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIFBhcnNlckVycm9yIDwgSlNPTkVycm9yXG4gIGVuZFxuXG4gICV4e1xuICAgIHZhciAkaGFzT3duID0gT3BhbC5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uICRwYXJzZShzb3VyY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNvdXJjZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICN7cmFpc2UgSlNPTjo6UGFyc2VyRXJyb3IsIGBlLm1lc3NhZ2VgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9fb3BhbCh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGtsYXNzLCBhcnIsIGhhc2gsIGksIGlpLCBrO1xuXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcblxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICByZXR1cm4gbmlsO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG5pbDtcblxuICAgICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBhcnIgPSAje2BvcHRpb25zLmFycmF5X2NsYXNzYC5uZXd9O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgI3tgYXJyYC5wdXNoKGB0b19vcGFsKHZhbHVlW2ldLCBvcHRpb25zKWApfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNoID0gI3tgb3B0aW9ucy5vYmplY3RfY2xhc3NgLm5ld307XG5cbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoJGhhc093bi5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICN7YGhhc2hgW2BrYF0gPSBgdG9fb3BhbCh2YWx1ZVtrXSwgb3B0aW9ucylgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucGFyc2UgJiYgKGtsYXNzID0gI3tgaGFzaGBbSlNPTi5jcmVhdGVfaWRdfSkgIT0gbmlsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAjezo6T2JqZWN0LmNvbnN0X2dldChga2xhc3NgKS5qc29uX2NyZWF0ZShgaGFzaGApfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGF0dHJfYWNjZXNzb3IgOmNyZWF0ZV9pZFxuICBlbmRcblxuICBzZWxmLmNyZWF0ZV9pZCA9IDpqc29uX2NsYXNzXG5cbiAgZGVmIHNlbGYuW10odmFsdWUsIG9wdGlvbnMgPSB7fSlcbiAgICBpZiBTdHJpbmcgPT09IHZhbHVlXG4gICAgICBwYXJzZSh2YWx1ZSwgb3B0aW9ucylcbiAgICBlbHNlXG4gICAgICBnZW5lcmF0ZSh2YWx1ZSwgb3B0aW9ucylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYucGFyc2Uoc291cmNlLCBvcHRpb25zID0ge30pXG4gICAgZnJvbV9vYmplY3QoYCRwYXJzZShzb3VyY2UpYCwgb3B0aW9ucy5tZXJnZShwYXJzZTogdHJ1ZSkpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBhcnNlIShzb3VyY2UsIG9wdGlvbnMgPSB7fSlcbiAgICBwYXJzZShzb3VyY2UsIG9wdGlvbnMpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmxvYWQoc291cmNlLCBvcHRpb25zID0ge30pXG4gICAgZnJvbV9vYmplY3QoYCRwYXJzZShzb3VyY2UpYCwgb3B0aW9ucylcbiAgZW5kXG5cbiAgIyBSYXcganMgb2JqZWN0ID0+IG9wYWwgb2JqZWN0XG4gIGRlZiBzZWxmLmZyb21fb2JqZWN0KGpzX29iamVjdCwgb3B0aW9ucyA9IHt9KVxuICAgIG9wdGlvbnNbOm9iamVjdF9jbGFzc10gfHw9IEhhc2hcbiAgICBvcHRpb25zWzphcnJheV9jbGFzc10gIHx8PSBBcnJheVxuXG4gICAgYHRvX29wYWwoanNfb2JqZWN0LCBvcHRpb25zLiQkc21hcClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdlbmVyYXRlKG9iaiwgb3B0aW9ucyA9IHt9KVxuICAgIG9iai50b19qc29uKG9wdGlvbnMpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmR1bXAob2JqLCBpbyA9IG5pbCwgbGltaXQgPSBuaWwpXG4gICAgc3RyaW5nID0gZ2VuZXJhdGUob2JqKVxuXG4gICAgaWYgaW9cbiAgICAgIGlvID0gaW8udG9faW8gaWYgaW8ucmVzcG9uZHNfdG8/IDp0b19pb1xuICAgICAgaW8ud3JpdGUgc3RyaW5nXG5cbiAgICAgIGlvXG4gICAgZWxzZVxuICAgICAgc3RyaW5nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE9iamVjdFxuICBkZWYgdG9fanNvblxuICAgIHRvX3MudG9fanNvblxuICBlbmRcbmVuZFxuXG4jIEJVRzogRW51bWVyYWJsZSBtdXN0IGNvbWUgYmVmb3JlIEFycmF5LCBvdGhlcndpc2UgaXQgb3ZlcnJpZGVzICN0b19qc29uXG4jICAgICAgdGhpcyBpcyBkdWUgdG8gaG93IG1vZHVsZXMgYXJlIGltcGxlbWVudGVkLlxubW9kdWxlIEVudW1lcmFibGVcbiAgZGVmIHRvX2pzb25cbiAgICB0b19hLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgZGVmIHRvX2pzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7c2VsZn0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goI3tgc2VsZltpXWAudG9fanNvbn0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBCb29sZWFuXG4gIGRlZiB0b19qc29uXG4gICAgYChzZWxmID09IHRydWUpID8gJ3RydWUnIDogJ2ZhbHNlJ2BcbiAgZW5kXG5lbmRcblxuY2xhc3MgSGFzaFxuICBkZWYgdG9fanNvblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tga2V5YC50b19zLnRvX2pzb259ICsgJzonICsgI3tgdmFsdWVgLnRvX2pzb259KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgTmlsQ2xhc3NcbiAgZGVmIHRvX2pzb25cbiAgICAnbnVsbCdcbiAgZW5kXG5lbmRcblxuY2xhc3MgTnVtZXJpY1xuICBkZWYgdG9fanNvblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBhbGlhcyB0b19qc29uIGluc3BlY3RcbmVuZFxuXG5jbGFzcyBUaW1lXG4gIGRlZiB0b19qc29uXG4gICAgc3RyZnRpbWUoJyVGVCVUJXonKS50b19qc29uXG4gIGVuZFxuZW5kXG5cbmNsYXNzIERhdGVcbiAgZGVmIHRvX2pzb25cbiAgICB0b19zLnRvX2pzb25cbiAgZW5kXG5cbiAgZGVmIGFzX2pzb25cbiAgICB0b19zXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJyYWlzZSIsIm5ldyIsInB1c2giLCIkd3JpdGVyIiwiW109IiwiLSIsIjEiLCJbXSIsImNyZWF0ZV9pZCIsImNvbnN0X2dldCIsImpzb25fY3JlYXRlIiwiYXR0cl9hY2Nlc3NvciIsInNlbGYiLCJjcmVhdGVfaWQ9IiwiPT09IiwidmFsdWUiLCJwYXJzZSIsIm9wdGlvbnMiLCJnZW5lcmF0ZSIsImZyb21fb2JqZWN0IiwibWVyZ2UiLCJwYXJzZSEiLCJzb3VyY2UiLCJsb2FkIiwib2JqIiwidG9fanNvbiIsImR1bXAiLCJzdHJpbmciLCJpbyIsInJlc3BvbmRzX3RvPyIsInRvX2lvIiwid3JpdGUiLCJ0b19zIiwidG9fYSIsInN0cmZ0aW1lIiwiYXNfanNvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBa0IsNkJBQWxCQSxXQUFBO0FBQUEsSUFHQUE7QUFBQUEsSUFBQUE7O0FBQUFB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VCxTQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUE7QUFERjFCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL0xBO0FBQUEsRUFxTUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUEwQixJQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBTyxNQUFBQSxDQUFBQSxDQUFBUCxTQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQTtBQUFBLElBSUEsT0FBQVUsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUgsTUFBQUEsQ0FBQUE7QUFERkcsSUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQUpBO0FBREZwQyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXJNQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1NjEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9tYXBwaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ3JhbWJsaW5nLXRyaWUnXG5yZXF1aXJlICdqc29uJ1xuXG5tb2R1bGUgSW50ZXJzY3JpcHRcbiAgY2xhc3MgSW52YWxpZFN5c3RlbUVycm9yIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbiAgY2xhc3MgTWFwcGluZ1xuICAgIGF0dHJfcmVhZGVyKFxuICAgICAgOmlkLFxuICAgICAgOnVybCxcbiAgICAgIDpuYW1lLFxuICAgICAgOm5vdGVzLFxuICAgICAgOnJ1bGVzLFxuICAgICAgOnRlc3RzLFxuICAgICAgOmxhbmd1YWdlLFxuICAgICAgOnBvc3RydWxlcyxcbiAgICAgIDpjaGFyYWN0ZXJzLFxuICAgICAgOmRlc2NyaXB0aW9uLFxuICAgICAgOmF1dGhvcml0eV9pZCxcbiAgICAgIDpjcmVhdGlvbl9kYXRlLFxuICAgICAgOnNvdXJjZV9zY3JpcHQsXG4gICAgICA6ZGVzdGluYXRpb25fc2NyaXB0LFxuICAgICAgOmNoYWluLFxuICAgICAgOmNoYXJhY3Rlcl9zZXBhcmF0b3IsXG4gICAgICA6d29yZF9zZXBhcmF0b3IsXG4gICAgICA6dGl0bGVfY2FzZSxcbiAgICAgIDpkb3duY2FzZSxcbiAgICAgIDpkaWN0aW9uYXJ5LFxuICAgICAgOmNoYXJhY3RlcnNfaGFzaCxcbiAgICAgIDpkaWN0aW9uYXJ5X2hhc2gsXG4gICAgICA6c2VnbWVudGF0aW9uLFxuICAgICAgOnRyYW5zY3JpcHRpb24sXG4gICAgICA6ZGljdGlvbmFyeV90cmllXG4gICAgKVxuXG4gICAgZGVmIGluaXRpYWxpemUoc3lzdGVtX2NvZGUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIEBzeXN0ZW1fY29kZSA9IHN5c3RlbV9jb2RlXG4gICAgICBAZGVwdGggPSBvcHRpb25zLmZldGNoKDpkZXB0aCwgMCkudG9faVxuICAgICAgIyBAc3lzdGVtX3BhdGggPSBvcHRpb25zLmZldGNoKDpzeXN0ZW1fY29kZSwgZGVmYXVsdF9wYXRoKVxuXG4gICAgICBsb2FkX2FuZF9zZXJpYWxpemVfc3lzdGVtX21hcHBpbmdzXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5mb3Ioc3lzdGVtX2NvZGUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIG5ldyhzeXN0ZW1fY29kZSwgb3B0aW9ucylcbiAgICBlbmRcblxuICAgIGRlZiBsb2FkX2FuZF9zZXJpYWxpemVfc3lzdGVtX21hcHBpbmdzXG4gICAgICBpZiBkZXB0aCA8IDVcbiAgICAgICAgbWFwcGluZ3MgPSBsb2FkX3N5c3RlbV9tYXBwaW5nc1xuICAgICAgICAjIHJhaXNlIEludGVyc2NyaXB0OjpJbnZhbGlkU3lzdGVtRXJyb3IubmV3KFwiTm8gc3lzdGVtIG1hcHBpbmdzIGZvdW5kXCIpIHVubGVzcyBtYXBwaW5ncy5cbiAgICAgICAgc2VyaWFsaXplX3N5c3RlbV9tYXBwaW5ncyhtYXBwaW5ncykgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHByaXZhdGVcblxuICAgIGF0dHJfcmVhZGVyIDpkZXB0aCwgOnN5c3RlbV9jb2RlXG5cbiAgICAjIGRlZiBzeXN0ZW1fY29kZV9maWxlXG4gICAgIyAgIFtzeXN0ZW1fY29kZSwgXCJ5YW1sXCJdLmpvaW4oXCIuXCIpXG4gICAgIyBlbmRcblxuICAgICMgZGVmIGRlZmF1bHRfcGF0aFxuICAgICMgICBAZGVmYXVsdF9wYXRoIHx8PSBJbnRlcnNjcmlwdC5yb290X3BhdGguam9pbihcIm1hcHNcIilcbiAgICAjIGVuZFxuXG4gICAgZGVmIGxvYWRfc3lzdGVtX21hcHBpbmdzXG4gICAgICAjIEhhc2gubmV3KGB3aW5kb3cueWFtbF9maWxlc1sje3N5c3RlbV9jb2RlfV1gKSAjIEhhc2gubmV3IG5vdCB3b3JraW5nIHdpdGgganNvbiBzdHJpbmdcbiAgICAgIEpTT04ucGFyc2UoYEpTT04uc3RyaW5naWZ5KHdpbmRvdy55YW1sX2ZpbGVzWyN7c3lzdGVtX2NvZGV9XSlgKSBcbiAgICByZXNjdWUgRXJybm86OkVOT0VOVFxuICAgICAgcmFpc2UgSW50ZXJzY3JpcHQ6OkludmFsaWRTeXN0ZW1FcnJvci5uZXcoXCJObyBzeXN0ZW0gbWFwcGluZ3MgZm91bmRcIilcbiAgICBlbmRcblxuICAgIGRlZiBzZXJpYWxpemVfc3lzdGVtX21hcHBpbmdzKG1hcHBpbmdzKVxuICAgICAgQGlkID0gbWFwcGluZ3MuZmV0Y2goXCJpZFwiLCBuaWwpXG4gICAgICBAdXJsID0gbWFwcGluZ3MuZmV0Y2goXCJ1cmxcIiwgbmlsKVxuICAgICAgQG5hbWUgPSBtYXBwaW5ncy5mZXRjaChcIm5hbWVcIiwgbmlsKVxuICAgICAgQG5vdGVzID0gbWFwcGluZ3MuZmV0Y2goXCJub3Rlc1wiLCBuaWwpXG4gICAgICBAdGVzdHMgPSBtYXBwaW5ncy5mZXRjaChcInRlc3RzXCIsIFtdKVxuICAgICAgQGxhbmd1YWdlID0gbWFwcGluZ3MuZmV0Y2goXCJsYW5ndWFnZVwiLCBuaWwpXG4gICAgICBAZGVzY3JpcHRpb24gPSBtYXBwaW5ncy5mZXRjaChcImRlc2NyaXB0aW9uXCIsIG5pbClcbiAgICAgIEBhdXRob3JpdHlfaWQgPSBtYXBwaW5ncy5mZXRjaChcImF1dGhvcml0eV9pZFwiLCBuaWwpXG4gICAgICBAY3JlYXRpb25fZGF0ZSA9IG1hcHBpbmdzLmZldGNoKFwiY3JlYXRpb25fZGF0ZVwiLCBuaWwpXG4gICAgICBAc291cmNlX3NjcmlwdCA9IG1hcHBpbmdzLmZldGNoKFwic291cmNlX3NjcmlwdFwiLCBuaWwpXG4gICAgICBAZGVzdGluYXRpb25fc2NyaXB0ID0gbWFwcGluZ3MuZmV0Y2goXCJkZXN0aW5hdGlvbl9zY3JpcHRcIiwgbmlsKVxuICAgICAgQGNoYWluID0gbWFwcGluZ3MuZmV0Y2goXCJjaGFpblwiLCBbXSlcbiAgICAgIEBjaGFyYWN0ZXJfc2VwYXJhdG9yID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJjaGFyYWN0ZXJfc2VwYXJhdG9yXCJdIHx8IG5pbFxuICAgICAgQHdvcmRfc2VwYXJhdG9yID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJ3b3JkX3NlcGFyYXRvclwiXSB8fCBuaWxcbiAgICAgIEB0aXRsZV9jYXNlID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJ0aXRsZV9jYXNlXCJdIHx8IGZhbHNlXG4gICAgICBAZG93bmNhc2UgPSBtYXBwaW5nc1tcIm1hcFwiXVtcImRvd25jYXNlXCJdIHx8IGZhbHNlXG4gICAgICBAcnVsZXMgPSBtYXBwaW5nc1tcIm1hcFwiXVtcInJ1bGVzXCJdIHx8IFtdXG4gICAgICBAcG9zdHJ1bGVzID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJwb3N0cnVsZXNcIl0gfHwgW11cbiAgICAgIEBjaGFyYWN0ZXJzID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJjaGFyYWN0ZXJzXCJdIHx8IHt9XG4gICAgICBAZGljdGlvbmFyeSA9IG1hcHBpbmdzW1wibWFwXCJdW1wiZGljdGlvbmFyeVwiXSB8fCB7fVxuICAgICAgQHNlZ21lbnRhdGlvbiA9IG1hcHBpbmdzW1wibWFwXCJdW1wic2VnZW1lbnRhdGlvblwiXSB8fCBuaWxcbiAgICAgIEB0cmFuc2NyaXB0aW9uID0gbWFwcGluZ3NbXCJtYXBcIl1bXCJ0cmFuc2NyaXB0aW9uXCJdIHx8IG5pbFxuXG4gICAgICBpbmNsdWRlX2luaGVyaXRlZF9tYXBwaW5ncyhtYXBwaW5ncylcbiAgICAgIGJ1aWxkX2hhc2hlc1xuICAgICAgYnVpbGRfdHJpZVxuICAgIGVuZFxuXG4gICAgZGVmIGluY2x1ZGVfaW5oZXJpdGVkX21hcHBpbmdzKG1hcHBpbmdzKVxuICAgICAgaW5oZXJpdF9zeXN0ZW1zID0gW10ucHVzaChtYXBwaW5nc1tcIm1hcFwiXVtcImluaGVyaXRcIl0pLmZsYXR0ZW5cbiAgICAgIGZvciBpbmhlcml0X3N5c3RlbSBpbiBpbmhlcml0X3N5c3RlbXMgZG9cbiAgICAgICAgaWYgKGluaGVyaXRfc3lzdGVtKVxuICAgICAgICAgIGluaGVyaXRlZF9tYXBwaW5nID0gTWFwcGluZy5mb3IoaW5oZXJpdF9zeXN0ZW0sIGRlcHRoOiBkZXB0aCArIDEpXG5cbiAgICAgICAgICBAcnVsZXMgPSBbaW5oZXJpdGVkX21hcHBpbmcucnVsZXMsIHJ1bGVzXS5mbGF0dGVuXG4gICAgICAgICAgQHBvc3RydWxlcyA9IFtpbmhlcml0ZWRfbWFwcGluZy5wb3N0cnVsZXMsIHBvc3RydWxlc10uZmxhdHRlblxuICAgICAgICAgIEBjaGFyYWN0ZXJzID0gKGluaGVyaXRlZF9tYXBwaW5nLmNoYXJhY3RlcnN8fCB7fSkubWVyZ2UoY2hhcmFjdGVycylcbiAgICAgICAgICBAZGljdGlvbmFyeSA9IChpbmhlcml0ZWRfbWFwcGluZy5kaWN0aW9uYXJ5fHwge30pLm1lcmdlKGRpY3Rpb25hcnkpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgYnVpbGRfaGFzaGVzKClcbiAgICAgIEBjaGFyYWN0ZXJzX2hhc2ggPSBjaGFyYWN0ZXJzJi5zb3J0X2J5IHsgfGssIF92fCBrLnNpemUgfSYucmV2ZXJzZSYudG9faFxuICAgICAgQGRpY3Rpb25hcnlfaGFzaCA9IGRpY3Rpb25hcnkmLnNvcnRfYnkgeyB8aywgX3Z8IGsuc2l6ZSB9Ji5yZXZlcnNlJi50b19oXG4gICAgZW5kXG5cbiAgICBkZWYgYnVpbGRfdHJpZSgpXG4gICAgICBAZGljdGlvbmFyeV90cmllID0gUmFtYmxpbmc6OlRyaWUuY3JlYXRlXG4gICAgICBkaWN0aW9uYXJ5X3RyaWUuY29uY2F0IGRpY3Rpb25hcnkua2V5c1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJtb2R1bGUiLCJjbGFzcyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBzeXN0ZW1fY29kZSIsInN5c3RlbV9jb2RlIiwiQGRlcHRoIiwib3B0aW9ucyIsImZldGNoIiwiMCIsInRvX2kiLCJsb2FkX2FuZF9zZXJpYWxpemVfc3lzdGVtX21hcHBpbmdzIiwiZm9yIiwic2VsZiIsIm5ldyIsIjwiLCJkZXB0aCIsIjUiLCJtYXBwaW5ncyIsImxvYWRfc3lzdGVtX21hcHBpbmdzIiwic2VyaWFsaXplX3N5c3RlbV9tYXBwaW5ncyIsInByaXZhdGUiLCJwYXJzZSIsInJhaXNlIiwiQGlkIiwiQHVybCIsIkBuYW1lIiwiQG5vdGVzIiwiQHRlc3RzIiwiQGxhbmd1YWdlIiwiQGRlc2NyaXB0aW9uIiwiQGF1dGhvcml0eV9pZCIsIkBjcmVhdGlvbl9kYXRlIiwiQHNvdXJjZV9zY3JpcHQiLCJAZGVzdGluYXRpb25fc2NyaXB0IiwiQGNoYWluIiwiQGNoYXJhY3Rlcl9zZXBhcmF0b3IiLCJbXSIsIkB3b3JkX3NlcGFyYXRvciIsIkB0aXRsZV9jYXNlIiwiQGRvd25jYXNlIiwiQHJ1bGVzIiwiQHBvc3RydWxlcyIsIkBjaGFyYWN0ZXJzIiwiQGRpY3Rpb25hcnkiLCJAc2VnbWVudGF0aW9uIiwiQHRyYW5zY3JpcHRpb24iLCJpbmNsdWRlX2luaGVyaXRlZF9tYXBwaW5ncyIsImJ1aWxkX2hhc2hlcyIsImJ1aWxkX3RyaWUiLCJpbmhlcml0X3N5c3RlbXMiLCJwdXNoIiwiZmxhdHRlbiIsImVhY2giLCJpbmhlcml0X3N5c3RlbSIsImluaGVyaXRlZF9tYXBwaW5nIiwiKyIsIjEiLCJydWxlcyIsInBvc3RydWxlcyIsImNoYXJhY3RlcnMiLCJtZXJnZSIsImRpY3Rpb25hcnkiLCJAY2hhcmFjdGVyc19oYXNoIiwiayIsInNpemUiLCJAZGljdGlvbmFyeV9oYXNoIiwiQGRpY3Rpb25hcnlfdHJpZSIsImNyZWF0ZSIsImRpY3Rpb25hcnlfdHJpZSIsImNvbmNhdCIsImtleXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsTUFBUkEsQ0FEQTtBQUFBLEVBR0EsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBMkIsNkJBQTNCQSxXQUFBO0FBQUEsSUFFQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLFVBQUFDLGFBQUFBLENBQ0UsTUFDQSxPQUNBLFFBQ0EsU0FDQSxTQUNBLFNBQ0EsWUFDQSxhQUNBLGNBQ0EsZUFDQSxnQkFDQSxpQkFDQSxpQkFDQSxzQkFDQSxTQUNBLHVCQUNBLGtCQUNBLGNBQ0EsWUFDQSxjQUNBLG1CQUNBLG1CQUNBLGdCQUNBLGlCQUNBLGlCQXpCRkEsQ0FBQTtBQUFBO0FBNEJBQyxNQUFBQSw4QkFBQUEsd0JBQUFBLHNCQUFlLFdBQUQsRUFBYyxPQUE1QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBcENKO0FBb0NnQyxRQUFBO0FBQUEsUUFBQSxZQUFVLFlBQUEsRUFBVjtBQUFBLFFBQUEsQ0FwQ2hDO0FBQUEsUUFxQ01DLG1CQUFlQyxXQXJDckI7QUFBQSxRQXNDTUMsYUFBU0MsT0FBQUMsT0FBQUEsQ0FBYyxTQUFRQyxDQUF0QkQsQ0FBQUUsTUFBQUEsQ0FBQUEsQ0F0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QUFFLENBQUFDLE1BQUFBLENBQUFBLENBeEh2RCxDQUFBLG1CQUFBLGtCQUFBLE1Bd0h5QixDQUFBLENBQUEscUNBQUEsTUFBQSxFQUFBLFdBQUEsRUFBQSxFQUFBLENBQUEsQ0FBQSxxQ0FBQSxNQUFBLEVBQUEsUUFBQSxFQUFBLEVBQUEsQ0FBQSxDQUFuQkMsQ0FEQTtBQURGbEIsTUFBQUEsQ0FBQUEscUNBQUFBLENBOUdBO0FBQUEsTUFtSEEsT0FBQUMsQ0FBQUEsOEJBQUFBLHlCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQWtCLHVCQUFtQixJQUFBLHdCQUFBLFNBQUFDLFFBQUFBLENBQUFBLENBQW5CO0FBQUEsUUFDQSxXQUFBQyxpQkFBQUEsQ0FBQUEsQ0FBQUMsUUFBQUEsS0FBdUJSLFlBQUFBLENBQUFBLENBQUFTLE1BQUFBLENBQUFBLENBQXZCRCxDQURBO0FBREZyQixNQUFBQSxDQUFBQSxvQ0FBQUEsQ0FBQUEsc0JBbkhBO0FBREZoRCxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBO0FBREZELEVBQUFBLEdBQUFBLFdBQUFBLFdBSEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTc5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vaW50ZXJzY3JpcHQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBmcm96ZW5fc3RyaW5nX2xpdGVyYWw6IHRydWVcbnJlcXVpcmUgXCJvcGFsXCJcbnJlcXVpcmUgXCJ5YW1sXCJcbnJlcXVpcmUgXCJtYXBwaW5nXCJcblxuIyBUcmFuc2xpdGVyYXRpb25cbm1vZHVsZSBJbnRlcnNjcmlwdFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICAjIGRlZiByb290X3BhdGhcbiAgICAjICAgQHJvb3RfcGF0aCB8fD0gUGF0aG5hbWUubmV3KEZpbGUuZGlybmFtZShfX2Rpcl9fKSlcbiAgICAjIGVuZFxuXG4gICAgIyBkZWYgdHJhbnNsaXRlcmF0ZV9maWxlKHN5c3RlbV9jb2RlLCBpbnB1dF9maWxlLCBvdXRwdXRfZmlsZSwgbWFwcz17fSlcbiAgICAjICAgaW5wdXQgPSBGaWxlLnJlYWQoaW5wdXRfZmlsZSlcbiAgICAjICAgb3V0cHV0ID0gdHJhbnNsaXRlcmF0ZShzeXN0ZW1fY29kZSwgaW5wdXQsIG1hcHMpXG5cbiAgICAjICAgRmlsZS5vcGVuKG91dHB1dF9maWxlLCAndycpIGRvIHxmfFxuICAgICMgICAgIGYucHV0cyhvdXRwdXQpXG4gICAgIyAgIGVuZFxuICAgICMgICBwdXRzIFwiT3V0cHV0IHdyaXR0ZW4gdG86ICN7b3V0cHV0X2ZpbGV9XCJcbiAgICAjIGVuZFxuXG4gICAgIyBkZWYgaW1wb3J0X3B5dGhvbl9tb2R1bGVzXG4gICAgIyAgIGJlZ2luXG4gICAgIyAgICAgcHlpbXBvcnQgOmcycHdyYXBwZXJcbiAgICAjICAgcmVzY3VlXG4gICAgIyAgICAgcHlpbXBvcnQgOnN5c1xuICAgICMgICAgIHN5cy5wYXRoLmFwcGVuZChyb290X3BhdGgudG9fcytcIi9saWIvXCIpXG4gICAgIyAgICAgcHlpbXBvcnQgOmcycHdyYXBwZXJcbiAgICAjICAgZW5kXG4gICAgIyBlbmRcblxuICAgICMgZGVmIGV4dGVybmFsX3Byb2Nlc3MocHJvY2Vzc19uYW1lLCBzdHJpbmcpXG4gICAgIyAgIGltcG9ydF9weXRob25fbW9kdWxlc1xuICAgICMgICBjYXNlIHByb2Nlc3NfbmFtZVxuICAgICMgICAgIHdoZW4gJ3NlcXVpdHVyLnB5dGhhaW5scF9sZXhpY29uJ1xuICAgICMgICAgICAgcmV0dXJuIGcycHdyYXBwZXIudHJhbnNsaXRlcmF0ZSgncHl0aGFpbmxwX2xleGljb24nLCBzdHJpbmcpXG4gICAgIyAgICAgd2hlbiAnc2VxdWl0dXIud2lrdGlvbmFyeV9waG9uZW1pYydcbiAgICAjICAgICAgIHJldHVybiBnMnB3cmFwcGVyLnRyYW5zbGl0ZXJhdGUoJ3dpa3Rpb25hcnlfcGhvbmVtaWMnLCBzdHJpbmcpXG4gICAgIyAgIGVsc2VcbiAgICAjICAgICBwdXRzIFwiSW52YWxpZCBQcm9jZXNzXCJcbiAgICAjICAgZW5kXG4gICAgIyBlbmRcblxuICAgIGRlZiB0cmFuc2xpdGVyYXRlKHN5c3RlbV9jb2RlLCBzdHJpbmcsIG1hcHM9e30pXG4gICAgICBpZiAoIW1hcHMuaGFzX2tleT9zeXN0ZW1fY29kZSlcbiAgICAgICAgbWFwc1tzeXN0ZW1fY29kZV0gPSBJbnRlcnNjcmlwdDo6TWFwcGluZy5mb3Ioc3lzdGVtX2NvZGUpXG4gICAgICBlbmRcbiAgICAgICMgbWFwcGluZyA9IEludGVyc2NyaXB0OjpNYXBwaW5nLmZvcihzeXN0ZW1fY29kZSlcbiAgICAgIG1hcHBpbmcgPSBtYXBzW3N5c3RlbV9jb2RlXVxuXG5cbiAgICAgICMgRmlyc3QsIGFwcGx5IGNoYWluZWQgdHJhbnNsaXRlcmF0aW9uIGFzIHNwZWNpZmllZCBpbiB0aGUgbGlzdCBgY2hhaW5gXG4gICAgICBjaGFpbiA9IG1hcHBpbmcuY2hhaW4uZHVwXG4gICAgICB3aGlsZSBjaGFpbi5sZW5ndGggPiAwXG4gICAgICAgIHN0cmluZyA9IHRyYW5zbGl0ZXJhdGUoY2hhaW4uc2hpZnQsIHN0cmluZywgbWFwcylcbiAgICAgIGVuZFxuXG4gICAgICAjIFRoZW4sIGFwcGx5IHRoZSByZXN0IG9mIHRoZSBtYXBcbiAgICAgIHNlcGFyYXRvciA9IG1hcHBpbmcuY2hhcmFjdGVyX3NlcGFyYXRvciB8fCBcIlwiXG4gICAgICB3b3JkX3NlcGFyYXRvciA9IG1hcHBpbmcud29yZF9zZXBhcmF0b3IgfHwgXCJcIlxuICAgICAgdGl0bGVfY2FzZSA9IG1hcHBpbmcudGl0bGVfY2FzZVxuICAgICAgZG93bmNhc2UgPSBtYXBwaW5nLmRvd25jYXNlXG5cbiAgICAgICMgY2hhcm1hcCA9IG1hcHBpbmcuY2hhcmFjdGVycyYuc29ydF9ieSB7IHxrLCBfdnwgay5zaXplIH0mLnJldmVyc2UmLnRvX2hcbiAgICAgICMgZGljdG1hcCA9IG1hcHBpbmcuZGljdGlvbmFyeSYuc29ydF9ieSB7IHxrLCBfdnwgay5zaXplIH0mLnJldmVyc2UmLnRvX2hcbiAgICAgIGNoYXJtYXAgPSBtYXBwaW5nLmNoYXJhY3RlcnNfaGFzaFxuICAgICAgZGljdG1hcCA9IG1hcHBpbmcuZGljdGlvbmFyeV9oYXNoXG4gICAgICB0cmllID0gbWFwcGluZy5kaWN0aW9uYXJ5X3RyaWVcblxuICAgICAgIyBTZWdtZW50YXRpb25cbiAgICAgICMgc3RyaW5nID0gZXh0ZXJuYWxfcHJvY2VzcyhtYXBwaW5nLnNlZ21lbnRhdGlvbiwgc3RyaW5nKSBpZiBtYXBwaW5nLnNlZ21lbnRhdGlvblxuXG4gICAgICAjIFRyYW5zbGl0ZXJhdGlvbi9UcmFuc2NyaXB0aW9uXG4gICAgICAjIHN0cmluZyA9IGV4dGVybmFsX3Byb2Nlc3MobWFwcGluZy50cmFuc2NyaXB0aW9uLCBzdHJpbmcpIGlmIG1hcHBpbmcudHJhbnNjcmlwdGlvblxuXG4gICAgICBwb3MgPSAwXG4gICAgICB3aGlsZSBwb3MgPCBzdHJpbmcudG9fcy5zaXplXG4gICAgICAgIG0gPSAwXG4gICAgICAgIHdvcmRtYXRjaCA9IFwiXCJcblxuICAgICAgICAjIFVzaW5nIFRyaWUsIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2hpbmcgc3Vic3RyaW5nXG4gICAgICAgIHdoaWxlIChwb3MgKyBtIDwgc3RyaW5nLnRvX3Muc2l6ZSkgJiYgKHRyaWUucGFydGlhbF93b3JkP3N0cmluZ1twb3MuLnBvcyttXSkgXG4gICAgICAgICAgd29yZG1hdGNoID0gc3RyaW5nW3Bvcy4ucG9zK21dIGlmIHRyaWUud29yZD9zdHJpbmdbcG9zLi5wb3MrbV1cbiAgICAgICAgICBtICs9IDFcbiAgICAgICAgZW5kXG4gICAgICAgIG0gPSB3b3JkbWF0Y2gubGVuZ3RoXG4gICAgICAgIGlmIG0gPiAwXG4gICAgICAgICAgcmVwbCA9IGRpY3RtYXBbc3RyaW5nW3Bvcy4ucG9zK20tMV1dXG4gICAgICAgICAgc3RyaW5nW3Bvcy4ucG9zK20tMV0gPSByZXBsXG4gICAgICAgICAgcG9zICs9IHJlcGwubGVuZ3RoXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwb3MgKz0gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBvdXRwdXQgPSBzdHJpbmcuY2xvbmVcbiAgICAgIG9mZnNldHMgPSBBcnJheS5uZXcgc3RyaW5nLnRvX3Muc2l6ZSwgMVxuXG4gICAgICAjIG1hcHBpbmcucnVsZXMuZWFjaCBkbyB8cnxcbiAgICAgICMgICBzdHJpbmcudG9fcy5zY2FuKC8je3JbJ3BhdHRlcm4nXX0vKSBkbyB8bWF0Y2hlc3xcbiAgICAgICMgICAgIG1hdGNoID0gUmVnZXhwLmxhc3RfbWF0Y2hcbiAgICAgICMgICAgIHBvcyA9IG1hdGNoLm9mZnNldCgwKS5maXJzdFxuICAgICAgIyAgICAgcmVzdWx0ID0gclsncmVzdWx0J10uY2xvbmVcbiAgICAgICMgICAgIG1hdGNoZXMuZWFjaC53aXRoX2luZGV4IHsgfHYsIGl8IHJlc3VsdC5zdWIhKC9cXFxcI3tpICsgMX0vLCB2KSB9IGlmIG1hdGNoZXMuaXNfYT8gQXJyYXlcbiAgICAgICMgICAgIHJlc3VsdC51cGNhc2UhIGlmIHVwX2Nhc2VfYXJvdW5kPyhzdHJpbmcsIHBvcylcbiAgICAgICMgICAgIG91dHB1dFtvZmZzZXRzWzAuLi5wb3NdLnN1bSwgbWF0Y2hbMF0uc2l6ZV0gPSByZXN1bHRcbiAgICAgICMgICAgIG9mZnNldHNbcG9zXSArPSByZXN1bHQuc2l6ZSAtIG1hdGNoWzBdLnNpemVcbiAgICAgICMgICBlbmRcbiAgICAgICMgZW5kXG4gICAgICBtYXBwaW5nLnJ1bGVzLmVhY2ggZG8gfHJ8XG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5nc3ViKC8je3JbJ3BhdHRlcm4nXX0vdSwgclsncmVzdWx0J10pXG4gICAgICBlbmRcblxuICAgICAgY2hhcm1hcC5lYWNoIGRvIHxrLCB2fFxuICAgICAgICB3aGlsZSAobWF0Y2ggPSBvdXRwdXQmLm1hdGNoKC8je2t9L3UpKVxuICAgICAgICAgIHBvcyA9IG1hdGNoLm9mZnNldCgwKS5maXJzdFxuICAgICAgICAgIHJlc3VsdCA9ICFkb3duY2FzZSAmJiB1cF9jYXNlX2Fyb3VuZD8ob3V0cHV0LCBwb3MpID8gdi51cGNhc2UgOiB2XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdIGlmIHJlc3VsdC5pc19hPyhBcnJheSkgIyBpZiBtb3JlIHRoYW4gb25lLCBjaG9vc2UgdGhlIGZpcnN0IG9uZVxuICAgICAgICAgICMgb3V0cHV0W3BvcywgbWF0Y2hbMF0uc2l6ZV0gPSBhZGRfc2VwYXJhdG9yKHNlcGFyYXRvciwgcG9zLCByZXN1bHQpXG4gICAgICAgICAgb3V0cHV0ID0gb3V0cHV0WzAsIHBvc10gKyBhZGRfc2VwYXJhdG9yKHNlcGFyYXRvciwgcG9zLCByZXN1bHQpICsgb3V0cHV0Wyhwb3MrbWF0Y2hbMF0uc2l6ZSkuLi0xXVxuICAgICAgICBlbmRcbiAgICAgIGVuZCAgICAgIFxuXG4gICAgICBtYXBwaW5nLnBvc3RydWxlcy5lYWNoIGRvIHxyfFxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQuZ3N1YigvI3tyWydwYXR0ZXJuJ119L3UsIHJbJ3Jlc3VsdCddKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG91dHB1dFxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3ViKC9eKC4pLywgICY6dXBjYXNlKSBpZiB0aXRsZV9jYXNlXG4gICAgICAgIGlmIHdvcmRfc2VwYXJhdG9yICE9ICcnXG4gICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmdzdWIoLyN7d29yZF9zZXBhcmF0b3J9I3tzZXBhcmF0b3J9L3Usd29yZF9zZXBhcmF0b3IpXG4gICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmdzdWIoLyN7d29yZF9zZXBhcmF0b3J9KC4pL3UsICY6dXBjYXNlKSBpZiB0aXRsZV9jYXNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIG91dHB1dCA/IG91dHB1dC51bmljb2RlX25vcm1hbGl6ZSA6IG91dHB1dFxuICAgIGVuZFxuXG4gICAgcHJpdmF0ZVxuXG4gICAgZGVmIGFkZF9zZXBhcmF0b3Ioc2VwYXJhdG9yLCBwb3MsIHJlc3VsdClcbiAgICAgIHBvcyA9PSAwID8gcmVzdWx0IDogc2VwYXJhdG9yICsgcmVzdWx0XG4gICAgZW5kXG5cbiAgICBkZWYgdXBfY2FzZV9hcm91bmQ/KHN0cmluZywgcG9zKVxuICAgICAgcmV0dXJuIGZhbHNlIGlmIHN0cmluZ1twb3NdID09IHN0cmluZ1twb3NdLmRvd25jYXNlXG5cbiAgICAgIGkgPSBwb3MgLSAxXG4gICAgICBpIC09IDEgd2hpbGUgaS5wb3NpdGl2ZT8gJiYgc3RyaW5nW2ldICF+IC9cXHB7TH0vdVxuICAgICAgYmVmb3JlID0gaSA+PSAwICYmIGkgPCBwb3MgPyBzdHJpbmdbaV0udG9fcy5zdHJpcCA6ICcnXG5cbiAgICAgIGkgPSBwb3MgKyAxXG4gICAgICBpICs9IDEgd2hpbGUgaSA8IHN0cmluZy5zaXplIC0gMSAmJiBzdHJpbmdbaV0gIX4gL1xccHtMfS91XG4gICAgICBhZnRlciA9IGkgPiBwb3MgPyBzdHJpbmdbaV0udG9fcy5zdHJpcCA6ICcnXG5cbiAgICAgIGJlZm9yZV91YyA9ICFiZWZvcmUuZW1wdHk/ICYmIGJlZm9yZSA9PSBiZWZvcmUudXBjYXNlXG4gICAgICBhZnRlcl91YyA9ICFhZnRlci5lbXB0eT8gJiYgYWZ0ZXIgPT0gYWZ0ZXIudXBjYXNlXG4gICAgICAjIGJlZm9yZV91YyAmJiAoYWZ0ZXIuZW1wdHk/IHx8IGFmdGVyX3VjKSB8fCBhZnRlcl91YyAmJiAoYmVmb3JlLmVtcHR5PyB8fCBiZWZvcmVfdWMpXG4gICAgICBiZWZvcmVfdWMgfHwgYWZ0ZXJfdWNcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwidHJhbnNsaXRlcmF0ZSIsIm1hcHMiLCJoYXNfa2V5PyIsInN5c3RlbV9jb2RlIiwiISIsIiR3cml0ZXIiLCJmb3IiLCJbXT0iLCItIiwiMSIsIm1hcHBpbmciLCJbXSIsImNoYWluIiwiZHVwIiwiPiIsImxlbmd0aCIsIjAiLCJzdHJpbmciLCJzaGlmdCIsInNlcGFyYXRvciIsImNoYXJhY3Rlcl9zZXBhcmF0b3IiLCJ3b3JkX3NlcGFyYXRvciIsInRpdGxlX2Nhc2UiLCJkb3duY2FzZSIsImNoYXJtYXAiLCJjaGFyYWN0ZXJzX2hhc2giLCJkaWN0bWFwIiwiZGljdGlvbmFyeV9oYXNoIiwidHJpZSIsImRpY3Rpb25hcnlfdHJpZSIsInBvcyIsIjwiLCJ0b19zIiwic2l6ZSIsIm0iLCJ3b3JkbWF0Y2giLCIrIiwicGFydGlhbF93b3JkPyIsIndvcmQ/IiwicmVwbCIsIm91dHB1dCIsImNsb25lIiwib2Zmc2V0cyIsIm5ldyIsImVhY2giLCJydWxlcyIsImdzdWIiLCJyIiwibWF0Y2giLCJrIiwib2Zmc2V0IiwiZmlyc3QiLCJyZXN1bHQiLCJ1cF9jYXNlX2Fyb3VuZD8iLCJ2IiwidXBjYXNlIiwiaXNfYT8iLCJhZGRfc2VwYXJhdG9yIiwiLTEiLCJwb3N0cnVsZXMiLCJzdWIiLCIhPSIsInVuaWNvZGVfbm9ybWFsaXplIiwicHJpdmF0ZSIsIj09IiwiaSIsInBvc2l0aXZlPyIsIiF+IiwiYmVmb3JlIiwiPj0iLCJzdHJpcCIsImFmdGVyIiwiYmVmb3JlX3VjIiwiZW1wdHk/IiwiYWZ0ZXJfdWMiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUFBQSxTQUFBQSxDQUFRLE1BQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLE1BQVJBLENBREE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLFNBQVJBLENBRkE7QUFBQSxFQUtBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFFRTtBQUFBLE1BQUE7O0FBQUE7QUFxQ0U7QUFBQUMsTUFBQUEsaUNBQUFBLG1CQUFBQSx5QkFBa0IsV0FBRCxFQUFjLE1BQWQsRUFBc0IsSUFBdkNBO0FBQUFBLFFBQUFBOztBQUFBQTtBQTlDSjtBQThDMkMsUUFBQTtBQUFBLFFBQUEsU0FBSyxZQUFBLEVBQUw7QUFBQSxRQUFBLENBOUMzQztBQUFBLFFBK0NNLElBQUEsUUFBS0MsSUFBQUMs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